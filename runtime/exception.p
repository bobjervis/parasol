/*
   Copyright 2015 Robert Jervis

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
/**
 * Provides facilities for performing exception handling and
 * also a set of commonly thrown exceptions.
 *
 * Much of the code in this namespace is present there (and not public) to proide support to
 * throw and try-catch code generated by the compiler.
 *
 * The included exceptions are the common exceptions either thrown due to hardware exceptions or
 * common runtime library conditions.
 */
namespace parasol:exception;

import parasol:context;
import parasol:memory;
import parasol:process;
import parasol:pxi;
import parasol:runtime;
import parasol:storage;
import parasol:thread;
import native:windows;
import native:linux;
import native:C;
/**
 * This function throws an AssertionFailedException if the test is false.
 *
 * @exception AssertionFailedException when the test argument value is false.
 */
public void assert(boolean test) {
	if (!test)
		throw AssertionFailedException();
}

class GlobalState {
	ref<OSExceptionHandling> _OSExceptionHandling;

	GlobalState() {
		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
			_OSExceptionHandling = new WindowsExceptionHandling();
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
			_OSExceptionHandling = new LinuxExceptionHandling();
		}
	}

	~GlobalState() {
		delete _OSExceptionHandling;
	}
}

GlobalState globalState;

class OSExceptionHandling {
}

class WindowsExceptionHandling extends OSExceptionHandling {
	address _handle;

	WindowsExceptionHandling() {
		_handle = windows.AddVectoredExceptionHandler(0, windowsExceptionHandler);
	}

	~WindowsExceptionHandling() {
		windows.RemoveVectoredExceptionHandler(_handle);
	}

	static long windowsExceptionHandler(ref<windows.EXCEPTION_POINTERS> exceptionInfo) {
		ref<ExceptionContext> context = createExceptionContext(address(exceptionInfo.ContextRecord.Rsp));
		context.framePointer = address(exceptionInfo.ContextRecord.Rbp);
		context.exceptionAddress = address(exceptionInfo.ContextRecord.Rip);
		context.exceptionType = int(exceptionInfo.ExceptionRecord.ExceptionCode);
		switch (exceptionInfo.ExceptionRecord.ExceptionCode) {
		case 0xc0000374:
			throw CorruptHeapException(context);

		case 0xc00000fd:
			throw StackOverflowException(context);

		case 0xc0000005:
		case 0xc0000006:
			context.memoryAddress = address(exceptionInfo.ExceptionRecord.ExceptionInformation_1);
			context.exceptionFlags = int(exceptionInfo.ExceptionRecord.ExceptionInformation_0);
			if (context.memoryAddress == null)
				throw NullPointerException(context);
			else
				throw AccessException(context);

		case 0xc0000094:
			throw DivideByZeroException(context);
		}
		printf("exception %x at %p\n", context.exceptionType, context.exceptionAddress);
		printf("Unexpected exception type\n");
		throw RuntimeException(context);
	}
}

class LinuxExceptionHandling extends OSExceptionHandling {
	private linux.struct_sigaction oldSigIllAction;
	private linux.struct_sigaction oldSigSegvAction;
	private linux.struct_sigaction oldSigFpeAction;
	private linux.struct_sigaction oldSigQuitAction;
	private linux.struct_sigaction oldSigAbortAction;
	private linux.struct_sigaction oldSigTermAction;

	LinuxExceptionHandling() {
		linux.struct_sigaction newGeneralAction;
		linux.struct_sigaction newSegvAction;

		newGeneralAction.set_sa_sigaction(sigGeneralHandler);
		newGeneralAction.sa_flags = linux.SA_SIGINFO;
		newSegvAction.set_sa_sigaction(sigSegvHandler);
		newSegvAction.sa_flags = linux.SA_SIGINFO;
		linux.sigaction(linux.SIGILL, &newGeneralAction, &oldSigIllAction);
		linux.sigaction(linux.SIGSEGV, &newSegvAction, &oldSigSegvAction);
		linux.sigaction(linux.SIGFPE, &newGeneralAction, &oldSigFpeAction);
		linux.sigaction(linux.SIGQUIT, &newGeneralAction, &oldSigQuitAction);
		linux.sigaction(linux.SIGABRT, &newGeneralAction, &oldSigAbortAction);
		linux.sigaction(linux.SIGTERM, &newGeneralAction, &oldSigTermAction);
	}

	~LinuxExceptionHandling() {
		linux.sigaction(linux.SIGILL, &oldSigIllAction, null);
		linux.sigaction(linux.SIGSEGV, &oldSigSegvAction, null);
		linux.sigaction(linux.SIGFPE, &oldSigFpeAction, null);
		linux.sigaction(linux.SIGQUIT, &oldSigQuitAction, null);
		linux.sigaction(linux.SIGABRT, &oldSigAbortAction, null);
		linux.sigaction(linux.SIGTERM, &oldSigTermAction, null);
	}

	static ref<ExceptionContext> fillExceptionInfo(ref<linux.siginfo_t> info, ref<linux.ucontext_t> uContext) {
		ref<ExceptionContext> context = createExceptionContext(address(uContext.uc_mcontext.gregs.rsp));
		context.exceptionAddress = address(uContext.uc_mcontext.gregs.rip);
		context.framePointer = address(uContext.uc_mcontext.gregs.rbp);
		context.exceptionType = (info.si_signo << 8) + info.si_code;
		context.exceptionFlags = info.si_errno;
		return context;
	}
	
	static void sigGeneralHandler(int signum, ref<linux.siginfo_t> info, ref<linux.ucontext_t> uContext) {
		ref<ExceptionContext> context = fillExceptionInfo(info, uContext);
		switch (signum) {
		case linux.SIGFPE:
			throw DivideByZeroException(context);
			
		case linux.SIGILL:
			throw IllegalInstructionException(context);

		case linux.SIGABRT:
			throw CRuntimeException(context);

		case linux.SIGQUIT:
			if (info.si_code == linux.SI_USER)
				dumpAllThreads(context);
			else
				dumpMyThread(context);
			thread.exit();

		case linux.SIGTRAP:
			throw CRuntimeException(context);

		case linux.SIGTERM:
			if (interruptResponse.interrupt())
				return;
		}
		printf("Unexpected signal %d at %p\n", signum, context.exceptionAddress);
		throw RuntimeException(context);
	}
	
	static void sigSegvHandler(int signum, ref<linux.siginfo_t> info, ref<linux.ucontext_t> uContext) {
		ref<ExceptionContext> context = fillExceptionInfo(info, uContext);
		context.memoryAddress = address(info.si_addr());
		switch (info.si_code) {
		case linux.SI_KERNEL:
		case linux.SEGV_MAPERR:
			if (context.memoryAddress == null)
				throw NullPointerException(context);
			else
				throw AccessException(context);	
			
		case linux.SEGV_ACCERR:
			throw PermissionsException(context);

		default:
			printf("SIGSEGV at %p, unexpected exception code %x\n", context.exceptionAddress, info.si_code);
			throw RuntimeException(context);
		}
	}
}

/**
 * This is the base class for all exceptions.
 *
 * An object must have a class that extends Exception to be used as an operand of a {@code throw}
 * statement.
 *
 * Note: Currently, a thrown exception caches an ExceptionContext object to hold the stack trace
 * of the exception. This memory is not re-claimed.
 * 
 * @threading It is not thread safe to throw the same exception object in two different threads
 * at the same time.
 */
public class Exception {
	protected ref<ExceptionContext> _exceptionContext;
	string _message;
	/**
	 * Constructs a new Exception with no message text.
	 */
	public Exception() {
		
	}
	/**
	 * Constructs a new Exception with message text.
	 *
	 * The message is formatted using a string.printf using the
	 * format and parameters supplied in the constructor.
	 *
	 * @param format a printf-style format for The text of the 
	 * message to be printed.
	 * @param parameters any parameters needed for the message.
	 */
	public Exception(string format, var... parameters) {
		_message.printf(format, parameters);
	}
	
	Exception(ref<ExceptionContext> exceptionContext) {
		_exceptionContext = exceptionContext;
	}
	
	public ref<Exception> clone() {
		ref<Exception> n = new Exception(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
	/**
	 * Retrieves the value of the Exception message text, if any.
	 *
	 * @return If not null, the message text of the Exception.
	 */
	public string message() {
		return _message;
	}
	/**
	 * Write the contents of the {@link textStackTrace} return value
	 * to the process standard output.
	 */
	public void printStackTrace() {
		string s = textStackTrace();
		if (s == null)
			s = "Exception was never thrown, no stack trace.\n";
		process.stdout.write(s);
	}
	/**
	 * Compose a text stack trace.
	 *
	 * @return If the exception was thrown, then this returns the text stack trace. If the
	 * Exception has never been thrown, then it returns null.
	 */
	public string textStackTrace() {
		if (_exceptionContext == null)
			return null;
		string output;
		boolean locationIsExact = true;

		if (_exceptionContext.exceptionType == 0)
			locationIsExact = false;
//		printf("    failure address %p\n", _exceptionContext.exceptionAddress);
		address stackHigh = pointer<byte>(_exceptionContext.stackPointer) + _exceptionContext.stackSize;
		address ip = _exceptionContext.exceptionAddress;
		pointer<byte> ip_ptr = pointer<byte>(ip);
		// If the exception address is not in Parasol code, then start by printing all possible
		// Parasol code addresses found on thes tack, in case the C stack doesn't work out
		if (ip_ptr < runtime.image.codeAddress() || ip_ptr >= runtime.image.highCodeAddress()) {
			output.printf("Exception address is outside Parasol code space, dumping Parasol code addresses found on the stack:\n\n");
			int relativeSp = 0;
			for (pointer<pointer<byte>> sp = pointer<pointer<byte>>(_exceptionContext.stackPointer);
							sp < pointer<pointer<byte>>(stackHigh) + -2; sp++, relativeSp += address.bytes) {
				pointer<byte> possible_ip = pointer<byte>(_exceptionContext.slot(sp));
				if (possible_ip >= runtime.image.codeAddress() && possible_ip < runtime.image.highCodeAddress()) {
					int relative = int(possible_ip) - int(runtime.image.codeAddress());
					if (possible_ip == runtime.image.entryPoint())
						break;
					string locationLabel = formattedLocation(possible_ip, relative, false);
					output.printf("     sp+0x%x: %s\n", relativeSp, locationLabel);
				}
			}
			output.printf("\n");
		}
		string tag = "->";
		int lowCode = int(runtime.image.codeAddress());
		int staticMemoryLength = int(runtime.image.highCodeAddress()) - lowCode;
		int ignoreFrames = ignoreTopFrames();
		pointer<address> frame;
		int(address, address) comparator = comparatorCurrentIp;
		for (;;) {
			ref<pxi.X86_64ExceptionEntry> ee;
			address ip;
			(ee, frame, ip) = nextFrame(frame, false, comparator);
			if (frame == null)
				break;
			comparator = comparatorReturnAddress;

			int relative = int(ip) - lowCode;
			if (ignoreFrames > 0)
				ignoreFrames--;
			else {
				string locationLabel = formattedLocation(ip, relative, locationIsExact);
				output.printf(" %2s %s\n", tag, locationLabel);
				tag = "";
			}
			locationIsExact = false;
		}
		return output;
	}
	
	int ignoreTopFrames() {
		return 0;
	}
	
	void throwNow(address framePointer, address stackPointer) {
		
		// The default treatment is that the return address just under the stackPointer is the starting point for
		// 'throw' resolution. That will cover the cases where the exception context doesn't exist (this is a plain
		// 'throw' statement), or this is a re-thrown exception (in which case the lastCrawledFramePointer will not be
		// null). If there is an _exceptionContext set but no lastCrawledFramePointer, we are processing a hardware
		// exception for the first time.
		
		int(address, address) comparator = comparatorReturnAddress;
		pointer<address> frame;
		boolean useRealStack;
		if (_exceptionContext == null) {
			// An inital throw statement of an unthrown exception
			_exceptionContext = createExceptionContext(stackPointer);
			_exceptionContext.framePointer = framePointer;
			_exceptionContext.exceptionAddress = pointer<address>(stackPointer)[-1];
		} else if (_exceptionContext.lastCrawledFramePointer == null) {
			// first time handling of a hardware exception
			comparator = comparatorCurrentIp;
		} else { // else a re-thrown exception
			frame = pointer<address>(stackPointer) + -2;
			useRealStack = true;
		}
		pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(exceptionsAddress());
		pointer<pxi.X86_64ExceptionEntry> eeFirst = ee;
		int count = exceptionsCount();
		pointer<byte> lowCode = runtime.image.codeAddress();
		for (;;) {
//			printf("  frame = %p \n", frame);
			ref<pxi.X86_64ExceptionEntry> ee;
			address ip;
			(ee, frame, ip) = nextFrame(frame, useRealStack, comparator);
//			printf("  -> frame %p ip %p (%x) ee = [%d]\n", frame, ip, pointer<byte>(ip) - lowCode, 
//											ee != null ? pointer<pxi.X86_64ExceptionEntry>(ee) - eeFirst : -1);
			if (frame == null)
				break;

			if (ee != null) {
				_exceptionContext.lastCrawledFramePointer = frame;
//				printf("Calling handler: %x\n", ee.handler);
				callCatchHandler(this, frame, ee.handler);
				process.exit(1);
			}
			comparator = comparatorReturnAddress;
		}
		printf("\nFATAL: Thread %s could not find a stack handler for this address.\n", thread.currentThread().name());
		printf("Parasol code based at %p\n", runtime.image.codeAddress());
		process.stdout.write(textStackTrace());
		process.exit(1);
	}

	private ref<pxi.X86_64ExceptionEntry>, pointer<address>, address nextFrame(pointer<address> lastFrame, boolean useRealStack, int comparator(address ip, address elem)) {
//		printf("nextFrame(%p, %s)\n", lastFrame, comparator == comparatorCurrentIp ? "current ip" : "return address");
		pointer<address> frame;
		pointer<byte> ip;

		pointer<byte> lowCode = runtime.image.codeAddress();
		pointer<byte> highCode = runtime.image.highCodeAddress();
		pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(exceptionsAddress());
		int count = exceptionsCount();
		if (count == 0) {
			printf("No exceptions table for this image.\n");
			process.exit(1);
		}
//		printf("ee = %p count = %d\n", ee, count);

		if (lastFrame == null) {
			frame = pointer<address>(_exceptionContext.framePointer);
			ip = pointer<byte>(_exceptionContext.exceptionAddress);
			// The initial 'lastFrame' starting point (as if there was a saved RBP, IP pair there) would
			// be just below the stack pointer.
			lastFrame = pointer<address>(_exceptionContext.stackPointer) + -2;
		} else {
			if (useRealStack) {
				frame = pointer<address>(lastFrame[0]);
				ip = pointer<byte>(lastFrame[1]);
			} else {
				frame = pointer<address>(_exceptionContext.slot(lastFrame));
				ip = pointer<byte>(_exceptionContext.slot(lastFrame + 1));
			}
		}
		address stackTop = address(long(_exceptionContext.stackBase) + _exceptionContext.stackSize);
		pointer<address> searchEnd = pointer<address>(stackTop) + -2;
		int location = int(ip - lowCode);
//		printf("location %x %p ? %p ? %p\n", location, address(lastFrame + 2), frame, searchEnd);


		if (frame < lastFrame + 2 || frame >= searchEnd) {
			// For whatever reason, the frame we are trying to use as the next place to start looking
			// for a return address is no good, so guess by checking all possible values. As soon as we
			// see a stack slot containing a possible next 
			for (frame = lastFrame + 2; ; frame++) {
				if (frame >= searchEnd) {
					frame = null;
					break;
				}
				pointer<address> nextFrame;
				if (useRealStack)
					nextFrame = pointer<address>(*frame);
				else
					nextFrame = pointer<address>(_exceptionContext.slot(frame));
				if (nextFrame >= frame + 2 && nextFrame < searchEnd)
					break;
			}
		}

//		printf("lowCode = %p highCode = %p\n", lowCode, highCode);
		if (ip >= lowCode && ip < highCode) {
			int location = int(ip - lowCode);
//			printf("%x Checking location %x", frame, location);
			address result = bsearch(&location, ee, count, pxi.X86_64ExceptionEntry.bytes, comparator);
//			printf(" -> found %d\n", pointer<pxi.X86_64ExceptionEntry>(result) - ee);
			if (result != null) {
				ref<pxi.X86_64ExceptionEntry> ee = ref<pxi.X86_64ExceptionEntry>(result);

//				printf("(handler %x)\n", ee.handler);

				// If we have a handler, call it.
				if (ee.handler != 0)
					return ee, frame, ip;
			} //else 
//				printf("\n");
		} //else
//			printf("frame with non-Parasol ip %x\n", frame);

		return null, frame, ip;
	} 
	/*
	 * findStack confirms whether there are any valid stack frames (ones with Parasol code from
	 * this image in them). Second, if it is valid, it counts how many frames there are so calling code
	 * can allocate storage for the stack walk.
	 * 
	 * 
	 * RETURNS:	-1 if this could not be confirmed to be a valid Parasol stack, or >= 1 for
	 * 			valid stacks (the number is the number of stack frames found).
	 */
	private int countStackFrames(pointer<address> frame) {
		pointer<address> oldRbp;
		pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(exceptionsAddress());
		int count = exceptionsCount();
		if (count == 0) {
			printf("No exceptions table for this image.\n");
			process.exit(1);
		}
		pointer<byte> lowCode = runtime.image.codeAddress();
		pointer<byte> highCode = runtime.image.highCodeAddress();
		int(address, address) comparator = comparatorCurrentIp;
		address stackTop = address(long(_exceptionContext.stackBase) + _exceptionContext.stackSize);
		pointer<address> plausibleEnd = pointer<address>(stackTop) + -2;
		int frames = 0;
		boolean confirmed;
		do {
			oldRbp = frame;
			pointer<byte> ip = pointer<byte>(frame[1]);
			if (ip >= lowCode && ip < highCode)
				confirmed = true;
			frame = pointer<address>(*frame);
			comparator = comparatorReturnAddress;
			frames++;
		} while (frame > oldRbp && frame < plausibleEnd);
		if (confirmed)
			return frames;
		else
			return -1;
	}
	
	ref<ExceptionContext> exceptionContext() {
		return _exceptionContext;
	}
}

private address bsearch(address key, address tableAddress, int tableSize, int rowSize, int comparator(address a, address b)) {
	pointer<byte> table = pointer<byte>(tableAddress);
	while (tableSize > 0) {
		int midIndex = tableSize / 2;
		pointer<byte> midPoint = table + midIndex * rowSize;
		int comp = comparator(key, midPoint);
		if (comp < 0)
			tableSize = midIndex;
		else if (comp > 0) {
			table = midPoint + rowSize;
			tableSize -= midIndex + 1; 
		} else
			return midPoint;
	}
	return null;
}

private int comparatorCurrentIp(address ip, address elem) {
	int location = *ref<int>(ip);
	pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(elem);

	if (location < ee[0].location)
		return -1;
	else if (location < ee[1].location)
		return 0;
	else
		return 1;
}

private int comparatorReturnAddress(address ip, address elem) {
	int location = *ref<int>(ip);
	pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(elem);

	if (location <= ee[0].location)
		return -1;
	else if (location <= ee[1].location)
		return 0;
	else
		return 1;
}
/**
 * This exception is thrown by array subscript operations that are out of bounds for the array.
 */
public class BoundsException extends Exception {
	public BoundsException() {
	}
	
	public BoundsException(string message) {
		super(message);
	}

	ref<BoundsException> clone() {
		ref<BoundsException> n = new BoundsException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}	
}
/**
 * This exception is thrown by a variety of runtime functions if an invalid argument value
 * is supplied.
 */
public class IllegalArgumentException extends Exception {
	public IllegalArgumentException() {
	}

	public IllegalArgumentException(string message) {
		super(message);
	}

	ref<IllegalArgumentException> clone() {
		ref<IllegalArgumentException> n = new IllegalArgumentException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
}
/**
 * This exception is thrown by a variety of runtime functions if an invalid call is mode.
 *
 * This is usually caused when a method on an object is called and the object is not in a valid
 * state for that method.
 */
public class IllegalOperationException extends Exception {
	public IllegalOperationException() {
	}

	public IllegalOperationException(string message) {
		super(message);
	}

	ref<IllegalOperationException> clone() {
		ref<IllegalOperationException> n = new IllegalOperationException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
}
/**
 * This exception is thrown by a variety of runtime functions if a call detected an error on
 * an external I/O device.
 *
 * This is most commonly triggered when reading or writing to an external device like a disk
 * or network connection. It is not triggered by an end-of-file condition, nor by a failed
 * file system operation. Those conditions must be detected by inspection of return values.
 */
public class IOException extends Exception {
	public IOException() {
	}

	public IOException(string message) {
		super(message);
	}

	ref<IOException> clone() {
		ref<IOException> n = new IOException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
}
/**
 * This exception is triggered by a SIGABRT signal and is generally a symptom of a
 * C runtime library failure. Most commonly, this is caused by corruption of the C memory heap.
 */
public class CRuntimeException extends RuntimeException {
	public CRuntimeException() {
		
	}

	CRuntimeException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<CRuntimeException> clone() {
		ref<CRuntimeException> n = new CRuntimeException();
		n._exceptionContext = _exceptionContext;
		return n;
	}	
}
/**
 * This is the base class for a group of (usually) hardware-detected exceptions.
 */
public class RuntimeException extends Exception {
	RuntimeException() {
	}
	
	RuntimeException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	public string message() {
		if (_exceptionContext == null)
			return "RuntimeException (not thrown)\n";
		string output;
		output.printf("RuntimeException: ");

		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
			pointer<byte> message = formatMessage(unsigned(_exceptionContext.exceptionType));

			string text(message);
			output.printf("%x", _exceptionContext.exceptionType);
			if (message != null) {
				if (text.endsWith("\r\n"))
					text = text.substr(0, text.length() - 2);
				output.printf(" (%s)", text);
			}
			output.printf(" ip %p", _exceptionContext.exceptionAddress);
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX)
			output.printf("%x", _exceptionContext.exceptionType);
		return output;
	}
	
	ref<RuntimeException> clone() {
		ref<RuntimeException> n = new RuntimeException(_exceptionContext);
		return n;
	}	

}

@Linux("libparasol.so.1", "formatMessage")
@Windows("parasol.dll", "formatMessage")
abstract pointer<byte> formatMessage(unsigned ntstatus);
/**
 * This exception is thrown by an integeer divide by zero. Note that a floating point
 * divide by zero will return a value of infinity and will not throw this exception.
 */
public class DivideByZeroException extends RuntimeException {
	DivideByZeroException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}

	ref<DivideByZeroException> clone() {
		ref<DivideByZeroException> n = new DivideByZeroException(_exceptionContext);
		return n;
	}	

}
/**
 * This exception is thrown when the machine executes an illegal instruction. The immediate causes can
 * be quite varied, but traces back to a bad pointer or ref value being used somewhere. 
 */
public class IllegalInstructionException extends RuntimeException {
	IllegalInstructionException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}

	ref<IllegalInstructionException> clone() {
		ref<IllegalInstructionException> n = new IllegalInstructionException(_exceptionContext);
		return n;
	}	

	public string message() {
		if (_exceptionContext == null)
			return "IllegalInstructionException (not thrown)\n";
		return "IllegalInstructionException";
	}
	
}
/**
 * This exception is raised by a call to assert with a false value.
 */
public class AssertionFailedException extends RuntimeException {
	AssertionFailedException() {
	}

	ref<AssertionFailedException> clone() {
		ref<AssertionFailedException> n = new AssertionFailedException();
		n._exceptionContext = _exceptionContext;
		return n;
	}	

	public string message() {
		if (_exceptionContext == null)
			return "AssertionFailedException (not thrown)\n";
		return "Assertion failed";
	}
	
	int ignoreTopFrames() {
		return 1;
	}
}
/**
 * This exception is returned when the Parasol memory allocation code detects a corrupted heap
 * data structure.
 */
public class CorruptHeapException extends RuntimeException {
	CorruptHeapException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<CorruptHeapException> clone() {
		ref<CorruptHeapException> a = new CorruptHeapException(_exceptionContext);
		return a;
	}
}
/**
 * This exception is generated in response to a stack overflow on some operating systems, such as Windows.
 * Linux systems do not give the failing thread any opportunity to process an exception for this condition.
 */
public class StackOverflowException extends RuntimeException {
	StackOverflowException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<StackOverflowException> clone() {
		ref<StackOverflowException> a = new StackOverflowException(_exceptionContext);
		return a;
	}
}
/**
 * This exception is thrown is response to a reference to an invalid address value, other than zero.
 */
public class AccessException extends RuntimeException {
	AccessException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<AccessException> clone() {
		ref<AccessException> a = new AccessException(_exceptionContext);
		return a;
	}

	public string message() {
		if (_exceptionContext == null)
			return "AccessException (not thrown)\n";
		string output;
		output.printf("AccessException: flags %d referencing %p", _exceptionContext.exceptionFlags, _exceptionContext.memoryAddress);
		return output;
	}
}
/**
 * This exception is thrown when a zero address value is referenced. Due to the way that hardware
 * instructions report failures, the detected failing address could be a small offset from zero, even
 * though any user visible object contains a zero address. For that reason, it is better to catch an
 * AccessException (this classes base class), which will include all invalid memory references.
 */
public class NullPointerException extends AccessException {
	NullPointerException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<NullPointerException> clone() {
		ref<NullPointerException> n = new NullPointerException(_exceptionContext);
		return n;
	}

	public string message() {
		if (_exceptionContext == null)
			return "NullPointerException (not thrown)\n";
		string output;
		output.printf("NullPointerException: flags %d referencing %p", _exceptionContext.exceptionFlags, _exceptionContext.memoryAddress);
		return output;
	}
}
/**
 * This is a variation of AccessException caused by inappropriate permissions on the memory location in
 * question. Typically, this will be caused by trying to write to read-only memory or trying to 
 * execute an instruction in data-only memory.
 */
public class PermissionsException extends AccessException {
	PermissionsException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<PermissionsException> clone() {
		ref<PermissionsException> n = new PermissionsException(_exceptionContext);
		return n;
	}
}
/**
 * Throw an exception. It performs the exact same semantics as the throw statement.
 * The throw statement will generate this call (and provide the magic frame and stack pointer).
 *  
 * Note: This function does not return.
 * 
 * @param e The non-null Exception to be thrown.
 * @param frame The frame pointer when the exception was thrown.
 * @param stackPointer The stack pointer when the exception was thrown.
 */
void throwException(ref<Exception> e, address frame, address stackPointer) {
	e.clone().throwNow(frame, stackPointer);
	printf("Thrown!\n");
}
/**
 * Intercept an uncaught exception. This code is called from the catch handler that encloses the static initializers.
 * 
 * It is called under the scope of the ExecutionContext of the code throwing the exception. Doing this inside the
 * enclosed ExecutionContext means that the source locations are correctly aligned for the stack trace.
 * 
 * Note that this handler also exposes the exception so that the caller to eval knows that the call failed because of an
 * uncaught exception.
 * 
 * @param e The uncaught exeption.  
 */
public void uncaughtException(ref<Exception> e) {
	memory.resetHeap();
	int id = thread.currentThread().id();
	if (process.stdout == null) {
		string s;
		s.printf("\nUncaught exception in thread %d!\n\n%s\n", id, e.message());
		s += e.textStackTrace();
		linux.write(1, &s[0], s.length());
	} else {
		printf("\nUncaught exception in thread %d!\n\n%s\n", id, e.message());
		e.exceptionContext().print();
		e.printStackTrace();
		process.stdout.flush();
	}
	exposeException(e);
}
/**
 * Register an interrupt handler.
 *
 * An operating system generally has some mechanism for communicating asynchronous events to
 * a running process. One such event is usually designated 'interrupt' and is intended to trigger
 * a graceful but expeditious shutdown of the process.
 *
 *
 * The handler function is expected to return true if the process should ignore the interrupt
 * signal. If the function returns false, the interrupt will generate an operating system specific 
 * failure, which may be to throw a RunTimeException.
 *
 * If the desire is to have the process issue a successful completion, the interrupt handler
 * should explicitly call process.exit and not return at all.
 *
 * On Linux, registering an interrupt handler will catch the SIGTERM signal. If the handler
 * function returns false, the SIGTERM handler is set to default and a SIGTERM signal is sent to
 * the process.
 *
 * @param handler The function to call when an interrupt signal is received.
 * @param argument The argument to pass to the handler function.
 *
 * @threading This function is thread safe.
 *
 * @return The previous intterupt handler, or null if no handler has yet been registered.
 * @return The previous handler argument, or null if no handler has yet been registered.
 */
public boolean(address), address handleInterrupt(boolean(address) handler, address argument) {
	return interruptResponse.handleInterrupt(handler, argument);
}

monitor class InterruptResponse {
	private boolean(address) _handler;
	private address _argument;

	public boolean interrupt() {
		if (_handler != null)
			return _handler(_argument);
		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
			linux.signal(linux.SIGTERM, linux.SIG_DFL);
			linux.kill(linux.getpid(), linux.SIGTERM);
		}
		return false;
	}

	public boolean(address), address handleInterrupt(boolean(address) handler, address argument) {
		boolean(address) oldHandler = _handler;
		address oldArgument = _argument;
		_handler = handler;
		_argument = argument;
		return oldHandler, oldArgument;
	}
}

InterruptResponse interruptResponse;

/*
 * dispatchException is called from the compiler when deciding which catch clause to execute when an exception is
 * thrown.
 * 
 * Note that the body of the exception is copied from the tmeporary location to the destination if there is a match.
 * 
 * PARAMETERS
 * 	e			The thrown exception. May be any type derived from Exception.
 * 	t			The type record of the Exception class that this handler matches.
 * 	destination	If the thrown exception's type matches the passed type, then the exception is copied.
 * 	size		The amount to copy.
 * 	
 * RETURNS	true if the exception should be handled, false if it should not
 */
boolean dispatchException(ref<Exception> e, ref<runtime.Class> c, ref<Exception> destination, int size) {
	ref<runtime.Class> actual = **ref<ref<ref<runtime.Class>>>(e);

//	printf("dispatchException %p actual %p t %p equals %s isSubtype %s\n", e, actual, t, actual.equals(t) ? "true" : "false", actual.isSubtype(t) ? "true" : "false");
//		printf("actual class %x t class %x\n", pxiOffset(**ref<ref<address>>(actual)), pxiOffset(**ref<ref<address>>(t)));
//		printf("actual vtable %x t vtable %x\n", pxiOffset(*ref<address>(actual)), pxiOffset(*ref<address>(t)));
//		printf("actual family %s t family %s\n", string(actual.family()), string(t.family()));
//	}
//	if (t.class == BuiltInType) {
//		printf("t._classType = %x\n", pxiOffset(ref<BuiltInType>(t).classType()));
//		printf("t._classType vatble %x\n", pxiOffset(*ref<address>(ref<BuiltInType>(t).classType())));
//	}
	if (*actual <= *c) {
		C.memcpy(destination, e, size);
		return true;
	} else
		return false;
}

private int pxiOffset(address a) {
	return int(a) - int(runtime.image.codeAddress());
	
}

ref<ExceptionContext> createExceptionContext(address stackPointer) {
	address top = runtime.stackTop();

	long stackSize;
	if (top == null)
		// This isn't a Parasol stack. There is no trace of Parasol on it. So, only trust the current
		// page.
		stackSize = ((long(stackPointer) + 8192) & ~long(0x1fff)) - long(stackPointer);
	else
		stackSize = long(top) - long(stackPointer);
	if (stackSize > 32 * 1024)
		stackSize = 32 * 1024;		// Limit dumps of really big stacks.
	pointer<byte> mem = pointer<byte>(memory.alloc(stackSize + ExceptionContext.bytes));
	ref<ExceptionContext> results = ref<ExceptionContext>(mem);
	results.stackCopy = mem + ExceptionContext.bytes;
	C.memcpy(results.stackCopy, stackPointer, stackSize);
	results.stackPointer = stackPointer;
	results.stackBase = stackPointer;
	results.stackSize = int(stackSize);
	return results;
}

/**
 * This method records in the runtime's ExecutionContext the given exception, if this is passed a null,
 * the 'uncaught exception' indicator is effectively reset. If passed a null, the enclosing ExecutionContext
 * will detect that an uncaught exception terminated execution.
 */
@Linux("libparasol.so.1", "exposeException")
@Windows("parasol.dll", "exposeException")
private abstract void exposeException(ref<Exception> e);
/** @ignore
 * This function is a support routine the Parasol compiler uses when running a compiled image.
 *
 * After calling the image entry point and returning, the compiler code calls this function to
 * retrieve any uncaught exception thrown in the Parasol image. If the return value is null, the
 * image code returned normally. If not null, it is the address of the uncaught exception.
 *
 * @return The function returns the address of any uncaught exception, or null if the image returned
 * normally.
 */
@Linux("libparasol.so.1", "fetchExposedException")
@Windows("parasol.dll", "fetchExposedException")
public abstract ref<Exception> fetchExposedException();

@Linux("libparasol.so.1", "exceptionsAddress")
@Windows("parasol.dll", "exceptionsAddress")
abstract address exceptionsAddress();
@Linux("libparasol.so.1", "exceptionsCount")
@Windows("parasol.dll", "exceptionsCount")
abstract int exceptionsCount();

@Linux("libparasol.so.1", "callCatchHandler")
@Windows("parasol.dll", "callCatchHandler")
abstract void callCatchHandler(ref<Exception> exception, address frame, int handler);

class ExceptionContext {
	address exceptionAddress;		// The machine instruction causing the exception
	address stackPointer;			// The thread stack point at the moment of the exception
	address framePointer;			// The hardware frame pointer at the moment of the exception
	address lastCrawledFramePointer;	// Used when re-throwing an exception to ensure proper crawl.

	// This is a copy of the hardware stack at the time of the exception.  It may extend beyond the actual
	// hardware stack at the moment of the exception because, for example, the call to create the copy used
	// the address of a local variable to get a stack offset.
	
	// To compute the address in the copy from a forensic machine address, use the following:
	//
	//	COPY_ADDRESS = STACK_ADDRESS - stackBase + stackCopy;
	
	address stackBase;			// The machine address of the hardware stack this copy was taken from
	pointer<byte> stackCopy;	// The first byte of the copy
	address memoryAddress;		// Valid only for access exceptions: memory location referenced
	int exceptionType;			// Exception type
	int exceptionFlags;			// Flags (dependent on type).
	int stackSize;				// The length of the copy
	
	boolean valid(address stackAddress) {
		return pointer<byte>(stackBase) <= pointer<byte>(stackAddress) &&
				pointer<byte>(stackAddress) < pointer<byte>(stackBase) + stackSize;
	}

	long slot(address stackAddress) {
		if (!valid(stackAddress))
			return 0;
		long addr = long(stackAddress);
		long base = long(stackBase);
		long copy = long(address(stackCopy));
		long target = addr - base + copy;
		ref<long> copyAddress = ref<long>(address(target));
		return *copyAddress;
	}
	
	void print() {
		printf("    exception address          %p\n", exceptionAddress);
		printf("    stack pointer              %p\n", stackPointer);
		printf("    frame pointer              %p\n", framePointer);
		printf("    last crawled frame pointer %p\n", lastCrawledFramePointer);
		printf("    stack base                 %p\n", stackBase);
		printf("    stack top                  %p\n", long(stackBase) + stackSize);
		printf("    exception type             %x\n", unsigned(exceptionType));
		printf("    exception flags            %x\n", unsigned(exceptionFlags));
	}
}
/**
 * Construct a string representing a machine location, including information about relative location
 * within a compiled image.
 *
 * @param ip The machine address to obtain a source location for.
 *
 * @param offset The offset into the Parasol code image where the symbol could be found. If
 * the value is negative, then only the ip is used and it is assumed to be outside Parasol code.
 *
 * @param locationIsExact true if this is the exact address you care about. For example, if
 * it is the return address from a function, it may be pointing to the next source line so
 * pass false to this parameter and the code will adjust to look for the location one byte before
 * the given address.
 *
 * @return The formatted string.
 *
 * If the location is outside a compiled Parasol image, a native operating system utility is used to obtain
 * as good a symbolic address as reasonably possible. If no good symbolic address is available, then the
 * hex address is formatted.
 *
 * If the location is inside a compile Parasol image, the Parasol source filename and line number is returned,
 * along with the image-relative offset of the machine code.
 */
public string formattedLocation(address ip, int offset, boolean locationIsExact) {
	string filename;
	int lineNumber;
	(filename, lineNumber) = runtime.image.getSourceLocation(ip, locationIsExact);
	if (filename == null) {
		return formattedExternalLocation(ip);
	} else {
		string result;
		result.printf("%s %d", filename, lineNumber);
		if (offset != 0)
			result.printf(" (@%x)", offset);
		return result;
	}
}
/*
class FileStat {
	string  filename;
	boolean _parsed;
	boolean _rootFile;
    string _domain;
    address _namespaceSymbol;
    address _namespaceNode;
    address _fileScope;
    address _tree;
    boolean _scopesBuilt;
    boolean _staticsInitialized;
    string _source;
    ref<compiler.Scanner> scanner;
}
 */
private string formattedExternalLocation(address ip) {
	string result;
	if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
	} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
		linux.Dl_info info;

		if (ip != null && linux.dladdr(ip, &info) != 0) {
			long symOffset = long(ip) - long(info.dli_saddr);
			if (info.dli_sname == null)
				result.printf("%s (@%p)", string(info.dli_fname), ip); 
			else
				result.printf("%s %s+0x%x (@%p)", string(info.dli_fname), string(info.dli_sname), symOffset, ip); 
			return result;
		}
	}
	result.printf("@%p", ip);
	return result;
}

private Monitor serializeDumps;

private void dumpMyThread(ref<ExceptionContext> context) {
	ref<thread.Thread> t = thread.currentThread();
	Exception e(context);
	lock (serializeDumps) {
		printf("\nThread %s (%d) stack\n", t.name(), t.id());
		process.stdout.flush();
		string s = e.textStackTrace();
		if (s.length() == 0)
			context.print();
		else
			printf("%s", s);
	}
}

private void dumpAllThreads(ref<ExceptionContext> context) {
	printf("\n\nSIGQUIT dump:\n\n");
	dumpMyThread(context);
	ref<thread.Thread> t = thread.currentThread();
	ref<thread.Thread>[] threads = thread.getActiveThreads();
	int pid = linux.getpid();
	for (int i = 0; i < threads.length(); i++) {
		if (threads[i] == t || threads[i] == null)
			continue;
//		printf("t %p thread %p\n", t, threads[i]);
		linux.tgkill(pid, int(threads[i].id()), linux.SIGQUIT);
	}
	thread.sleep(1000);
}
