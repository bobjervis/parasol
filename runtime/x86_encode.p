/*
   Copyright 2015 Robert Jervis

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
namespace parasol:x86_64;

import native:C;

import parasol:compiler;
import parasol:compiler.Access;
import parasol:compiler.Binary;
import parasol:compiler.Block;
import parasol:compiler.ClassScope;
import parasol:compiler.CompileContext;
import parasol:compiler.Constant;
import parasol:compiler.EnumInstanceType;
import parasol:compiler.EnumType;
import parasol:compiler.FIRST_USER_METHOD;
import parasol:compiler.FlagsInstanceType;
import parasol:compiler.FunctionType;
import parasol:compiler.InterfaceImplementationScope;
import parasol:compiler.Lock;
import parasol:compiler.MessageId;
import parasol:compiler.Node;
import parasol:compiler.NodeList;
import parasol:compiler.Operator;
import parasol:compiler.OrdinalMap;
import parasol:compiler.OverloadInstance;
import parasol:compiler.ParameterScope;
import parasol:compiler.PlainSymbol;
import parasol:compiler.Reference;
import parasol:compiler.Scope;
import parasol:compiler.Segment;
import parasol:compiler.Selection;
import parasol:compiler.StorageClass;
import parasol:compiler.Symbol;
import parasol:compiler.Target;
import parasol:compiler.Ternary;
import parasol:compiler.ThunkScope;
import parasol:compiler.Try;
import parasol:compiler.Type;
import parasol:compiler.TypedefType;
import parasol:compiler.Unary;
import parasol:compiler.Unit;
import parasol:compiler.Variable;
import parasol:context;
import parasol:storage;
import parasol:math.abs;
import parasol:memory;
import parasol:pxi;
import parasol:runtime;
import parasol:text;
/*
 * X86-64 instruction mnemonics generated by the compiler.
 */
enum X86 {
	ADD,
	ADDSD,
	ADDSS,
	AND,
	CALL,
	CMP,
	CVTSD2SI,
	CVTSD2SS,
	CVTSI2SD,
	CVTSI2SS,
	CVTSS2SD,
	CVTSS2SI,
	CVTTSD2SI,
	CVTTSS2SI,
	CWD,
	DIV,
	DIVSD,
	DIVSS,
	ENTER,
	IDIV,
	IMUL,
	LEA,
	LEAVE,
	MOV,
	MOVSD,
	MOVSS,
	MOVSX,
	MOVSX_REX_W,
	MOVSXD,
	MOVZX,
	MOVZX_8,
	MUL,
	MULSD,
	MULSS,
	NEG,
	NOT,
	OR,
	POP,
	PUSH,
	PXOR,
	RET,
	SAL,
	SAR,
	SBB,
	SHR,
	SUB,
	SUBSD,
	SUBSS,
	TEST,
	UCOMISD,
	UCOMISS,
	XCHG,
	XOR,
	XORPD,
	XORPS,
	MAX_INSTRUCTION
}

int REGISTER_PARAMETER_STACK_AREA = 4 * address.bytes;

enum JumpDistance {
	UNKNOWN,
	SHORT,
	NEAR
}

class DeferredTry {
	public ref<X86_64Encoder.CodeSegment> primaryHandler;
	public ref<Try> tryStatement;
	public ref<Lock> lockStatement;
	public ref<X86_64Encoder.CodeSegment> join;
	public ref<X86_64Encoder.CodeSegment> exceptionHandler;

	void print() {
		if (tryStatement != null) {
			printf("tryStatement:\n");
			tryStatement.print(4);
		}
		if (lockStatement != null) {
			printf("lockStatment:\n");
			lockStatement.print(4);
		}
		printf("primaryHandler %p join %p exceptionHandler %p\n", primaryHandler, join, exceptionHandler);
//		if (primaryHandler != null) {
			
	}
}

private int FIRST_STACK_PARAM_OFFSET = 16;

/*
 * The X86_64 image section is laid out as follows:
 * 
 * 		Section Header
 * 		
 * 		Image Offset 0:
 *			The image is laid out in sections, according to the
 *			values in the Segments enum (in x86_encode.p). The
 *			encoder writes them to the named segments and the final stage
 *			of code generation concatenates them into the completed image.
 */

class X86_64WinSection extends pxi.Section {
	private ref<X86_64> _target;
	
	public X86_64WinSection(ref<X86_64> target) {
		super(runtime.Target.X86_64_WIN);
		_target = target;
	}
	
	public long length() {
		return _target.imageLength();
	}
	
	public boolean write(storage.File pxiFile) {
		return _target.writePxiFile(pxiFile);
	}
}

class X86_64LnxSection extends pxi.Section {
	private ref<X86_64> _target;
	
	public X86_64LnxSection(ref<X86_64> target) {
		super(runtime.Target.X86_64_LNX_SRC);
		_target = target;
	}
	
	public long length() {
		return _target.imageLength();
	}
	
	public boolean write(storage.File pxiFile) {
		return _target.writePxiFile(pxiFile);
	}
}

enum Segments {
	CODE,
	TYPE_DATA,
	EXCEPTION_TABLE,
	NATIVE_BINDINGS,
	VTABLES,

	DATA_8,
	STRINGS,
	DATA_4,
	DATA_2,
	DATA_1,

	BUILT_INS_TEXT,
	SOURCE_LOCATIONS,
	SOURCE_FILE_INDICES,
	SOURCE_FILE_OFFSETS,
	SOURCE_FILE_NAMES,
	SOURCE_FILE_LINE_INDICES,
	SOURCE_FILE_LINE_COUNTS,
	SOURCE_FILE_BASE_LINES,
	LINE_FILE_OFFSETS,
	RELOCATIONS,
	MAXIMUM,
	ALLOCATED
}

class NativeBinding {
	pointer<byte> dllName;
	pointer<byte> symbolName;
	address functionAddress;
}

class X86_64Encoder extends Target {
	protected pxi.X86_64SectionHeader _pxiHeader;
	protected memory.NoReleasePool _storage;
	protected pointer<byte> _staticMemory;
	protected int _staticMemoryLength;
	protected runtime.SourceLocation[] _sourceLocations;
	protected int[ref<Unit>] _sourceFileMap;
	protected DeferredTry[] _deferredTry;
	protected ref<Segment>[Segments] _segments;
	protected ref<Symbol>[] _nativeBindingSymbols;
	
	private ref<CodeSegment>[] _exceptionHandlers;
	private ref<Symbol>[][] _dataMap;
	private ref<Scope>[] _functionMap;
	private OrdinalMap _ordinalMap;
	private ref<FunctionState> _f;
	private byte[] _functionCode;
	private ref<ClassScope>[] _vtables;
	private ref<JumpContext> _jumpContext;
	private TempStack _t;
	private ref<Fixup> _fixups;
	private int[] _builtIns;								// The set of built-ins referenced by this
															// file.
	
	protected X86_64Encoder() {
		_dataMap.resize(9);
		_segments.resize(Segments.ALLOCATED);
		_segments[Segments.CODE] = new Segment(8, 0x37);
		_segments[Segments.TYPE_DATA] = new Segment(8);
		_segments[Segments.EXCEPTION_TABLE] = new Segment(8);
		_segments[Segments.NATIVE_BINDINGS] = new Segment(8);
		_segments[Segments.VTABLES] = new Segment(8);

		_segments[Segments.DATA_8] = new Segment(8);
		_segments[Segments.STRINGS] = new Segment(4);
		_segments[Segments.DATA_4] = new Segment(4);
		_segments[Segments.DATA_2] = new Segment(2);
		_segments[Segments.DATA_1] = new Segment(1);

		_segments[Segments.BUILT_INS_TEXT] = new Segment(1);
		_segments[Segments.SOURCE_LOCATIONS] = new Segment(4);
		_segments[Segments.SOURCE_FILE_INDICES] = new Segment(4);
		_segments[Segments.SOURCE_FILE_OFFSETS] = new Segment(4);
		_segments[Segments.SOURCE_FILE_NAMES] = new Segment(4);
		_segments[Segments.SOURCE_FILE_LINE_INDICES] = new Segment(4);
		_segments[Segments.SOURCE_FILE_LINE_COUNTS] = new Segment(4);
		_segments[Segments.SOURCE_FILE_BASE_LINES] = new Segment(4);
		_segments[Segments.LINE_FILE_OFFSETS] = new Segment(4);
		_segments[Segments.RELOCATIONS] = new Segment(4);
		_segments[Segments.MAXIMUM] = new Segment(1);
	}
	
	~X86_64Encoder() {
		_segments.deleteAll();
	}

	boolean generateCode(ref<Unit> mainFile, ref<CompileContext> compileContext) {
		_segments[Segments.SOURCE_LOCATIONS].reserve(pxi.X86_64SourceMap.bytes);
		if (mainFile != null) {
			// Storage has been allocated in the derived class for all static objects.
			// Now we need to generate the executable code for the static initializers,
			// along with the call to main (if any).
	
			_pxiHeader.entryPoint = generateFunction(mainFile.scope(), compileContext);
	
			// Now generate some more functions that might have been missed during the static code generation.
			prepareVTables(compileContext);
			
			if (_segments[Segments.CODE].length() == 0) {
				mainFile.tree().root().add(MessageId.NO_CODE, compileContext.pool());
				return false;
			}
		} else {
		}

		ref<pxi.X86_64SourceMap> smap = ref<pxi.X86_64SourceMap>(_segments[Segments.SOURCE_LOCATIONS].at(0));
		smap.codeLocationsCount = _sourceLocations.length();
		smap.sourceFileCount = _segments[Segments.SOURCE_FILE_NAMES].length() / int.bytes;

		for (i in _sourceLocations) {
			ref<runtime.SourceLocation> sl = &_sourceLocations[i];
			_segments[Segments.SOURCE_LOCATIONS].append(&sl.offset, int.bytes);
			_segments[Segments.SOURCE_FILE_INDICES].append(&sl.file.sourceFileIndex, int.bytes);
			_segments[Segments.SOURCE_FILE_OFFSETS].append(&sl.location.offset, int.bytes);
		}

		appendExceptionEntry(int.MAX_VALUE, null);
		
		int segmentsLength = 0;

		// First transform fixups from code-generated to segmented

		ref<Segment> codeSeg = _segments[Segments.CODE];
		pointer<byte> code = codeSeg.at(0);
		for (ref<Fixup> f = _fixups; f != null; f = f.next) {
			switch (f.kind) {
			case	RELATIVE32_CODE:				// Fixup value is a ref<ParameterScope>
				ref<ParameterScope> functionScope = ref<ParameterScope>(f.value);
				codeFixup(f.location, Segments.CODE, int(functionScope.value) - 1);
//				target = int(functionScope.value) - 1;
//				*ref<int>(&code[f.location]) = int(target) - (f.location + int.bytes);
				break;
				
			case	RELATIVE32_DATA:				// Fixup value is a ref<Symbol>
				ref<Symbol> sym = ref<Symbol>(f.value);
				Segments segment = segmentIndexOf(sym);
				if (sym.isEnumClass()) {
					ref<EnumType> etype = ref<EnumInstanceType>(sym.type().wrappedType()).enumType();
					if (etype.hasConstructors())
						segment = staticDataSegment(etype.alignment());
				}
				codeFixup(f.location, segment, int(sym.offset));
//				int ipAdjust = *ref<int>(&_code[f.location]);
//				*ref<int>(&code[f.location]) = int(sym.offset + ipAdjust - (f.location + int.bytes));
				break;
			
			case	RELATIVE32_FPDATA:				// Fixup value is a ref<Constant>
				ref<Constant> con = ref<Constant>(f.value);
//				Segments targetSegment;
				if (con.type.family() == runtime.TypeFamily.FLOAT_32) {
//					targetSegment = Segments.DATA_4;
					codeFixup(f.location, Segments.DATA_4, con.offset);
				} else {
//					targetSegment = Segments.DATA_8;
					codeFixup(f.location, Segments.DATA_8, con.offset);
				}
//				printf("f.location=%x targetOffset=%s:%x\n", f.location, string(targetSegment), con.offset);
//				*ref<int>(&code[f.location]) = int(targetOffset - (f.location + int.bytes));
				break;
			
			case	RELATIVE32_TYPE:				// Fixup value is a ref<Type>
//				type = ref<Type>(f.value);
				codeFixup(f.location, Segments.TYPE_DATA, -1);	// copyToImage returns the offset + 1
//				ipAdjust = *ref<int>(&code[f.location]) - 1;	// copyToImage returns the offset + 1
//				*ref<int>(&code[f.location]) = int(_pxiHeader.typeDataOffset + ipAdjust - (f.location + int.bytes));
//				printf("Reference @%x to ordinal %x ", f.location, type.copyToImage(this));
//				type.print();
//				printf("\n");
				break;
			
			case	RELATIVE32_STRING:				// Fixup value is an int offset into the string pool
				codeFixup(f.location, Segments.STRINGS, int(f.value));
//				*ref<int>(&code[f.location]) = _pxiHeader.stringsOffset + int(f.value) - (f.location + int.bytes);
				break;

			case	RELATIVE32_VTABLE:				// Fixup value is a ref<ClassScope>
				ref<ClassScope> scope = ref<ClassScope>(f.value);
				codeFixup(f.location, Segments.VTABLES, int(scope.vtable) - 1);
//				ipAdjust = *ref<int>(&code[f.location]);
//				*ref<int>(&code[f.location]) = int(_pxiHeader.vtablesOffset + ipAdjust + (int(scope.vtable) - 1) - (f.location + int.bytes));
				break;

			case	ABSOLUTE64_JUMP:				// Fixup value is a ref<CodeSegment>
				printf("    @%x ABSOLUTE64_JUMP %p\n", f.location, f.value);
				break;
				
			case	ABSOLUTE64_CODE:				// Fixup value is a ref<ParameterScope>
				// Generated from an inline function - not yet supported
				printf("    @%x ABSOLUTE64_CODE %p\n", f.location, f.value);
				break;
				
			case	ABSOLUTE64_DATA:				// Fixup value is a ref<Symbol>
				printf("    @%x ABSOLUTE64_DATA %p\n", f.location, f.value);
				break;

			case	ABSOLUTE64_STRING:				// Fixup value is an int offset into the string pool
//				printf("@ %x v %x ", f.location, f.value);
//				f.locationSymbol.print(0, false);
				ref<Segment> s = _segments[Segments.DATA_8];
				int location = int(f.locationSymbol.offset) + f.location;
				*ref<int>(s.at(location)) = int(f.value);
				s.fixup(location, byte(Segments.STRINGS), true);
				definePxiFixup(Segments.DATA_8, location);
				break;

			case	INT_CONSTANT:					// fixup value is the intereger constant
				location = int(f.locationSymbol.offset) + f.location;
				C.memcpy(segmentOf(f.locationSymbol).at(location), &f.value, f.locationSymbol.type().size());
				break;

			case	NATIVE32:						// fixup value is the native bindings entry
//				*ref<int>(&code[f.location]) = _pxiHeader.nativeBindingsOffset + int(f.value) -
//								(f.location + int.bytes);
				codeFixup(f.location, Segments.NATIVE_BINDINGS, int(f.value));
				break;

			default:
				printf("f = %p\n", f);
				text.memDump(f, Fixup.bytes);
				f.print();
				assert(false);
			}
		}
		
		// Second link the segments base addresses.
		
		for (int i = 0; i <= int(Segments.MAXIMUM); i++) {
			Segments segment = Segments(i);
			
			segmentsLength = _segments[segment].link(segmentsLength);
		}

		// Third resolve fixups within the segments.
		
		for (int i = 0; i <= int(Segments.MAXIMUM); i++) {
			Segments segment = Segments(i);
			
			_segments[segment].resolveFixups(this, &_segments[Segments(0)]);
		}

		// these calls will change the offset recorded in a static symbol from segment-relative
		// to image relative, 
		relocateStaticData(8);
		relocateStaticData(4);
		relocateStaticData(2);
		relocateStaticData(1);
		
		_pxiHeader.sourceMapOffset = _segments[Segments.SOURCE_LOCATIONS].offset();
		_pxiHeader.typeDataOffset = _segments[Segments.TYPE_DATA].offset();
		_pxiHeader.typeDataLength = _segments[Segments.TYPE_DATA].length();
		_pxiHeader.stringsOffset = _segments[Segments.STRINGS].offset();
		_pxiHeader.stringsLength = _segments[Segments.STRINGS].length();
		_pxiHeader.nativeBindingsOffset = _segments[Segments.NATIVE_BINDINGS].offset();
		_pxiHeader.nativeBindingsCount = _segments[Segments.NATIVE_BINDINGS].length() / NativeBinding.bytes;
		_pxiHeader.relocationOffset = _segments[Segments.RELOCATIONS].offset();
		_pxiHeader.relocationCount = _segments[Segments.RELOCATIONS].length() / int.bytes;
		_pxiHeader.exceptionsOffset = _segments[Segments.EXCEPTION_TABLE].offset();
		_pxiHeader.exceptionsCount = _segments[Segments.EXCEPTION_TABLE].length() / pxi.X86_64ExceptionEntry.bytes;
		_pxiHeader.builtInsText = _segments[Segments.BUILT_INS_TEXT].offset();
		_pxiHeader.vtablesOffset = _segments[Segments.VTABLES].offset();

		populateVTables(compileContext);

		for (int i = 0; i < _nativeBindingSymbols.length(); i++)
			_nativeBindingSymbols[i].offset += _pxiHeader.nativeBindingsOffset;
		
		_dataMap[0].append(_nativeBindingSymbols);

		_staticMemoryLength = _segments[Segments.MAXIMUM].offset();

		_staticMemory = pointer<byte>(runtime.allocateRegion(_staticMemoryLength));
		for (int i = 0; i < int(Segments.MAXIMUM); i++) {
			ref<Segment> s = _segments[Segments(i)];
			C.memcpy(_staticMemory + s.offset(), s.at(0), s.length());
		}
		return true;
	}

	private void codeFixup(int location, Segments segment, int contents) {
		ref<Segment> s = _segments[Segments.CODE];
		*ref<int>(s.at(location)) += contents;
		s.fixup(location, byte(segment), false);
	}

	protected void definePxiFixup(Segments segment, int location) {
		ref<Segment> s = _segments[Segments.RELOCATIONS];
		int offset = s.reserve(location.bytes);
		*ref<int>(s.at(offset)) = location;
		s.fixup(offset, byte(segment), true);
	}
	
	private ref<Segment> segmentOf(ref<Symbol> sym) {
		return _segments[staticDataSegment(sym.type().alignment())];
	}

	private Segments segmentIndexOf(ref<Symbol> sym) {
		return staticDataSegment(sym.type().alignment());
	}

	private Segments staticDataSegment(int alignment) {
		switch (alignment) {
		case	8:
			return Segments.DATA_8;

		case	4:
			return Segments.DATA_4;

		case	2:
			return Segments.DATA_2;

		case	1:
			return Segments.DATA_1;
		}
		throw Exception("Invalid alignment: " + alignment);
	}

	private void relocateStaticData(int alignment) {
		ref<Segment> s;
		switch (alignment) {
		case 8:
			s = _segments[Segments.DATA_8];
			break;
			
		case 4:
			s = _segments[Segments.DATA_4];
			break;
			
		case 2:
			s = _segments[Segments.DATA_2];
			break;
			
		case 1:
			s = _segments[Segments.DATA_1];
			break;
			
		}
		_dataMap[0].append(_dataMap[alignment]);
		for (i in _dataMap[alignment]) {
			ref<Symbol> sym = _dataMap[alignment][i];
			if (!sym.isEnumClass() &&
				sym.type().family() != runtime.TypeFamily.TYPEDEF &&
				sym.class == PlainSymbol) {
				ref<PlainSymbol> ps = ref<PlainSymbol>(sym);
				if (ps.accessFlags() & Access.COMPILE_TARGET) {
					long x = long(sectionType());
					address p = s.at(int(sym.offset));
					C.memcpy(p, &x, sym.type().size());
				} else if (ps.initializer() != null) {
					switch (ps.initializer().op()) {
					case	INTEGER:
						ref<Constant> c = ref<Constant>(ps.initializer());
						long x = c.intValue();
						address p = s.at(int(sym.offset));
						C.memcpy(p, &x, sym.type().size());
						break;
					}
				}
			}
			_dataMap[alignment][i].offset += s.offset();
		}
	}
	
	public int copyClassToImage(ref<Type> type, int baseOrdinal, runtime.TypeFamily family) {
		ref<Segment> s = _segments[Segments.TYPE_DATA];
		int size = runtime.Class.bytes;
		int offset = s.reserve(size, 8);
		*ref<long>(s.at(offset)) = runtime.Class.MAGIC;
		int baseOffset = offset + runtime.Class.BASE_OFFSET;
		if (baseOrdinal != 0) {
			baseOrdinal--;
			*ref<int>(s.at(baseOffset)) = baseOrdinal;
			s.fixup(baseOffset, byte(Segments.TYPE_DATA), true);
			definePxiFixup(Segments.TYPE_DATA, baseOffset);
		}
		int familyOffset = offset + runtime.Class.FAMILY_OFFSET;
		*ref<runtime.TypeFamily>(s.at(familyOffset)) = family;
//		printf("{ magic: %x base %x: %x family %x: %d }\n", offset, baseOffset, baseOrdinal, familyOffset, int(family));
//		copyFields(template, offset);
		_ordinalMap.set(offset, type);
		return offset + 1;
	}

/**
	public int copyInterfaceToImage(ref<Type> type, ref<runtime.Interface> template) {
		ref<Segment> s = _segments[Segments.TYPE_DATA];
		int size = template.bytes;
		int offset = s.reserve(size, 8);
		copyFields(template, offset);
		int offset = copyClassToImage(type, template);
		_ordinalMap.set(offset, type);
		return offset + 1;
	}
 */
/*
	private void copyFields(ref<runtime.Class> template, int offset) {
		ref<Segment> s = _segments[Segments.TYPE_DATA];
		pointer<long> slots = pointer<long>(s.at(offset
));
		int ordinal = compiler.getOrdinal(template.base());
		*slots = ordinal;
//		ordinal = addStringLiteral(template.
		slots += template.bytes / address.bytes;		// skip to the intefaces array
		for (int i = 0; i < template.interfaceCount(); i++) {
			ordinal = compiler.getOrdinal(template.getInterface(i));
			slots[i] = ordinal;
		}
	}
*/
	public void markRegisterParameters(ref<ParameterScope> scope, ref<CompileContext> compileContext) {
		// Stack will look like:
		//
		// 		  ... stack arguments
		// TODO: Need to insert 32 byte register save area (for full Win64 ABI compatibility - not on Linux)
		// 		  Return Address
		// RBP -> RBP (saved frame pointer)
		// saved register parameters (for now, see above) as:
		//    On Windows:
		// 		  RCX / XMM0 (as needed)
		// 		  RDX / XMM1 (as needed)
		// 		  R8 / XMM2 (as needed)
		// 		  R9 / XMM3 (as needed)
		//    On Linux (non-floating and floating arguments can be intermixed, register are in order within each subset):
		//		  RDI, RSI, RDX, RCX, R8, R9
		//         XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7
		// 		  local variables
		//		  possible 8-byte padding to align stack on 16 byte boundary
		//		  32-byte register save area (per Win64 ABI)
		//		  TODO: Remove 32-byte register save area on Linux
		//
		int regStackOffset = 0;
		if (scope.hasThis()) {
			regStackOffset -= address.bytes;
		}

		if (scope.hasOutParameter(compileContext)) {
			regStackOffset -= address.bytes;
			_f.outParameterOffset = regStackOffset;
		}
		scope.variableStorage = 0;
		ref<FunctionType> fType = scope.type;
		if (fType != null) {
			fType.assignRegisterArguments(compileContext);
			pointer<ref<Type>> params = fType.parameters();
			for (int i = 0; i < scope.parameters().length(); i++) {
				ref<Symbol> sym = (*scope.parameters())[i];
				
				if (sym.deferAnalysis()) {
					sym.offset = 0;
					continue;
				}
				if (fType.parameterRegister(i) == 0) {
					// It's a stack argument
					sym.offset = FIRST_STACK_PARAM_OFFSET + scope.variableStorage;
					scope.variableStorage += sym.type().stackSize();
				} else {
					regStackOffset -= address.bytes;
					sym.offset = regStackOffset;
				}
			}
		}
		_f.registerSaveSize = -regStackOffset;
	}
	
	protected void buildVtable(ref<ClassScope> scope, ref<CompileContext> compileContext) {
		if (scope.vtable == null) {
			scope.vtable = address(_segments[Segments.VTABLES].reserve((scope.methods().length() + 
																FIRST_USER_METHOD) * address.bytes) + 1);
			_vtables.append(scope);
		}
	}
	/**
	 * 
	 */
	private void prepareVTables(ref<CompileContext> compileContext) {
		// TODO: make this work better.
		buildVtable(ref<ClassScope>(classType().scope()), compileContext);
		buildVtable(ref<ClassScope>(builtInType().scope()), compileContext);
		for (int i = 0; i < _vtables.length(); i++) {
			ref<ClassScope> scope = _vtables[i];
			// This relies on the copyToImage function being idempotent, in that the return value
			// that we ignore for now will be the same in populateVTables, but will have all side-
			// effects like genrating the runtime.Class objects into the image done now.
			scope.classType.copyToImage(this);
			// This relies on the side-effects of arranging that the function in question eventually gets generated.
			if (scope.destructor() != null)
				getFunctionAddress(scope.destructor(), compileContext);
			for (int j = 0; j < scope.methods().length(); j++) {
				ref<OverloadInstance> oi = (*scope.methods())[j];
				ref<ParameterScope> functionScope = oi.parameterScope();

				// This relies on the side-effects of arranging that the function in question eventually gets generated.
				getFunctionAddress(functionScope, compileContext);
			}
			if (scope.class == InterfaceImplementationScope) {
				getFunctionAddress(scope.destructor(), compileContext);
				ref<ref<ThunkScope>[]> thunks = ref<InterfaceImplementationScope>(scope).thunks();
				for (int i = 0; i < thunks.length(); i++)
					getFunctionAddress((*thunks)[i], compileContext);
			}
		}
	}

	private void populateVTables(ref<CompileContext> compileContext) {
		for (int i = 0; i < _vtables.length(); i++) {
			ref<ClassScope> scope = _vtables[i];
			int tableStart = int(scope.vtable) - 1;
			int entries = scope.methods().length() + FIRST_USER_METHOD;
			
			_pxiHeader.vtableData += entries;
			int tableEnd = tableStart + entries * address.bytes;
			pointer<address> table = pointer<address>(_segments[Segments.VTABLES].at(tableStart));
			*table = address(_pxiHeader.typeDataOffset + scope.classType.copyToImage(this) - 1);
			if (scope.class == InterfaceImplementationScope) {
				int target = int(scope.destructor().value) - 1;
				table[1] = address(target);
				ref<ref<ThunkScope>[]> thunks = ref<InterfaceImplementationScope>(scope).thunks();
				for (int j = 0; j < thunks.length(); j++) {
					int target = int((*thunks)[j].value) - 1;
					table[j + FIRST_USER_METHOD] = address(target);
				}
			} else {
				if (scope.destructor() != null) {
					int target = int(scope.destructor().value) - 1;
					table[1] = address(target);
				}
				for (int j = 0; j < scope.methods().length(); j++) {
					ref<OverloadInstance> oi = (*scope.methods())[j];
					ref<ParameterScope> functionScope = oi.parameterScope();

					int target = int(functionScope.value) - 1;
					table[j + FIRST_USER_METHOD] = address(target);
				}
			}
		}
	}

	public void assignStorageToObject(ref<Symbol> sym, ref<Scope> scope, int offset, ref<CompileContext> compileContext) {
		if (sym.class == PlainSymbol) {
			ref<PlainSymbol> symbol = ref<PlainSymbol>(sym);
			ref<Type> type = symbol.assignType(compileContext);
			if (type == null)
				return;
			// As a special case, enums may produce static storage, if they have actual constructors and such.
			if (symbol.isEnumClass()) {
				assignStaticSymbolStorage(symbol, compileContext);
				return;
			}
			if (!type.requiresAutoStorage())
				return;
			int size;
			int alignment;
			type.assignSize(this, compileContext);
			switch (symbol.storageClass()) {
			case	STATIC:
				if (symbol.value == null) {
					int size = type.size();
					if (size <= 0) {			// This is a static declaration inside a class 
						compileContext.rememberStaticSymbol(symbol);
						break;
					}
					assignStaticSymbolStorage(symbol, compileContext);
				}
				break;

			case	PARAMETER:
				// These were allocated above.
				break;

			case	AUTO:
				// Round auto sizes up to next slot size - do not try to optimize stack frame yet.
				size = type.stackSize();
				scope.variableStorage += size;
				symbol.offset = -scope.variableStorage;
				break;

			case	TEMPLATE_INSTANCE:
				symbol.offset = 0;
				scope.variableStorage = 0;
				break;

			case	MEMBER:
				// Align member fields, but don't reorder them - do not try to optimize stack frame yet.
				size = type.size();
				alignment = type.alignment();
				if (alignment == -1) {
					symbol.add(MessageId.UNFINISHED_ASSIGN_STORAGE, compileContext.pool(), string(scope.storageClass()));
				}
				scope.variableStorage = (scope.variableStorage + alignment - 1) & ~(alignment - 1);
				symbol.offset = scope.variableStorage;
				scope.variableStorage += size;
				break;

			case	ENUMERATION:
				ref<EnumInstanceType> eit = ref<EnumInstanceType>(type);
				ref<Symbol> typeDefinition = eit.typeSymbol();
				if (typeDefinition.value == null)
					assignStorageToObject(typeDefinition, typeDefinition.enclosing(), 0, compileContext);
				symbol.value = typeDefinition.value;
				break;

			case	FLAGS:
				ref<FlagsInstanceType> fit = ref<FlagsInstanceType>(type);
				typeDefinition = fit.symbol();
				if (typeDefinition.value == null)
					assignStorageToObject(typeDefinition, typeDefinition.enclosing(), 0, compileContext);
				symbol.value = typeDefinition.value;
				break;

			default:
				symbol.print(0, false);
				printf("StorageClass: %s\n", string(symbol.storageClass()));
				assert(false);
			}
		}
	}
	
	protected void assignStaticSymbolStorage(ref<PlainSymbol> symbol, ref<CompileContext> compileContext) {
		if (symbol.value == null) {
			symbol.value = symbol;
			ref<Type> type;
			int size;
			if (symbol.isEnumClass()) {
				ref<EnumType> etype = ref<EnumInstanceType>(symbol.type().wrappedType()).enumType();
				if (!etype.hasConstructors())
					return;
				etype.assignSize(this, compileContext);
				type = etype;
				size = type.size() * etype.instanceCount;
			} else {
				type = symbol.type();
				size = type.size();
			}
			int alignment = type.alignment();
			assignStaticRegion(symbol, alignment, size);
			if (symbol.accessFlags() & Access.CONSTANT) {
				ref<PlainSymbol> sym = ref<PlainSymbol>(symbol);		// constants are constrained to be Plain
				ref<Node> n = sym.foldInitializer(compileContext);
				long value = n.foldInt(this, compileContext);
				staticFixup(FixupKind.INT_CONSTANT, symbol, 0, address(value));
			}
		}
	}
	
	public void assignStaticRegion(ref<Symbol> symbol, int alignment, int size) {
		switch (alignment) {
		case 8:
			symbol.segment = _segments[Segments.DATA_8];
			break;
			
		case 4:
			symbol.segment = _segments[Segments.DATA_4];
			break;
			
		case 2:
			symbol.segment = _segments[Segments.DATA_2];
			break;
			
		case 1:
			symbol.segment = _segments[Segments.DATA_1];
			break;
			
		default:
			symbol.print(0, false);
			assert(false);
		}
		_dataMap[alignment].append(symbol);
		symbol.offset = ref<Segment>(symbol.segment).reserve(size);
	}

	public boolean disassemble(ref<runtime.Arena> arena) {
		Disassembler d(arena, 0, _staticMemoryLength, _staticMemory, &_pxiHeader);
		d.setDataMap(&_dataMap[0][0], _dataMap[0].length());
		d.setFunctionMap(&_functionMap);
		d.setOrdinalMap(&_ordinalMap);
		d.setSourceLocations(&_sourceLocations[0], _sourceLocations.length());
		d.setVtablesClasses(&_vtables);
		return d.disassemble();
	}

	public abstract ref<ParameterScope>, boolean getFunctionAddress(ref<ParameterScope> functionScope, ref<CompileContext> compileContext);
	
	int generateFunction(ref<Scope> scope, ref<CompileContext> compileContext) {
		// Sketch of the code generator:
		// 1 optimization, tree clean up and all tree-level rewrites.
		// 2 block decomposition (partial flattening of control-flow)
		// 3 register allocation
		// 4 instruction selection
		// 5 jump clean-up
		// 6 instruction ordering
		// 7 coding
		FunctionState f;
		f.avail = longMask()|floatMask;
		RegisterState r(&_t, f.avail);
		f.r = &r;
		f.firstCode = _functionCode.length();
		f.current = scope;
		f.oldestUnspilled = f.tempBase = _t.stackDepth();
		f.knownDeferredTrys = _deferredTry.length();
		
		ref<FunctionState> savedState = _f;

		_f = &f;
		if (scope.class <= ParameterScope) {
			ref<ParameterScope> parameterScope = ref<ParameterScope>(scope);
			markRegisterParameters(parameterScope, compileContext);
		}
		generateFunctionCore(scope, compileContext);
		int offset = packFunction();
		_f = savedState;
		_functionMap.append(scope);
		return offset;
	}

	protected void showCS() {
		_f.showCS(this);
		printf("Code offset = %x\n", _functionCode.length());
	}

	private int packFunction() {
//		showCS();
		closeCodeSegment(CC.NOP, null);
		
		int length = _f.optimizeJumps(this);
		int offset = _segments[Segments.CODE].reserve(length);
		int firstExceptionEntry = _segments[Segments.EXCEPTION_TABLE].length();
		_f.packCode(offset, this);
		pointer<pxi.X86_64ExceptionEntry> ee = pointer<pxi.X86_64ExceptionEntry>(_segments[Segments.EXCEPTION_TABLE].at(firstExceptionEntry));
		for (int i = firstExceptionEntry; i < _segments[Segments.EXCEPTION_TABLE].length(); i += pxi.X86_64ExceptionEntry.bytes, ee++) {
			int hi = i / pxi.X86_64ExceptionEntry.bytes;
			if (_exceptionHandlers[hi] != null)
				ee.handler = offset + _exceptionHandlers[hi].segmentOffset;
		}
		_functionCode.resize(_f.firstCode);
		return offset;
	}

	void emitSourceFile(ref<Unit> file) {
		if (file.sourceFileIndex == -1) {
			int segOffset = _segments[Segments.SOURCE_FILE_NAMES].length();
//			printf("file %s -> %d.\n", file.filename(), segOffset);
			file.sourceFileIndex = segOffset / int.bytes + 1;
			string filename = file.filename();
			int filenameOffset = _segments[Segments.BUILT_INS_TEXT].reserve(filename.length() + 1);
			C.memcpy(_segments[Segments.BUILT_INS_TEXT].at(filenameOffset), filename.c_str(), filename.length());
			_segments[Segments.SOURCE_FILE_NAMES].append(&filenameOffset, int.bytes);
			_segments[Segments.SOURCE_FILE_NAMES].fixup(segOffset, byte(Segments.BUILT_INS_TEXT), true);
			ref<runtime.SourceOffset[]> lines = file.lines();
			int lineIndex = _segments[Segments.LINE_FILE_OFFSETS].length();
			_segments[Segments.SOURCE_FILE_LINE_INDICES].append(&lineIndex, int.bytes);
			int lineCount = lines.length();
			_segments[Segments.SOURCE_FILE_LINE_COUNTS].append(&lineCount, int.bytes);
			int baseLineNumber = file.baseLineNumber();
			_segments[Segments.SOURCE_FILE_BASE_LINES].append(&baseLineNumber, int.bytes);
			_segments[Segments.LINE_FILE_OFFSETS].append(&(*lines)[0], lines.length() * int.bytes);
		}
	}

	public abstract void generateFunctionCore(ref<Scope> scope, ref<CompileContext> compileContext);

	void reserveAutoStorage(ref<Scope> scope, ref<CompileContext> compileContext) {
		_f.autoSize = scope.autoStorage(this, _f.registerSaveSize, compileContext);
	}

	/**
	 * Code generation proceeds by maintaining a stack of in-progress functions. The _f member of
	 * the X86Encoder points to the top of the stack. Each FUnctionState object is allocated on the
	 * stack. There is no need for an explicit chain of pointers to deeper FunctionState objects.
	 * The code that pushes a new FunctionState instance must do it's work and then pop the _f
	 * member back to it's prior value before returning.
	 *
	 * All other code that needs to update the state of the current function being generated can
	 * use an expression of the form _f.XXX.
	 */
	class FunctionState {
//		public long allocatedRegisters;
		public int autoSize;
		public int firstCode;
		public ref<CodeSegment> currentHandler;
		public long avail;
		public long freeRegisters;
		public long usedRegisters;
		public int tempBase;			// Index of the first temp in the function.
		public int oldestUnspilled;		// Index of the oldest unspilled temporary. 
		public ref<RegisterState> r;
		public byte doesFit;
		public byte anyPushed;
		public ref<Scope> current;
		public int outParameterOffset;
		public int registerSaveSize;
		public int knownDeferredTrys;
		public int stackAdjustment;

		private ref<CodeSegment> _first;
		private ref<CodeSegment> _last;
		private ref<CodeSegment> _emitting;

		void ensureCodeSegment(ref<X86_64Encoder> encoder) {
			if (_emitting == null) {
				ref<CodeSegment> cs = encoder._storage new CodeSegment();
				cs.start(encoder);
			}
		}
	
		void start(ref<CodeSegment> cs, ref<X86_64Encoder> encoder) {
			closeCodeSegment(CC.NOP, null, encoder);
			cs.codeOffset = encoder._functionCode.length();
			cs.prev = _last;
			if (_last == null)
				_first = cs;
			else
				_last.next = cs;
			_last = cs;
			_emitting = cs;
	//			printf("Starting code segment\n");
	//			print(target);
		}
		
		void closeCodeSegment(CC continuation, ref<CodeSegment> jumpTarget, ref<X86_64Encoder> encoder) {
			if (_emitting == null) {
				if (continuation == CC.NOP)
					return;
				ref<CodeSegment> cs = encoder._storage new CodeSegment;
				cs.start(encoder);
			}
			_emitting.length = encoder._functionCode.length() - _emitting.codeOffset; 
			_emitting.continuation = continuation;
			_emitting.jumpTarget = jumpTarget;
			_emitting = null;
		}
		
		void insertPreamble(ref<X86_64Encoder> encoder) {
			ref<CodeSegment> cs = encoder._storage new CodeSegment;
			cs.next = _first;
			cs.codeOffset = encoder._functionCode.length();
			if (_first != null)
				_first.prev = cs;
			else
				_last = cs;
			_first = cs;
			_emitting = cs;
		}

		void emitSourceLocation(ref<Unit> file, runtime.SourceOffset location, ref<X86_64Encoder> encoder) {
			ensureCodeSegment(encoder);
			encoder.emitSourceFile(file);

			runtime.SourceLocation loc = {
				file: file,
				location: location,
				offset: encoder._functionCode.length() - _emitting.codeOffset
			};

			_emitting.sourceLocations.append(loc, &encoder._storage);
		}
	
		void showCS(ref<X86_64Encoder> encoder) {
			if (_emitting == null) {
				printf("----\nNo segment active last = %p\n", _last);
				if (_last != null)
					_last.print(encoder);
			} else {
				printf("----\nTrailing block:\n");
				_emitting.print(encoder);
			}
		}

		void fixup(FixupKind kind, address value, ref<X86_64Encoder> encoder) {
			 fixup(kind, null, encoder._functionCode.length() - _emitting.codeOffset, value, encoder);
		}
	
		void fixup(FixupKind kind, ref<Symbol> locationSymbol, int location, address value, ref<X86_64Encoder> encoder) {
			 ref<Fixup> f = encoder._storage new Fixup();
			 f.kind = kind;
			 f.locationSymbol = locationSymbol; 
			 f.location = location;
			 f.value = value;
			 f.next = _emitting.fixups;
			 _emitting.fixups = f;
		}

		int optimizeJumps(ref<X86_64Encoder> encoder) {
			int i = 1;
			for (ref<CodeSegment> cs = _first; cs != null; cs = cs.next) {
				cs.ordinal = i++;
				
				// Do some validation to ensure that the up-stream code did its job correctly
				if (cs.continuation == null) {
					for (ref<CodeSegment> cs = _first; cs != null; cs = cs.next)
						cs.print(encoder);
					assert(false);
				}
			}
	
			int size;
			boolean changed;
			do {
				changed = false;
				size = 0;
				for (ref<CodeSegment> cs = _first; cs != null; cs = cs.next) {
					cs.segmentOffset = size;
					if (cs.continuation != CC.NOP) {
						if (cs.jumpDistance == JumpDistance.UNKNOWN) {
							if (cs.jumpTarget.ordinal < cs.ordinal) {
			
							} else {
								
							}
						}
						size += cs.jumpDistance == JumpDistance.SHORT ? minCCSize[cs.continuation] :
								maxCCSize[cs.continuation];
					}
					size += cs.length;
				}		
			} while (changed);
	//		printf("After:\n");
	//		for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next)
	//			cs.print(this);
	
			return size;
		}
		
		void packCode(int offset, ref<X86_64Encoder> encoder) {
			int nextCopy = offset;
			ref<Segment> seg = encoder._segments[Segments.CODE];
			pointer<byte> code = seg.at(0);
			for (ref<CodeSegment> cs = _first; cs != null; cs = cs.next) {
				for (i in cs.sourceLocations)
					cs.sourceLocations[i].offset += nextCopy;

				encoder._sourceLocations.append(cs.sourceLocations);
				encoder.emitExceptionEntry(nextCopy, cs.exceptionHandler);
				C.memcpy(&code[nextCopy], &encoder._functionCode[cs.codeOffset], cs.length);
				while (cs.fixups != null) {
					ref<Fixup> fx = cs.fixups;
					cs.fixups = fx.next;
					fx.next = encoder._fixups;
					encoder._fixups = fx;
					if (fx.locationSymbol == null)
						fx.location += nextCopy;
				}
				nextCopy += cs.length;
				switch (cs.continuation) {
				case	JO:				// Jump on overflow
				case	JNO:			// Jump not overflow
				case	JB:				// Jump below (unsigned <)
				case	JNB:			// Jump not below (unsigned >=)
				case	JE:				// Jump equal / zero
				case	JNE:			// Jump not equal / zero
				case	JNA:			// Jump not above (unsigned <=)
				case	JA:				// Jump above (unsigned >)
				case	JS:				// Jump on sign
				case	JNS:			// Jump on no sign
				case	JP:				// Jump parity even
				case	JNP:			// Jump parity odd
				case	JL:				// Jump less (sign <)
				case	JGE:			// Jump greater or equal (signed >=)
				case	JLE:			// Jump less or equal (signed <=)
				case	JG:				// Jump greater (signed >)
					if (cs.jumpDistance == JumpDistance.SHORT) {
						code[nextCopy++] = byte(0x70 + int(cs.continuation) - 1);
						code[nextCopy] = byte(offset + cs.jumpTarget.segmentOffset - (nextCopy + 1));
						nextCopy++;
					} else {
						code[nextCopy++] = 0x0f;
						code[nextCopy++] = byte(0x80 + int(cs.continuation) - 1);
						*ref<int>(&code[nextCopy]) = offset + cs.jumpTarget.segmentOffset - (nextCopy + int.bytes);
						nextCopy += int.bytes;
					}
					break;
					
				case	JMP:
					if (cs.jumpDistance == JumpDistance.SHORT) {
						code[nextCopy++] = 0xeb;
						code[nextCopy] = byte(offset + cs.jumpTarget.segmentOffset - (nextCopy + 1));
						nextCopy++;
					} else {
						code[nextCopy++] = 0xe9;
						*ref<int>(&code[nextCopy]) = offset + cs.jumpTarget.segmentOffset - (nextCopy + int.bytes);
						nextCopy += int.bytes;
					}
				}
			}
		}
	}
	/**
	 * 
	 */
	class CodeSegment {
		public ref<CodeSegment> prev;
		public ref<CodeSegment> next;
		public CC continuation;
		public JumpDistance jumpDistance;
		public ref<CodeSegment> jumpTarget;
		public ref<CodeSegment> exceptionHandler;
		public ref<Fixup> fixups;
		public int codeOffset;				// offset in _functionCode array where code is stored.
		public int length;
		public int ordinal;
		public int segmentOffset;
		public runtime.SourceLocation[] sourceLocations;
		
		CodeSegment() {
			continuation = CC.NOP;
			jumpDistance = JumpDistance.UNKNOWN;
		}

		void start(ref<X86_64Encoder> encoder) {
			encoder._f.start(this, encoder);
			exceptionHandler = encoder._f.currentHandler;
		}
		
		void print(ref<X86_64Encoder> encoder) {
			printf("%p: %p %p %s", this, prev, next, ccLabel(continuation));
			if (continuation != CC.NOP) {
				printf("(%p", jumpTarget);
				if (jumpDistance != JumpDistance.UNKNOWN)
					printf(" %s", string(jumpDistance));
				if (jumpTarget.segmentOffset != segmentOffset)
					printf("%c%#x", jumpTarget.segmentOffset < segmentOffset ? '-' : '+', abs(jumpTarget.segmentOffset - segmentOffset));
				printf(")");
			}
			printf(" %#x[%#x] ord %d seg offs %#x\n", codeOffset, length, ordinal, segmentOffset);
			if (length > 0)
				text.memDump(&encoder._functionCode[codeOffset], length, segmentOffset);
			for (ref<Fixup> f = fixups; f != null; f = f.next)
				f.print();
		}
	}

	ref<CodeSegment> pushExceptionHandler(ref<CodeSegment> handler) {
		closeCodeSegment(CC.NOP, null);
		ref<CodeSegment> outerHandler = _f.currentHandler;
		_f.currentHandler = handler;
		return outerHandler;
	}
	
	void emitExceptionEntry(int location, ref<CodeSegment> handler) {
		
		// If we have no table yet, behave as if we are in 'null' state.
		if (handler == null && _exceptionHandlers.length() == 0)
			return;

		int i = _exceptionHandlers.length() - 1;
		
		// If we are already under this handler, stay there.
		if (i < 0 || _exceptionHandlers[i] != handler)
			appendExceptionEntry(location, handler);
	}
	
	private void appendExceptionEntry(int location, ref<CodeSegment> handler) {
		pxi.X86_64ExceptionEntry ee;
		
		ee.location = location;
		ee.handler = 0;
		_segments[Segments.EXCEPTION_TABLE].append(&ee, ee.bytes);
		_exceptionHandlers.append(handler);
	}

	void inst(X86 instruction, runtime.TypeFamily family, ref<Node> left, ref<Node> right, ref<CompileContext> compileContext) {
		if (left.deferGeneration() || right.deferGeneration())
			return;
		if (right.op() == Operator.SEQUENCE) {
			inst(instruction, family, left, ref<Binary>(right).right(), compileContext);
			return;
		}
		if (left.op() == Operator.SEQUENCE) {
			inst(instruction, family, ref<Binary>(left).right(), right, compileContext);
			return;
		}
		if ((left.nodeFlags & ADDRESS_MODE) != 0) {
			if (right.register != 0)
				inst(instruction, left, R(int(right.register)), compileContext);
			else if (right.isConstant()) {
				ref<Constant> c = ref<Constant>(right);
				if (c.representedBy(compileContext.builtInType(runtime.TypeFamily.SIGNED_32)))
					inst(instruction, left, int(c.intValue()), compileContext);
				else {
					printf("%s - -\n", string(instruction));
					left.print(4);
					right.print(4);
					assert(false);
				}
			} else {
				printf("%s - -\n", string(instruction));
				left.print(4);
				right.print(4);
				assert(false);
			}
		} else {
			R dest = R(left.register);
			if (right.register != 0) {
				R src = R(right.register);
				if (family == runtime.TypeFamily.FLAGS) {
					assert(left.type.family() == runtime.TypeFamily.FLAGS);
					switch (left.type.size()) {
					case 1:
					case 2:
						family = runtime.TypeFamily.SIGNED_16;
						break;
						
					case 4:
						family = runtime.TypeFamily.SIGNED_32;
						break;
						
					case 8:
						family = runtime.TypeFamily.SIGNED_64;
						break;
					}
				}
				inst(instruction, family, dest, src);
			} else if (right.op() == Operator.INTEGER) {
				switch (right.type.family()) {
				case	FLAGS:
				case	UNSIGNED_8:
				case	UNSIGNED_32:
				case	SIGNED_32:
				case	SIGNED_64:
					ref<Constant> c = ref<Constant>(right);
					inst(instruction, family, dest, int(c.intValue()));
					break;
					
				default:
					right.type.print();
					printf("\n");
					assert(false);
				}
			} else if ((right.nodeFlags & ADDRESS_MODE) != 0)
				inst(instruction, dest, right, compileContext);
			else {
				R src = R(int(right.register));
				inst(instruction, family, dest, src);
			}
		}
	}
	
	boolean pushRegister(runtime.TypeFamily family, R reg) {
		switch (family) {
		case	UNSIGNED_8:
		case	UNSIGNED_16:
		case	UNSIGNED_32:
		case	SIGNED_16:
		case	SIGNED_32:
		case	SIGNED_64:
		case	STRING:
		case	STRING16:
		case	ENUM:
		case	FLAGS:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	CLASS:
		case	BOOLEAN:
		case	VOID:
		case	FUNCTION:
		case	INTERFACE:
		case	SUBSTRING:				// These should only show up in compares
		case	SUBSTRING16:			// These should only show up in compares
			inst(X86.PUSH, runtime.TypeFamily.SIGNED_64, reg);
			break;
			
		case	FLOAT_32:
			inst(X86.SUB, runtime.TypeFamily.SIGNED_64, R.RSP, 8);
			inst(X86.MOVSS, runtime.TypeFamily.SIGNED_32, R.RSP, 0, reg);
			break;
			
		case	FLOAT_64:
			inst(X86.SUB, runtime.TypeFamily.SIGNED_64, R.RSP, 8);
			inst(X86.MOVSD, runtime.TypeFamily.SIGNED_64, R.RSP, 0, reg);
			break;
		
		default:
			return false;
		}
		return true;
	}
	
	boolean popRegister(runtime.TypeFamily family, R reg) {
		switch (family) {
		case	UNSIGNED_8:
		case	UNSIGNED_16:
		case	UNSIGNED_32:
		case	SIGNED_16:
		case	SIGNED_32:
		case	SIGNED_64:
		case	STRING:
		case	STRING16:
		case	ENUM:
		case	FLAGS:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	CLASS:
		case	BOOLEAN:
		case	VOID:
		case	FUNCTION:
		case	INTERFACE:
		case	SUBSTRING:				// These should only show up in compares
		case	SUBSTRING16:			// These should only show up in compares
			inst(X86.POP, runtime.TypeFamily.SIGNED_64, reg);
			break;
			
		case	FLOAT_32:
			inst(X86.MOVSS, runtime.TypeFamily.SIGNED_32, reg, R.RSP, 0);
			inst(X86.ADD, runtime.TypeFamily.SIGNED_64, R.RSP, 8);
			break;
			
		case	FLOAT_64:
			inst(X86.MOVSD, runtime.TypeFamily.SIGNED_64, reg, R.RSP, 0);
			inst(X86.ADD, runtime.TypeFamily.SIGNED_64, R.RSP, 8);
			break;
			
		default:
			return false;
		}
		return true;
	}
	/*
	 */
	void inst(X86 instruction, runtime.TypeFamily family, R dest, long operand) {
		if (dest == R.NO_REG) {
			printf("%s NO_REG %d\n", string(instruction), operand);
			assert(false);
		}
		switch (instruction) {
		case	CALL:				// vtable call
			emit(REX_W);
			emit(0xff);
			if (operand >= -128 && operand <= 127) {
				modRM(1, 2, 0);
				emit(byte(int(operand)));
			} else {
				modRM(2, 2, 0);
				emitInt(int(operand));
			}
			return;
			
		case	CMP:
		case	ADD:
		case	AND:
		case	OR:
		case	XOR:
		case	SUB:
		case	SBB:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, R.NO_REG, dest);
				emit(0x80);
				modRM(3, group1opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(family, null, R.NO_REG, dest);
				if (operand >= -128 && operand <= 127) {
					emit(0x83);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emit(byte(int(operand)));
				} else {
					emit(0x81);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emitShort(int(operand));
				}
				return;

			case	SIGNED_32:
			case	UNSIGNED_32:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	SIGNED_64:
			case	UNSIGNED_64:
			case	CLASS:
			case	FUNCTION:
			case	INTERFACE:
				emitRex(family, null, R.NO_REG, dest);
				if (operand >= -128 && operand <= 127) {
					emit(0x83);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emit(byte(int(operand)));
				} else {
					emit(0x81);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emitInt(int(operand));
				}
				return;
			}
			break;
			
		case	SAL:
		case	SAR:
		case	SHR:
			switch (family) {
			case	UNSIGNED_8:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xc0);
				modRM(3, group2opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
				
			case	UNSIGNED_16:
				emit(0x66);

			case	UNSIGNED_32:
			case	UNSIGNED_64:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xc1);
				modRM(3, group2opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
			}
			break;
				
		case	MOV:
			if (operand == 0) {
				inst(X86.XOR, family, dest, dest);
				return;
			}
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				if (fits(dest, byteMask)) {
					emitRex(family, null, R.NO_REG, dest);
					emit(byte(0xb0 + rmValues[dest]));
					emit(byte(operand));
					return;
				}
				family = runtime.TypeFamily.UNSIGNED_16;

			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitShort(int(operand));
				return;
				
			case	UNSIGNED_32:
			case	SIGNED_32:
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitInt(int(operand));
				return;
				
			case	CLASS:
			case	SIGNED_64:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	FUNCTION:
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitLong(operand);
				return;
			}
		}
		printf("%s %s %s %d\n", string(instruction), string(family), string(dest), operand);
		assert(false);
	}

	void inst(X86 instruction, ref<Type> type, R left, ref<Node> right, int offset) {
		switch (instruction) {
		case	MOV:
		case	ADD:
		case	SUB:
		case	OR:
		case	XOR:
		case	AND:
			switch (type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x02));
				ref<Type> t = right.type;
				right.type = type;
				modRM(right, rmValues[left], 0, offset);
				right.type = t;
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				t = right.type;
				right.type = type;
				modRM(right, rmValues[left], 0, offset);
				right.type = t;
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
			case	ADDRESS:
			case	FUNCTION:
			case	REF:
			case	POINTER:
			case	STRING:
			case	VAR:
			case	TYPEDEF:
			case	CLASS_VARIABLE:
				emitRex(type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				t = right.type;
				right.type = type;
				modRM(right, rmValues[left], 0, offset);
				right.type = t;
				break;
				
			default:
				printf("%s %s %s +%d\n", string(instruction), type.signature(), string(left), offset);
				right.print(4);
				assert(false);
			}
			break;
			
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x8d);
			ref<Type> t = right.type;
			right.type = type;
			modRM(right, rmValues[left], 0, offset);
			right.type = t;
			break;
						
		default:
			printf("%s %s %s +%d\n", string(instruction), type.signature(), string(left), offset);
			right.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, R baseReg, int offset) {
		switch (instruction) {
		case	PUSH:
			emitRex(runtime.TypeFamily.VOID, null, R.NO_REG, baseReg);
			emit(0xff);
			if (offset == 0)
				modRM(0, 6, rmValues[baseReg]);
			else if (offset >= -128 && offset <= 127) {
				modRM(1, 6, rmValues[baseReg]);
				emit(byte(offset));
			} else {
				modRM(2, 6, rmValues[baseReg]);
				emitInt(offset);
			}
			return;
			
		case	SAR:
			emitRex(runtime.TypeFamily.SIGNED_64, null, R.NO_REG, baseReg);
			emit(0xd1);
			modRM(3, 7, rmValues[baseReg]);
			return;
		}
		printf("%s [%s+%d]\n", string(instruction), string(baseReg), offset);
		assert(false);
	}
	
	void inst(X86 instruction, R dest, R reg, int offset) {
		switch (instruction) {
		case	MOV:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, reg);
			emit(byte(opcodes[instruction] + 0x03));
			if (offset >= -128 && offset <= 127) {
				modRM(1, rmValues[dest], rmValues[reg]);
				emit(byte(offset));
			} else {
				modRM(2, rmValues[dest], rmValues[reg]);
				emitInt(offset);
			}
			break;
			
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, reg);
			emit(0x8d);
			if (reg == R.RSP) {
				if (offset >= -128 && offset <= 127) {
					modRM(1, rmValues[dest], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				if (offset >= -128 && offset <= 127) {
					modRM(1, rmValues[dest], rmValues[reg]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], rmValues[reg]);
					emitInt(offset);
				}
			}
			break;
			
		default:
			printf("%s, %s, %s, %d\n", string(instruction), string(dest), string(reg), offset);
			assert(false);
		}
	}

	void inst(X86 instruction, R dest, R reg, R index) {
		switch (instruction) {
		case	MOV:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, reg);
			emit(byte(opcodes[instruction] + 0x03));
			modRM(0, rmValues[dest], 4);
			sib(0, rmValues[reg], rmValues[index]);
			break;
			
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, reg);
			emit(0x8d);
			modRM(0, rmValues[dest], 4);
			sib(0, rmValues[reg], rmValues[index]);
			break;
			
		default:
			printf("%s, %s, %s, %s\n", string(instruction), string(dest), string(reg), string(index));
			assert(false);
		}
	}
	
	void inst(X86 instruction, runtime.TypeFamily family, R dest, R reg, int offset) {
		switch (instruction) {
		case	MOVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			if (reg == R.RSP) {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[dest], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				printf("%s, %s, %s, %d, %s\n", string(instruction), string(family), string(dest), offset, string(reg));
				assert(false);
			}
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			if (reg == R.RSP) {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[dest], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				printf("%s, %s, %s, %d, %s\n", string(instruction), string(family), string(dest), offset, string(reg));
				assert(false);
			}
			break;
			
		case	MOV:
			emitRex(family, null, dest, reg);
			emit(byte(opcodes[instruction] + 0x03));
			if (offset >= -128 || offset <= 127) {
				modRM(1, rmValues[dest], rmValues[reg]);
				emit(byte(offset));
			} else {
				modRM(2, rmValues[dest], rmValues[reg]);
				emitInt(offset);
			}
			break;

		default:
			printf("%s, %s, %s, %s, %d\n", string(instruction), string(family), string(dest), string(reg), offset);
			assert(false);
		}
	}

	void inst(X86 instruction, runtime.TypeFamily family, R dest, int offset, R reg) {
		switch (instruction) {
		case	MOVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.FLOAT_64, null, reg, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			if (dest == R.RSP) {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], rmValues[dest]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], rmValues[dest]);
					emitInt(offset);
				}
			}
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.FLOAT_64, null, reg, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			if (dest == R.RSP) {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], rmValues[dest]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], rmValues[dest]);
					emitInt(offset);
				}
			}
			break;
			
		case	MOV:
		case	CMP:
			emitRex(family, null, reg, dest);
			if (dest == R.RSP) {
				switch (family) {
				case	UNSIGNED_8:
					emit(opcodes[instruction]);
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				case	SIGNED_32:
					emit(byte(opcodes[instruction] + 0x01));
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				case	REF:
				case	POINTER:
				case	ADDRESS:
					emit(byte(opcodes[instruction] + 0x01));
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				default:
					printf("%s %s %s +%d %s\n", string(instruction), string(family), string(dest), offset, string(reg));
					assert(false);
				}
			} else {
				emit(byte(opcodes[instruction] + 0x01));
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], rmValues[dest]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], rmValues[dest]);
					emitInt(offset);
				}
				break;
			}
			break;
			
		default:
			printf("%s, %s, %d, %s\n", string(instruction), string(dest), offset, string(reg));
			assert(false);
		}
	}
	
	void inst(X86 instruction, R dest, R src) {
		switch (instruction) {
		case	PXOR:
			emit(0x66);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0xef);
			modRM(3, rmValues[dest], rmValues[src]);
			return;

		default:
			printf("%s, %s, %s\n", string(instruction), string(dest), string(src));
			assert(false);
		}
	}

	void inst(X86 instruction, runtime.TypeFamily family, R dest, R src) {
		switch (instruction) {
		case	SAL:
			switch (family) {
			case	UNSIGNED_8:
				emit(0xd2);
				modRM(3, 4, rmValues[dest]);
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xd3);
				modRM(3, 4, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
				assert(false);
			}
			break;
			
		case	SHR:
			switch (family) {
			case	UNSIGNED_8:
				emit(0xd2);
				modRM(3, 5, rmValues[dest]);
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xd3);
				modRM(3, 5, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
				assert(false);
			}
			break;
			
		case	SAR:
			switch (family) {
			case	SIGNED_16:
				emit(0x66);
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xd3);
				modRM(3, 7, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
				assert(false);
			}
			break;
			
		case	UCOMISD:
			emit(0x66);
		case	UCOMISS:
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x2e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSS2SD:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;

		case	CVTSD2SS:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;

		case	CVTSS2SI:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2d);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTTSS2SI:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSD2SI:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2d);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTTSD2SI:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSI2SS:
			emit(0xf3);
			emitRex(family, null, dest, src);
			emit(0x0f);
			emit(0x2a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSI2SD:
			emit(0xf2);
			emitRex(family, null, dest, src);
			emit(0x0f);
			emit(0x2a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x58);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x58);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MULSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x59);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MULSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x59);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	DIVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	DIVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	XORPD:
			emit(0x66);
		case	XORPS:
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x57);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, src, dest);
			emit(0x0f);
			emit(0x11);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, src, dest);
			emit(0x0f);
			emit(0x11);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVSXD:
			emitRex(runtime.TypeFamily.SIGNED_64, null, src, dest);
			emit(0x63);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	MOVZX:
			emitRex(family, null, src, dest);
			emit(0x0f);
			emit(0xb7);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVZX_8:
			emitRex(family, null, src, dest);
			emit(0x0f);
			emit(0xb6);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVSX:
			emitRex(runtime.TypeFamily.SIGNED_32, null, src, dest);
			emit(0x0f);
			emit(0xbf);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	MOVSX_REX_W:
			emitRex(runtime.TypeFamily.SIGNED_64, null, src, dest);
			emit(0x0f);
			emit(0xbf);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	XCHG:
			emitRex(family, null, src, dest);
			emit(0x87);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	MOV:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, dest, src);
				if ((getRegMask(dest) & byteMask) != 0 && (getRegMask(src) & byteMask) != 0) {
					// Both are valid byte registers, so use the byte instruction.
					emit(byte(opcodes[instruction] + 0x02));
				} else {
					emit(byte(opcodes[instruction] + 0x03));
				}
				modRM(3, rmValues[dest], rmValues[src]);
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	CLASS:
			case	ADDRESS:
			case	CLASS_VARIABLE:
			case	REF:
			case	POINTER:
			case	STRING:
			case	STRING16:
			case	SIGNED_64:
			case	FUNCTION:
			case	VAR:
			case	TYPEDEF:
			case	INTERFACE:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			default:
				printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
				assert(false);
			}
			return;
			
		case	OR:
		case	XOR:
		case	AND:
		case	CMP:
		case	ADD:
		case	SUB:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, dest, src);
				if ((getRegMask(dest) & byteMask) != 0 && (getRegMask(src) & byteMask) != 0)
					emit(byte(opcodes[instruction] + 0x02));
				else
					emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	CLASS:
			case	ADDRESS:
			case	CLASS_VARIABLE:
			case	REF:
			case	POINTER:
			case	STRING:
			case	STRING16:
			case	SIGNED_64:
			case	FUNCTION:
			case	VAR:
			case	TYPEDEF:
			case	INTERFACE:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			default:
				printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
				assert(false);
			}
		}
		printf("%s %s %s %s\n", string(instruction), string(family), string(dest), string(src));
		assert(false);
	}
	
	void inst(X86 instruction, ref<Node> operand) {
		if ((operand.nodeFlags & ADDRESS_MODE) == 0) {
			inst(instruction, operand.type.family(), R(operand.register));
			return;
		}
		switch (instruction) {
		case	CALL:
			emit(0xff);
			modRM(operand, 2, 0, 0);
			break;
			
		case	NEG:
		case	NOT:
			switch (operand.type.family()) {
			case	UNSIGNED_8:
				emitRex(operand.type.family(), operand, R.NO_REG, R.NO_REG);
				emit(0xf6);
				modRM(operand, group3opcodes[instruction], 0, 0);
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(operand.type.family(), operand, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(operand, group3opcodes[instruction], 0, 0);
				break;
				
			default:
				printf("%s\n", string(instruction));
				operand.print(0);
				assert(false);
			}
			break;
			
		default:
			printf("%s\n", string(instruction));
			operand.print(0);
			assert(false);
		}
	}

	void inst(X86 instruction, ref<Node> operand, ref<CompileContext> compileContext) {
		if (operand.register != 0) {
			inst(instruction, operand.type.family(), R(int(operand.register)));
			return;
		}
		switch (instruction) {
		case	PUSH:
			
		default:
			printf("%s -\n", string(instruction));
			operand.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, runtime.TypeFamily family, R reg) {
		switch (instruction) {
		case	CWD:
			switch (family) {
			case	SIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
				emit(0x99);
				return;
				
			case	SIGNED_64:
				emit(REX_W);
				emit(0x99);
				return;
			}
			break;
			
		case	IDIV:
		case	NOT:
		case	NEG:
			emitRex(family, null, R.NO_REG, reg);
			emit(0xf7);
			modRM(3, group3opcodes[instruction], rmValues[reg]);
			return;			

		case	CALL:
			switch (reg) {
			case RAX:
			case RCX:
				emit(0xff);
				modRM(3, 2, rmValues[reg]);
				return;
			}
			break;
			
		case	PUSH:
			emitRex(runtime.TypeFamily.SIGNED_32, null, R.NO_REG, reg);
			emit(byte(0x50 + rmValues[reg]));
			return;
			
		case	POP:
			emitRex(runtime.TypeFamily.SIGNED_32, null, R.NO_REG, reg);
			emit(byte(0x58 + rmValues[reg]));
			return;
		}
		printf("%s %s %s\n", string(instruction), string(family), string(reg));
		assert(false);
	}
	/*
	 * The left must represent an address mode.
	 */
	void inst(X86 instruction, ref<Node> left, R right, ref<CompileContext> compileContext) {
		switch (instruction) {
		case	MOVSS:
			emit(0xf3);
			emitRex(left.type.family(), left, right, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			modRM(left, rmValues[right], 0, 0);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(left.type.family(), left, right, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			modRM(left, rmValues[right], 0, 0);
			break;
			
		case	SAL:
		case	SAR:
		case	SHR:
			switch (left.type.family()) {
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, right, R.NO_REG);
				emit(0xd2);
				modRM(left, shiftReg[instruction], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
				emitRex(left.type.family(), left, right, R.NO_REG);
				emit(0xd3);
				modRM(left, shiftReg[instruction], 0, 0);
				break;
				
			default:
				printf("%s - %s\n", string(instruction), string(right));
				left.print(4);
				assert(false);
			}
			break;
			
		case	CMP:
		case	AND:
		case	OR:
		case	MOV:
		case	XOR:
		case	ADD:
		case	SUB:
			switch (impl(left.type)) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(impl(left.type), left, right, R.NO_REG);
				emit(opcodes[instruction]);
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(impl(left.type), left, right, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x01));
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	STRING:
			case	STRING16:
			case	SIGNED_64:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	FUNCTION:
			case	CLASS_VARIABLE:
			case	INTERFACE:
			case	TYPEDEF:
				emitRex(impl(left.type), left, right, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x01));
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	CLASS:
				switch (left.type.size()) {
				case	1:
					emitRex(runtime.TypeFamily.SIGNED_8, left, right, R.NO_REG);
					emit(opcodes[instruction]);
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	2:
					emit(0x66);
					emitRex(runtime.TypeFamily.SIGNED_16, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	4:
					emitRex(runtime.TypeFamily.SIGNED_32, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	8:
					emitRex(runtime.TypeFamily.SIGNED_64, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				default:
					printf("%s - %s\n", string(instruction), string(right));
					left.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s - %s\n", string(instruction), string(right));
				left.print(4);
				assert(false);
			}
			break;
			
		default:
			printf("%s - %s\n", string(instruction), string(right));
			left.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, R left, ref<Symbol> right, ref<CompileContext> compileContext) {
		switch (instruction) {
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, null, left, R.NO_REG);
			emit(0x8d);
			modRM(right, rmValues[left], 0, 0);
			break;

		default:
			printf("%s %s -\n", string(instruction), string(left));
			right.print(4, false);
			assert(false);
		}
	}

	void inst(X86 instruction, R left, ref<Node> right, ref<CompileContext> compileContext) {
		if (right.deferGeneration())
			return;
		switch (instruction) {
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x8d);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	MOVZX:
			emitRex(right.type.family(), right, left, R.NO_REG);
			emit(0x0f);
			emit(0xb6);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSX:
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0xbf);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSX_REX_W:
			emitRex(runtime.TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x0f);
			emit(0xbf);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSXD:
			emitRex(runtime.TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x63);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MULSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x59);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MULSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x59);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	DIVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5e);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	DIVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5e);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	CVTSS2SD:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5a);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	CVTSD2SS:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5a);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	UCOMISD:
			emit(0x66);
		case	UCOMISS:
			emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x2e);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	MOV:
		case	ADD:
		case	SUB:
		case	OR:
		case	XOR:
		case	AND:
			switch (impl(right.type)) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(impl(right.type), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x02));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(impl(right.type), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
			case	INTERFACE:
			case	ADDRESS:
			case	FUNCTION:
			case	REF:
			case	POINTER:
			case	STRING:
			case	STRING16:
			case	VAR:
			case	TYPEDEF:
			case	CLASS_VARIABLE:
				emitRex(impl(right.type), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	CLASS:
				switch (right.type.size()) {
				case	1:
					emitRex(runtime.TypeFamily.SIGNED_8, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x02));
					modRM(right, rmValues[left], 0, 0);
					break;

				case	2:
					emit(0x66);
					emitRex(runtime.TypeFamily.SIGNED_16, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				case	4:
					emitRex(runtime.TypeFamily.SIGNED_32, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				case	8:
					emitRex(runtime.TypeFamily.SIGNED_64, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				default:
					printf("%s %s - (%d)\n", string(instruction), string(left), right.type.size());
					right.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s %s -\n", string(instruction), string(left));
				right.print(4);
				assert(false);
			}
			break;
			
		case	DIV:
		case	IDIV:
		case	MUL:
			assert(left == R.RAX);
			switch (right.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(runtime.TypeFamily.SIGNED_8, right, left, R.NO_REG);
				emit(0xf6);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0xf7);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0xf7);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			default:
				printf("%s %s -\n", string(instruction), string(left));
				right.print(4);
				assert(false);
			}
			break;
				
		case	IMUL:
			switch (right.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			default:
				printf("%s %s -\n", string(instruction), string(left));
				right.print(4);
				assert(false);
			}
			break;
				
		default:
			printf("%s %s -\n", string(instruction), string(left));
			right.print(4);
			assert(false);
		}
	}
	
	void instLoadEnumAddress(R reg, ref<Node> n, int offset) {
		// Generate an LEA reg,n
		emitRex(runtime.TypeFamily.SIGNED_64, n, reg, R.NO_REG);
		emit(0x8d);
		ref<Symbol> symbol;
		if (n.type.class == EnumType)
			symbol = ref<EnumType>(n.type).symbol();
		else
			symbol = n.symbol();
		enumAddressModRM(symbol, rmValues[reg], 0, n.type != null ? offset * n.type.size() : 0);
	}

	void instString(X86 instruction, R left, string literal) {
		int offset = addStringLiteral(literal);
		emitRex(runtime.TypeFamily.SIGNED_64, null, left, R.NO_REG);
		emit(0x8d);
		modRM(0, rmValues[left], 5);
		fixup(FixupKind.RELATIVE32_STRING, address(offset));
		emitInt(0);
	}

	void inst(X86 instruction, R left, ref<Node> right, int immediate) {
		switch (instruction) {
		case	IMUL:
			switch (right.type.family()) {
			case	UNSIGNED_8:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x6b);
				modRM(right, rmValues[left], byte.bytes, 0);
				emit(byte(immediate));
				break;
/*				
			case	UNSIGNED_16:
				if (rexValues[left] != 0)
					emit(rexValues[left]);
				emit(0x66);
				emit(0x69);
				modRM(right, rmValues[left]);
				emitShort(immediate);
				break;
 */				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x69);
				modRM(right, rmValues[left], int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x69);
				modRM(right, rmValues[left], int.bytes, 0);
				emitInt(immediate);
				break;
				
			default:
				printf("%s %s -, %d\n", string(instruction), string(left), immediate);
				right.print(4);
				assert(false);
			}
			break;
				
		default:
			printf("%s %s -, %d\n", string(instruction), string(left), immediate);
			right.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, ref<Node> left, int immediate, ref<CompileContext> compileContext) {
		switch (instruction) {
		case	IMUL:
			emitRex(left.type.family(), left, R(int(left.register)), R.NO_REG);
			if (immediate >= -128 || immediate <= 127) {
				emit(0x6b);
				modRM(left, rmValues[R(int(left.register))], byte.bytes, 0);
				emit(byte(immediate));
			} else {
				emit(0x69);
				modRM(left, rmValues[R(int(left.register))], int.bytes, 0);
				emitInt(immediate);				
			}
			break;
			
		case	TEST:
			switch (left.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf6);
				modRM(left, 0, int.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	SIGNED_64:
			case	STRING:
			case	ADDRESS:
			case	REF:
			case	POINTER:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;

			default:
				printf("%s - %d\n", string(instruction), int(immediate));
				left.print(4);
				assert(false);
			}
			break;
				
		case	CMP:
		case	AND:
		case	OR:
		case	XOR:
		case	ADD:
		case	SUB:
			switch (impl(left.type)) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x80);
				modRM(left, group1opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x81);
				modRM(left, group1opcodes[instruction], int.bytes, 0);
				emitShort(immediate);
				break;

			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
			case	STRING:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	INTERFACE:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x81);
				modRM(left, group1opcodes[instruction], int.bytes, 0);
				emitInt(immediate);
				break;

			default:
				printf("%s - %d\n", string(instruction), int(immediate));
				left.print(4);
				assert(false);
			}
			break;
				
		case	SAL:
		case	SAR:
		case	SHR:
			switch (left.type.family()) {
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc0);
				modRM(left, group2opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc1);
				modRM(left, group2opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			default:
				printf("%s - %d\n", string(instruction), int(immediate));
				left.print(4);
				assert(false);
			}
			break;
			
		case	MOV:
			switch (impl(left.type)) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				if (left.register == 0 || fits(R(left.register), byteMask)) {
					emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
					emit(0xc6);
					modRM(left, 0, byte.bytes, 0);
					emit(byte(immediate));
					break;
				}
				
			case	SIGNED_16:
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc7);
				modRM(left, 0, int.bytes, 0);
				emitShort(immediate);
				break;

			case	FLOAT_32:
			case	FLOAT_64:
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	STRING:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	SIGNED_64:
			case	FUNCTION:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	CLASS:
				switch (left.type.size()) {
				case	1:
					emit(0xc6);
					modRM(left, 0, byte.bytes, 0);
					emit(byte(immediate));
					break;
					
				case	2:
					emit(0x66);
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitShort(immediate);
					break;
					
				case	4:
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitInt(immediate);
					break;
					
				case	8:
					emit(REX_W);
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitInt(immediate);
					break;
					
				default:
					printf("%s - %d\n", string(instruction), int(immediate));
					left.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s - %d\n", string(instruction), int(immediate));
				left.print(4);
				assert(false);
			}
			break;
						
		default:
			printf("%s - %d\n", string(instruction), immediate);
			left.print(4);
			assert(false);
		}
	}

	void inst(X86 instruction, runtime.TypeFamily family, R base, int offset, int immediate) {
		switch (instruction) {
		case	MOV:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, base, R.NO_REG);
				emit(0xc6);
				modRM(0, base, offset);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(family, null, base, R.NO_REG);
				emit(0xc7);
				modRM(0, base, offset);
				emitShort(immediate);
				break;

			case	UNSIGNED_32:
			case	SIGNED_32:
			case	STRING:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	SIGNED_64:
			case	FUNCTION:
				emitRex(family, null, base, R.NO_REG);
				emit(0xc7);
				modRM(0, base, offset);
				emitInt(immediate);
				break;
				
			default:
				printf("%s [%s+%d] %d\n", string(instruction), string(base), offset, int(immediate));
				assert(false);
			}
			break;
						
		default:
			printf("%s [%s+%d] %d\n", string(instruction), string(base), offset, int(immediate));
			assert(false);
		}
	}
	
	void inst(X86 instruction, int immediate) {
		switch (instruction) {
		case	ENTER:
			emit(0xc8);
			emit(byte(immediate));
			emit(byte(immediate >> 8));
			emit(0);
			break;
		
		case	PUSH:
			emit(REX_W);
			if (immediate >= -128 && immediate <= 127) {
				emit(0x6a);
				emit(byte(immediate));
			} else {
				emit(0x68);
				emitInt(immediate);
			}
			break;
			
		case	RET:
			if (immediate > 0) {
				emit(0xc2);
				emitShort(immediate);
			} else
				emit(0xc3);
			break;
			
		default:
			printf("%s %d\n", string(instruction), immediate);
			assert(false);
		}
	}
	
	void inst(X86 instruction) {
		switch (instruction) {
		case	LEAVE:
			emit(0xc9);
			return;
			
		case	RET:
			emit(0xc3);
			return;
		}
		assert(false);
	}
	
	boolean instCall(ref<ParameterScope> functionScope, ref<CompileContext> compileContext) {
		ref<ParameterScope> func;
		boolean isNativeBinding;
		
		(func, isNativeBinding) = getFunctionAddress(functionScope, compileContext);
		if (func == null)
			return false;
		if (isNativeBinding) {
			if (sectionType() == runtime.Target.X86_64_WIN)
				inst(X86.SUB, runtime.TypeFamily.ADDRESS, R.RSP, 16);
			emit(0xff);
			modRM(0, 2, 5);
			fixup(FixupKind.NATIVE32, functionScope.value);
			emitInt(0);
			if (sectionType() == runtime.Target.X86_64_WIN)
				inst(X86.ADD, runtime.TypeFamily.ADDRESS, R.RSP, 16);
		} else {
			emit(0xe8);
			fixup(FixupKind.RELATIVE32_CODE, func);
			emitInt(0);
		}
		return true;
	}
	
	boolean instJump(ref<ParameterScope> functionScope, ref<CompileContext> compileContext) {
		ref<ParameterScope> func;
		boolean isNativeBinding;
		
		(func, isNativeBinding) = getFunctionAddress(functionScope, compileContext);
		if (func == null)
			return false;
		if (isNativeBinding) {
			printf("Can't jump to a built-in\n");
			assert(false);
		} else {
			emit(0xe9);
			fixup(FixupKind.RELATIVE32_CODE, func);
			emitInt(0);
		}
		return true;
	}
	
	boolean instLoadFunctionAddress(R dest, ref<ParameterScope> functionScope, ref<CompileContext> compileContext) {
		ref<ParameterScope> func;
		boolean isNativeBinding;
		
		(func, isNativeBinding) = getFunctionAddress(functionScope, compileContext);
		if (func == null)
			return false;
		emit(byte(REX_W | rexValues[dest]));
		if (isNativeBinding) {
			// MOV
			emit(0x8b);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.NATIVE32, functionScope.value);
			emitInt(0);
		} else {
			// LEA
			emit(0x8d);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.RELATIVE32_CODE, func);
		}
		emitInt(0);
		return true;
	}

	void instFunc(X86 instruction, R dest, ref<Scope> func) {
		switch (instruction) {
		case	MOV:			
			emit(byte(REX_W | rexbValues[dest]));
			emit(byte(0xb8 + rmValues[dest]));
			fixup(FixupKind.ABSOLUTE64_CODE, func);
			emitLong(0);
			break;
			
		default:
			assert(false);
		}
	}
	
	void instNativeBinding(X86 instruction, R dest, ref<ParameterScope> functionScope) {
		switch (instruction) {
		case	MOV:			
			emit(byte(REX_W | rexValues[dest]));
			emit(0x8b);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.NATIVE32, functionScope.value);
			emitInt(0);
			break;
			
		default:
			assert(false);
		}
	}
	
	void instPush(ref<Node> node, int offset) {
		if (node.register != 0) {
			inst(X86.PUSH, runtime.TypeFamily.ADDRESS, R(int(node.register)));
			return;
		}
		switch (node.op()) {
		case	SUBSCRIPT:
			emitRex(runtime.TypeFamily.SIGNED_32, node, R.NO_REG, R.NO_REG);
			emit(0xff);
			subscriptModRM(node, 6, offset);
			break;
			
		case	DOT:
		case	IDENTIFIER:
			ref<Symbol> sym = node.symbol();
			if (sym == null) {
				node.print(0);
				assert(false);
			}
			switch (sym.storageClass()) {
			case	STATIC:
				emit(0xff);
				modRM(0, 6, 5);
				fixup(FixupKind.RELATIVE32_DATA, sym);
				emitInt(offset);
				break;
				
			case	AUTO:
			case	PARAMETER:
				emit(0xff);
				offset += int(sym.offset);
				if (offset >= -128 && offset <= 127) {
					modRM(1, 6, 5);
					emit(byte(offset));
				} else {
					modRM(2, 6, 5);
					emitInt(offset);
				}
				break;
/*				
			case	ENUMERATION:
				ref<EnumInstanceType> t = ref<EnumInstanceType>(node.type);
				loadEnumType(R.RAX, t.symbol(), 0);
				inst(X86.PUSH, runtime.TypeFamily.ADDRESS, R.RAX);
				break;
 */
			case	MEMBER:
				offset += int(sym.offset);
				if (node.op() == Operator.DOT && !ref<Selection>(node).indirect()) {
					ref<Selection> dot = ref<Selection>(node);
					instPush(dot.left(), offset);
					break;
				}
				emit(0xff);
				int regValue;
				if (node.op() == Operator.DOT) {
					ref<Selection> dot = ref<Selection>(node);
					regValue = rmValues[R(int(dot.left().register))];
				} else
					regValue = rmValues[thisRegister()];
				if (offset >= -128 && offset <= 127) {
					modRM(1, 6, regValue);
					emit(byte(offset));
				} else {
					modRM(2, 6, regValue);
					emitInt(offset);
				}
				break;

			default:
				printf("StorageClass %s\n", string(sym.storageClass()));
				node.print(0);
				assert(false);
			}
			break;
			
		case	INDIRECT:
			ref<Unary> u = ref<Unary>(node);
			R reg = R(int(u.operand().register));
			emit(0xff);
			if (offset == 0)
				modRM(0, 6, rmValues[reg]);
			else if (offset >= -128 && offset <= 127) {
				modRM(1, 6, rmValues[reg]);
				emit(byte(offset));
			} else {
				modRM(2, 6, rmValues[reg]);
				emitInt(offset);
			}
			break;
			
		case	VARIABLE:
			emit(0xff);
			ref<Variable> v = ref<Reference>(node).variable();
			offset += v.offset + ref<Reference>(node).offset(); 
			if (offset >= -128 && offset <= 127) {
				modRM(1, 6, 5);
				emit(byte(offset));
			} else {
				modRM(2, 6, 5);
				emitInt(offset);
			}
			break;
			
		case	SEQUENCE:
			ref<Binary> b = ref<Binary>(node);
			instPush(b.right(), offset);
			break;
			
		default:
			node.print(0);
			assert(false);
		}
	}
	
	public void inst(X86 instruction, R dest, ref<Symbol> constant) {
		switch (instruction) {
		case	MOV:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, R.NO_REG);
			emit(byte(opcodes[instruction] + 0x03));
			break;
			
		case	LEA:
			emitRex(runtime.TypeFamily.SIGNED_64, null, dest, R.NO_REG);
			emit(0x8d);
			break;
			
		case	XORPD:
			emit(0x66);
		case	XORPS:
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x57);
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			break;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			break;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			break;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			break;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			break;
		
		case UCOMISD:
			emit(0x66);
		case UCOMISS:
			emit(0x0f);
			emit(0x2e);
			emitRex(runtime.TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			break;

		default:
			printf("%s %s \n", string(instruction), string(dest));
			constant.print(0, false);
			assert(false);
			emit(0x10);
		}
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_DATA, constant);
		emitInt(0);
	}
	
	public void instLoadType(R destination, ref<Type> type) {
		emit(REX_W);
		emit(0x8d);			// LEA
		modRM(0, rmValues[destination], 5);
		fixup(FixupKind.RELATIVE32_TYPE, type);
		emitInt(type.copyToImage(this));
	}
	
	public void instStoreVTable(R thisPointer, int offset, R tempRegister, ref<ClassScope> scope) {
		instLoadVtable(tempRegister, scope);
		emit(REX_W);
		emit(0x89);			// MOV
		if (offset == 0)
			modRM(0, rmValues[tempRegister], rmValues[thisPointer]);
		else if (offset < 128) {
			modRM(1, rmValues[tempRegister], rmValues[thisPointer]);
			emit(byte(offset));
		} else {
			modRM(2, rmValues[tempRegister], rmValues[thisPointer]);
			emitInt(offset);
		}
	}
	
	public void instLoadVtable(R dest, ref<ClassScope> scope) {
		emit(REX_W);
		emit(0x8d);			// LEA
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_VTABLE, scope);
		emitInt(0);
	}
	/*
	 * ipAdjust is an adjustment that should be applied to ip relative address modes.
	 * allAdjust is an adjustment that should be applied to all address modes.
	 */
	private void modRM(ref<Node> addressMode, int regOpcode, int ipAdjust, int allAdjust) {
		if (addressMode.register != 0) {
			modRM(3, regOpcode, rmValues[R(int(addressMode.register))]);
			return;
		}
		switch (addressMode.op()) {
		case	SEQUENCE:
			ref<Binary> b = ref<Binary>(addressMode);
			modRM(b.right(), regOpcode, ipAdjust, allAdjust);
			break;
			
		case	THIS:
		case	SUPER:
			modRM(3, regOpcode, rmValues[thisRegister()]);
			break;

		case	ELLIPSIS_DATA:
			offset = ref<Reference>(addressMode).offset() + allAdjust;
			if (offset >= -128 && offset <= 127) {
				modRM(1, regOpcode, 4);
				sib(0, 4, 4);
				emit(byte(offset));
			} else {
				modRM(2, regOpcode, 4);
				sib(0, 4, 4);
				emitInt(offset);
			}
			break;

		case	VARIABLE:
			ref<Variable> v = ref<Reference>(addressMode).variable();
			int offset = v.offset + ref<Reference>(addressMode).offset() + allAdjust;
			if (offset >= -128 && offset <= 127) {
				modRM(1, regOpcode, 5);
				emit(byte(offset));
			} else {
				modRM(2, regOpcode, 5);
				emitInt(offset);
			}
			break;
			
		case	DOT:
		case	IDENTIFIER:
			ref<Symbol> sym = addressMode.symbol();
			if (sym == null) {
				addressMode.print(0);
				assert(false);
			}
			switch (sym.storageClass()) {
			case	STATIC:
				modRM(sym, regOpcode, ipAdjust, allAdjust);
				break;
				
			case	ENUMERATION:
				ref<EnumInstanceType> eit = ref<EnumInstanceType>(sym.type());
				enumAddressModRM(eit.typeSymbol(), regOpcode, ipAdjust, allAdjust + int(sym.offset) * eit.enumType().size());
				break;
				
			case	AUTO:
			case	PARAMETER:
				int offset = int(sym.offset) + allAdjust;
				if (offset >= -128 && offset <= 127) {
					modRM(1, regOpcode, 5);
					emit(byte(offset));
				} else {
					modRM(2, regOpcode, 5);
					emitInt(offset);
				}
				break;
				
			case	MEMBER:
			case	LOCK:
				int baseReg;
				if (addressMode.op() == Operator.IDENTIFIER)
					baseReg = rmValues[thisRegister()];
				else {
					ref<Selection> dot = ref<Selection>(addressMode);
					ref<Node> object = dot.left();
					while (object.op() == Operator.SEQUENCE) {
						ref<Binary> b = ref<Binary>(object);
						object = b.right();
					}
					if (object.op() == Operator.THIS || object.op() == Operator.SUPER)
						baseReg = rmValues[thisRegister()];
					else if ((object.nodeFlags & ADDRESS_MODE) != 0) {
						modRM(object, regOpcode, ipAdjust, int(sym.offset) + allAdjust);
						return;
					} else
						baseReg = rmValues[R(int(object.register))];
				}
				allAdjust += int(sym.offset);
				if (allAdjust >= -128 && allAdjust <= 127) {
					modRM(1, regOpcode, baseReg);
					emit(byte(allAdjust));
				} else {
					modRM(2, regOpcode, baseReg);
					emitInt(allAdjust);
				}
				break;

			default:
				printf("modRM(Identifier, %d)\n", regOpcode);
				addressMode.print(4);
				assert(false);
			}
			break;
			
		case	FLOATING_POINT:
			modRM(0, regOpcode, 5);
			pointer<byte> endPtr;
			ref<Constant> con = ref<Constant>(addressMode);
			if (con.type.family() == runtime.TypeFamily.FLOAT_32) {
				string s(con.value().c_str(), con.value().length() - 1); // omit the trailing f
				double x = C.strtod(s.c_str(), &endPtr);
				assert(endPtr == s.c_str() + s.length());
				float y = float(x);
				con.offset = _segments[Segments.DATA_4].append(&y, float.bytes);
			} else {
				string s = con.value();
				double x = C.strtod(s.c_str(), &endPtr);
				assert(endPtr == s.c_str() + s.length());
				con.offset = _segments[Segments.DATA_8].append(&x, double.bytes);
			}
			fixup(FixupKind.RELATIVE32_FPDATA, con);
			emitInt(0);
			break;
			
		case	TEMPLATE_INSTANCE:
			modRM(0, regOpcode, 5);
			ref<TypedefType> tt = ref<TypedefType>(addressMode.type);
			ref<Type> tp = tt.wrappedType();
			fixup(FixupKind.RELATIVE32_TYPE, tp);
			emitInt(tp.copyToImage(this));
			break;
			
		case	INDIRECT:
			ref<Unary> u = ref<Unary>(addressMode);
			ref<Node> ptr = u.operand();
			int baseReg;
			if (ptr.op() == Operator.THIS || ptr.op() == Operator.SUPER)
				baseReg = rmValues[thisRegister()];
			else if (ptr.register != 0)
				baseReg = rmValues[R(int(ptr.register))];
			else if (ptr.deferGeneration())
				baseReg = 0;
			else if (ptr.op() == Operator.ADD) {
				b = ref<Binary>(ptr);
				if (b.left().register != 0) {
					baseReg = rmValues[R(int(b.left().register))];
					allAdjust += int(b.right().foldInt(this, null));
				} else {
					baseReg = rmValues[R(int(b.right().register))];
					allAdjust += int(b.left().foldInt(this, null));
				}
			} else {
				printf("modRM(-, %d)\n", regOpcode);
				addressMode.print(4);
				assert(false);
			}
			if (allAdjust == 0) {
				modRM(0, regOpcode, baseReg);
			} else if (allAdjust >= -128 && allAdjust <= 127) {
				modRM(1, regOpcode, baseReg);
				emit(byte(allAdjust));
			} else {
				modRM(2, regOpcode, baseReg);
				emitInt(allAdjust);
			}
			break;
			
		case	SUBSCRIPT:
			subscriptModRM(addressMode, regOpcode, 0);
			break;
			
		case	ADD:
			b = ref<Binary>(addressMode);
			if (b.left().register != 0) {
				baseReg = rmValues[R(int(b.left().register))];
				allAdjust += int(b.right().foldInt(this, null));
			} else {
				baseReg = rmValues[R(int(b.right().register))];
				allAdjust += int(b.left().foldInt(this, null));
			}
			if (allAdjust == 0) {
				modRM(0, regOpcode, baseReg);
			} else if (allAdjust >= -128 && allAdjust <= 127) {
				modRM(1, regOpcode, baseReg);
				emit(byte(allAdjust));
			} else {
				modRM(2, regOpcode, baseReg);
				emitInt(allAdjust);
			}
			break;

		case	STRING:
			ref<Constant> c = ref<Constant>(addressMode);
			string s(c.value());
			string output;
			boolean result;
			(output, result) = s.unescapeParasol();
			offset = addStringLiteral(output);
			modRM(0, regOpcode, 5);
			fixup(FixupKind.RELATIVE32_STRING, address(offset));
			emitInt(0);
			break;
			
		default:
			printf("modRM(-, %d)\n", regOpcode);
			addressMode.print(4);
			assert(false);
		}
	}
	
	private void modRM(byte regOpcode, R base, int offset) {
		if (offset == 0) {
			switch (base) {
			case	RAX:
			case	RBX:
			case	RCX:
			case	RDX:
			case	RSI:
			case	RDI:
				modRM(0, regOpcode, rmValues[base]);
				break;
				
			default:
				modRM(1, regOpcode, rmValues[base]);
				emit(byte(offset));
			}
		} else if (offset >= -128 && offset <= 127) {
			modRM(1, regOpcode, rmValues[base]);
			emit(byte(offset));
		} else {
			modRM(2, regOpcode, rmValues[base]);
			emitInt(offset);
		}
	}
	
	private void modRM(ref<Symbol> sym, int regOpcode, int ipAdjust, int allAdjust) {
		modRM(0, regOpcode, 5);
		if (sym.type().family() == runtime.TypeFamily.TYPEDEF) {
			ref<TypedefType> tt = ref<TypedefType>(sym.type());
			ref<Type> t = tt.wrappedType();
			fixup(FixupKind.RELATIVE32_TYPE, t);
			emitInt(t.copyToImage(this));
		} else {
			fixup(FixupKind.RELATIVE32_DATA, sym);
			emitInt(-ipAdjust + allAdjust);
		}
	}

	private void enumAddressModRM(ref<Symbol> sym, int regOpcode, int ipAdjust, int allAdjust) {
		modRM(0, regOpcode, 5);
		fixup(FixupKind.RELATIVE32_DATA, sym);
		emitInt(-ipAdjust + allAdjust);
	}

	private void subscriptModRM(ref<Node> addressMode, int regOpcode, int offset) {
		ref<Binary> b = ref<Binary>(addressMode);
		int mod = 0;
		if (b.left().type.family() == runtime.TypeFamily.STRING)
			offset += 4;
		if (offset != 0) {
			if (offset >= -128 || offset <= 127)
				mod = 1;
			else
				mod = 2;
		}
		modRM(mod, regOpcode, 4);
		R r1 = R(b.left().register);
		R r2 = R(b.right().register);
		int scale = 0;
		int sz = b.type.size();
		assert(sz <= address.bytes);
		while (sz > 1) {
			scale += 1;
			sz >>= 1;
		}
		sib(scale, rmValues[r2], rmValues[r1]);
		if (mod == 1)
			emit(byte(offset));
		else if (mod == 2)
			emitInt(offset);
	}
	
	public int addStringLiteral(substring value) {
		int sLength = value.length();
		int offset = _segments[Segments.STRINGS].reserve(value.length() + int.bytes + 1);
		pointer<byte> dest = _segments[Segments.STRINGS].at(offset);
		*ref<int>(dest) = sLength;
		C.memcpy(dest + int.bytes, &value.c_str()[0], sLength);
		return offset;
	}
	/*
	 * Calculate the necessary REX bits for this addressmode.
	 */
	private void emitRex(runtime.TypeFamily family, ref<Node> addressMode, R regField, R baseField) {
		byte rex = 0;
		if (addressMode == null)
			rex |= rexbValues[baseField];
		else if (addressMode.register != 0)
			rex |= rexbValues[R(int(addressMode.register))];
		else {
			switch (addressMode.op()) {
			case	SEQUENCE:
				b = ref<Binary>(addressMode);
				emitRex(family, b.right(), regField, baseField);
				return;
				
			case	THIS:
			case	SUPER:
			case	VARIABLE:
			case	TEMPLATE_INSTANCE:
			case	STRING:
			case	FLOATING_POINT:
			case	ELLIPSIS_DATA:
				break;
				
			case	DOT:
			case	IDENTIFIER:
				ref<Symbol> sym = addressMode.symbol();
				if (sym == null) {
					addressMode.print(0);
					assert(false);
				}
				switch (sym.storageClass()) {
				case	STATIC:
				case	AUTO:
				case	PARAMETER:
				case	ENUMERATION:
				case	FLAGS:
					break;
					
				case	LOCK:
				case	MEMBER:
					int baseReg;
					if (addressMode.op() != Operator.IDENTIFIER) {
						ref<Selection> dot = ref<Selection>(addressMode);
						ref<Node> object = dot.left();
						while (object.op() == Operator.SEQUENCE) {
							ref<Binary> b = ref<Binary>(object);
							object = b.right();
						}
						rex |= rexbValues[R(object.register)];
					}
					break;

				default:
					printf("emitRex(-, %s, %s)\n", string(regField), string(baseField));
					addressMode.print(4);
					assert(false);
				}
				break;
				
			case	INDIRECT:
				ref<Unary> u = ref<Unary>(addressMode);
				ref<Node> ptr = u.operand();
				rex |= rexbValues[R(int(ptr.register))];
				break;
				
			case	SUBSCRIPT:
				ref<Binary> b = ref<Binary>(addressMode);
				R r1 = R(int(b.left().register));
				R r2 = R(int(b.right().register));
				rex |= rexbValues[r1];
				rex |= rexxValues[r2];
				break;
				
			case	ADD:
				b = ref<Binary>(addressMode);
				if ((b.left().nodeFlags & ADDRESS_MODE) == 0)
					emitRex(family, b.left(), regField, baseField);
				else
					emitRex(family, b.right(), regField, baseField);
				break;

			default:
				printf("emitRex(-, %s, %s)\n", string(regField), string(baseField));
				addressMode.print(4);
				assert(false);
			}
		}
		switch (family) {
		case	SIGNED_64:
		case	UNSIGNED_64:
		case	STRING:
		case	STRING16:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	FUNCTION:
		case	CLASS:
		case	FLOAT_64:
		case	TYPEDEF:
		case	CLASS_VARIABLE:
		case	VAR:
		case	INTERFACE:
			rex |= REX_W;
		}
		rex |= rexValues[regField];
		if (rex != 0)
			emit(rex);
	}
		
	private void modRM(int mod, int regOpcode, int rm) {
//		printf("modRM(%d, %d, %d)\n", mod, regOpcode, rm);
		assert(regOpcode >= 0 && regOpcode < 8);
		assert(rm >= 0 && rm < 8);
		assert(mod >= 0 && mod < 4);
		emit(byte((mod << 6) | (regOpcode << 3) | rm));
	}
	
	private void sib(int scale, int index, int base) {
		emit(byte((scale << 6) | (index << 3) | base));
	}
	
	private void emit(byte b) {
		_f.ensureCodeSegment(this);
		_functionCode.append(b);
	}
	
	private void emitShort(int immediate) {
		for (int i = 0; i < char.bytes; i++) {
			emit(byte(immediate));
			immediate >>= 8;
		}
	}
	
	private void emitInt(int immediate) {
		for (int i = 0; i < int.bytes; i++) {
			emit(byte(immediate));
			immediate >>= 8;
		}
	}
	
	private void emitLong(long immediate) {
		for (int i = 0; i < address.bytes; i++) {
			emit(byte(int(immediate)));
			immediate >>= 8;
		}
	}
	
	int tempStackDepth() {
		return _t.stackDepth();
	}
	
	void emitSourceLocation(ref<Unit> file, runtime.SourceOffset location) {
		_f.emitSourceLocation(file, location, this);
	}
	
	protected boolean inlineEllipsisArguments(ref<NodeList> args, ref<NodeList> params) {
		ref<Unary> ellipsis = params.node.getProperEllipsis();
		
		// If there is no delcared ellipsis, this is not an inline array call
		if (ellipsis == null)
			return false;
		
		// A call with no optional inline arguments is an inline call.
		if (args == null)
			return true;
		
		// A call with more arguments than parameters is an inline call.
		if (args.next != null)
			return true;
		
		// If the one argument is not the correct array type, it is inline
		return !args.node.type.equals(params.node.type);
	}

	class JumpContext {
		private ref<CodeSegment>[] _caseLabels;
		private int _nextCase;
		private ref<JumpContext> _next;
		private ref<Node> _controller;
		private ref<CodeSegment> _breakLabel;
		private ref<CodeSegment> _continueLabel;

		public JumpContext(ref<Node> controller, ref<CodeSegment> breakLabel, ref<CodeSegment> continueLabel, ref<ref<Node>[]> nodes, ref<X86_64> target, ref<JumpContext> next) {
			_next = next;
			_controller = controller;
			_breakLabel = breakLabel;
			_continueLabel = continueLabel;
			if (nodes != null) {
				for (int i = 0; i < nodes.length(); i++) {
					_caseLabels.append(target._storage new CodeSegment);
					_nextCase++;
				}
			}
		}

		public ref<JumpContext> next() { 
			return _next; 
		}

		public ref<CodeSegment> breakLabel() {
			return _breakLabel; 
		}

		public ref<CodeSegment> continueLabel() {
			if (_controller.op() == Operator.SWITCH)
				return _next.continueLabel();
			else
				return _continueLabel;
		}

		public ref<CodeSegment> consumeDefaultLabel() {
			ref<CodeSegment> defaultLabel = _continueLabel;
			_continueLabel = null;
			return defaultLabel;
		}

		public ref<JumpContext> enclosingSwitch() {
			if (_controller.op() == Operator.SWITCH)
				return this;
			else if (_next != null)
				return _next.enclosingSwitch();
			else
				return null;
		}

		public ref<CodeSegment> nextCaseLabel() {
			--_nextCase;
			return _caseLabels[_nextCase];
		}

		ref<CodeSegment>[] caseLabels() { 
			return _caseLabels; 
		}
	}

	void pushJumpContext(ref<JumpContext> context) {
		_jumpContext = context;
	}
	
	ref<JumpContext> jumpContext() {
		return _jumpContext;
	}

	void popJumpContext() {
		_jumpContext = _jumpContext.next();
	}

	void closeCodeSegment(CC continuation, ref<CodeSegment> jumpTarget) {
		_f.closeCodeSegment(continuation, jumpTarget, this);
	}
	
	void insertPreamble() {
		_f.insertPreamble(this);
	}

	private void fixup(FixupKind kind, address value) {
		 _f.fixup(kind, value, this);
	}
	
	protected void fixup(FixupKind kind, ref<Symbol> locationSymbol, int location, address value) {
		_f.fixup(kind, locationSymbol, location, value, this);
	}
	
	protected void staticFixup(FixupKind kind, ref<Symbol> locationSymbol, int location, address value) {
		 ref<Fixup> f = _storage new Fixup();
		 f.kind = kind;
		 f.locationSymbol = locationSymbol; 
		 f.location = location;
		 f.value = value;
		 f.next = _fixups;
		 _fixups = f;
	}
	
	private int assignBuiltInVector(int builtInId) {
		int i;
		for (i = 0; i < _builtIns.length(); i++)
			if (_builtIns[i] == builtInId)
				return i;
		_builtIns.append(builtInId);
		return i;
	}
	
	protected byte[] functionCode() {
		return _functionCode;
	}
	
	protected ref<FunctionState> f() {
		return _f;
	}

	public int imageLength() {
		return pxi.X86_64SectionHeader.bytes + _staticMemoryLength;
	}
	
	public boolean writePxiFile(storage.File pxiFile) {
		if (pxiFile.write(&_pxiHeader, _pxiHeader.bytes) < 0)
			return false;
		if (pxiFile.write(_staticMemory, _staticMemoryLength) < 0)
			return false;
		return true;
	}
	
	public ref<pxi.X86_64SectionHeader> pxiHeader() {
		return &_pxiHeader;
	}

	public pointer<byte> staticMemory() {
		return _staticMemory;
	}
	
	public int staticMemoryLength() {
		return _staticMemoryLength;
	}
	
	public abstract R firstRegisterArgument();
	
	public abstract R secondRegisterArgument();
	
	public abstract R thirdRegisterArgument();
	
	public abstract R fourthRegisterArgument();
	
	public abstract R thisRegister();
	
	public abstract long longMask();
	
	public long callMask() {
		return longMask()|floatMask;
	}
}

enum FixupKind {
	RELATIVE32_CODE,				// Fixup value is a ref<Scope>
	RELATIVE32_DATA,				// Fixup value is a ref<Symbol>
	RELATIVE32_TYPE,				// Fixup value is a ref<Type>
	RELATIVE32_STRING,				// Fixup value is an int offset into the string pool
	RELATIVE32_VTABLE,				// Fixup value is a ref<ClassScope>
	RELATIVE32_FPDATA,				// Fixup value is a ref<Constant>
	LOCAL32_CODE,					// Fixup value is a ref<CodeSegment>
	ABSOLUTE64_JUMP,				// Fixup value is a ref<CodeSegment>
	ABSOLUTE64_CODE,				// Fixup value is a ref<Scope>
	ABSOLUTE64_DATA,				// Fixup value is a ref<Symbol>
	ABSOLUTE64_STRING,				// Fixup value is a an int offset into the string pool
	INT_CONSTANT,					// Fixup value is the value of the constant
	NATIVE32,						// Fixup value is NativeBindings index
}

class Fixup {
	public FixupKind kind;
	public ref<Symbol> locationSymbol;			// For data-fixups, the static symbol from which
												// the location is offset.
	public int location;						// Where the bytes to be fixed up appear in code
	public address value;						// What the value should be
	public ref<Fixup> next;						// Next fixup
	
	void print() {
		switch (kind) {
		case	RELATIVE32_CODE:				// Fixup value is a ref<Scope>
		case	RELATIVE32_DATA:				// Fixup value is a ref<Symbol>
		case	RELATIVE32_STRING:				// Fixup value is an int offset into the string pool
		case	RELATIVE32_TYPE:				// Fixup value is a ref<Type>
		case	RELATIVE32_VTABLE:				// Fixup value is a ref<ClassScope>
		case	RELATIVE32_FPDATA:				// Fixup value is a ref<Constant>
		case	ABSOLUTE64_JUMP:				// Fixup value is a ref<CodeSegment>
		case	ABSOLUTE64_CODE:				// Fixup value is a ref<Scope>
		case	ABSOLUTE64_DATA:				// Fixup value is a ref<Symbol>
		case	ABSOLUTE64_STRING:				// Fixup value is a ref<Symbol>
		case	INT_CONSTANT:
		case	NATIVE32:						// Fixup value is nativeBindings index
			printf("    @%x %s %p\n", location, string(kind), value);
			break;
			
		default:
			printf("    @%x <error %s> %p\n", location, string(kind), value);
			assert(false);
		}
	}
}

private string ccLabel(CC x) {
	if (x == null)
		return "<null>";
	if (int(x) < 0 || int(x) >= int(CC.MAX_CC)) {
		string s;
		s.printf("<bad:%d>", int(x));
		return s;
	} else
		return string(x);
}
	
/*
 * X86 condition codes
 */
enum CC {
	ERROR,			// Not a valid jump
	JO,				// Jump on overflow
	JNO,			// Jump not overflow
	JB,				// Jump below (unsigned <)
	JNB,			// Jump not below (unsigned >=)
	JE,				// Jump equal / zero
	JNE,			// Jump not equal / zero
	JNA,			// Jump not above (unsigned <=)
	JA,				// Jump above (unsigned >)
	JS,				// Jump on sign
	JNS,			// Jump on no sign
	JP,			// Jump parity even
	JNP,			// Jump parity odd
	JL,				// Jump less (sign <)
	JGE,			// Jump greater or equal (signed >=)
	JLE,			// Jump less or equal (signed <=)
	JG,				// Jump greater (signed >)
	NOP,			// no-op
	JMP,			// Unconditional jump
	MAX_CC
}

CC parityTest(Operator compare, ref<Type> type) {
	if (type.isFloat()) {
		switch (compare) {
		case	NOT_LESS_GREATER:		return CC.NOP;
		case	LESS_GREATER:			return CC.NOP;
		case	NOT_LESS:				return CC.JP;
		case	NOT_GREATER:			return CC.NOP;
		case	NOT_LESS_EQUAL:			return CC.JP;
		case	NOT_GREATER_EQUAL:		return CC.NOP;
		case	NOT_EQUAL:				return CC.JP;
		case	EQUALITY:				return CC.JNP;
		case	GREATER:				return CC.NOP;
		case	GREATER_EQUAL:			return CC.NOP;
		case	LESS:					return CC.JNP;
		case	LESS_EQUAL:				return CC.JNP;
		case	LESS_GREATER_EQUAL:		return CC.NOP;
		case	NOT_LESS_GREATER_EQUAL:	return CC.NOP;
		
		default:
			printf("parityTest(%s,", string(compare));
			type.print();
			printf(")\n");
			assert(false);
		}
		return CC.ERROR;
	} else
		return CC.NOP;
}

CC continuation(Operator compare, ref<Type> type) {
	switch (compare) {
	case	NOT_LESS_GREATER:
		switch (type.family()) {
		case	ENUM:
		case	UNSIGNED_32:
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	ADDRESS:
		case	POINTER:
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JE; 
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	LESS_GREATER:
		switch (type.family()) {
		case	ENUM:
		case	UNSIGNED_32:
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	ADDRESS:
		case	POINTER:
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNE; 
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_LESS:
		switch (type.family()) {
		case	ADDRESS:
		case	POINTER:
		case	ENUM:
		case	UNSIGNED_32:	return CC.JNB;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JGE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNB;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_GREATER:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNA;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JLE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNA;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_LESS_EQUAL:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JA;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JG; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JA;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_GREATER_EQUAL:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JB;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JL; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JB;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_EQUAL:
		switch (type.family()) {
		case	ERROR:
		case	UNSIGNED_8:
		case	UNSIGNED_16:
		case	UNSIGNED_32:
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	FLOAT_32:
		case	FLOAT_64:
		case	BOOLEAN:
		case	FUNCTION:
		case	ADDRESS:
		case	CLASS_VARIABLE:
		case	REF:
		case	POINTER:
		case	FLAGS:
		case	ENUM:
		case	INTERFACE:
		case	TYPEDEF:
		case	CLASS:			return CC.JNE;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	EQUALITY:
		switch (type.family()) {
		case	UNSIGNED_8:
		case	UNSIGNED_16:
		case	UNSIGNED_32:
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	FLOAT_32:
		case	FLOAT_64:
		case	BOOLEAN:
		case	FUNCTION:
		case	ADDRESS:
		case	CLASS_VARIABLE:
		case	REF:
		case	POINTER:
		case	FLAGS:
		case	ENUM:
		case	TYPEDEF:
		case	INTERFACE:
		case	CLASS:			return CC.JE; 
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	GREATER:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JA;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JG; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JA;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	GREATER_EQUAL:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNB;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JGE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNB;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	LESS:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JB;
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JL; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JB;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	LESS_EQUAL:
		switch (type.family()) {
		case	ENUM:
		case	ADDRESS:
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNA;
		case	CLASS_VARIABLE:
		case	SIGNED_16: 
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JLE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNA;		// also need JNP
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	LESS_GREATER_EQUAL:
		switch (type.family()) {
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNP;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	case	NOT_LESS_GREATER_EQUAL:
		switch (type.family()) {
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JP;
		default:
			printf("continuation(%s,%s)\n", string(compare), type.signature());
			assert(false);
		}
		break;

	default:
		printf("continuation(%s,%s)\n", string(compare), type.signature());
		assert(false);
	}
	return CC.ERROR;
}

Operator invert(Operator compare) {
	switch (compare) {
	case	NOT_LESS_GREATER:		return Operator.LESS_GREATER;
	case	NOT_LESS_GREATER_EQUAL:	return Operator.LESS_GREATER_EQUAL;
	case	NOT_LESS:				return Operator.LESS;
	case	NOT_GREATER:			return Operator.GREATER;
	case	NOT_LESS_EQUAL:			return Operator.LESS_EQUAL;
	case	NOT_GREATER_EQUAL:		return Operator.GREATER_EQUAL;
	case	NOT_EQUAL:				return Operator.EQUALITY;
	case	EQUALITY:				return Operator.NOT_EQUAL;
	case	GREATER:				return Operator.NOT_GREATER;
	case	GREATER_EQUAL:			return Operator.NOT_GREATER_EQUAL;
	case	LESS:					return Operator.NOT_LESS;
	case	LESS_GREATER:			return Operator.NOT_LESS_GREATER;
	case	LESS_EQUAL:				return Operator.NOT_LESS_EQUAL;
	case	LESS_GREATER_EQUAL:		return Operator.NOT_LESS_GREATER_EQUAL;
	default:
		printf("invert(%s)\n", string(compare));
		assert(false);
	}
	return Operator.SYNTAX_ERROR;
}

private int[CC] minCCSize = [
	JO: 	2,
	JNO: 	2,
	JB: 	2,
	JNB: 	2,
	JE: 	2,
	JNE: 	2,
	JNA: 	2,
	JA: 	2,
	JS: 	2,
	JNS: 	2,
	JP: 	2,
	JNP: 	2,
	JL: 	2,
	JGE: 	2,
	JLE: 	2,
	JG: 	2,
	JMP:	2,
	MAX_CC: 0
];


private int[CC] maxCCSize= [
	JO: 	6,
	JNO: 	6,
	JB: 	6,
	JNB: 	6,
	JE: 	6,
	JNE: 	6,
	JNA: 	6,
	JA: 	6,
	JS: 	6,
	JNS: 	6,
	JP: 	6,
	JNP: 	6,
	JL: 	6,
	JGE: 	6,
	JLE: 	6,
	JG: 	6,
	JMP: 	5,
	MAX_CC: 0
];


private byte[R] rmValues = [
	NO_REG: 	0xff,
	RAX: 		0,
	RBX: 		3,
	RCX: 		1,
	RDX: 		2,
	RSP: 		4,
	RBP: 		5,
	RSI: 		6,
	RDI: 		7,
	R8: 		0,
	R9: 		1,
	R10: 		2,
	R11: 		3,
	R12: 		4,
	R13: 		5,
	R14: 		6,
	R15: 		7,
	AH: 		4,
	XMM0: 		0,
	XMM1: 		1,
	XMM2: 		2,
	XMM3: 		3,
	XMM4: 		4,
	XMM5: 		5,
	XMM6: 		6,
	XMM7: 		7,
	XMM8: 		0,
	XMM9: 		1,
	XMM10: 		2,
	XMM11: 		3,
	XMM12: 		4,
	XMM13: 		5,
	XMM14: 		6,
	XMM15: 		7,
	MAX_REG: 	0
];

private byte[R] rexValues = [
	R8: 		REX_R,
	R9: 		REX_R,
	R10: 		REX_R,
	R11: 		REX_R,
	R12: 		REX_R,
	R13: 		REX_R,
	R14: 		REX_R,
	R15: 		REX_R,
	XMM8: 		REX_R,
	XMM9: 		REX_R,
	XMM10: 		REX_R,
	XMM11: 		REX_R,
	XMM12: 		REX_R,
	XMM13: 		REX_R,
	XMM14: 		REX_R,
	XMM15: 		REX_R,
	MAX_REG:	byte(0),
];

private byte[R] rexbValues = [
	R8: 		REX_B,
	R9: 		REX_B,
	R10: 		REX_B,
	R11: 		REX_B,
	R12: 		REX_B,
	R13: 		REX_B,
	R14: 		REX_B,
	R15: 		REX_B,
	MAX_REG:	byte(0),
];

private byte[R] rexxValues = [
	R8: 		REX_X,
	R9: 		REX_X,
	R10: 		REX_X,
	R11: 		REX_X,
	R12: 		REX_X,
	R13: 		REX_X,
	R14: 		REX_X,
	R15: 		REX_X,
	MAX_REG:	byte(0),
];

byte[X86] opcodes = [
	ADD:	byte(0x00),
	OR: 	byte(0x08),
	SBB:	byte(0x18),
	AND:	byte(0x20),
	SUB:	byte(0x28),
	XOR:	byte(0x30),
	CMP:	byte(0x38),
	MOV:	byte(0x88),

	MAX_INSTRUCTION: byte(0)
];

byte[X86] shiftReg = [
	SAL:	byte(0x04),
	SAR:	byte(0x07),
	SHR:	byte(0x05),
];

byte[X86] group1opcodes;

group1opcodes.resize(X86.MAX_INSTRUCTION);

group1opcodes[X86.ADD] = 0;
group1opcodes[X86.OR] = 1;
group1opcodes[X86.SBB] = 3;
group1opcodes[X86.AND] = 4;
group1opcodes[X86.SUB] = 5;
group1opcodes[X86.XOR] = 6;
group1opcodes[X86.CMP] = 7;

byte[X86] group2opcodes;

group2opcodes.resize(X86.MAX_INSTRUCTION);

group2opcodes[X86.SAL] = 4;
group2opcodes[X86.SHR] = 5;
group2opcodes[X86.SAR] = 7;

byte[X86] group3opcodes;

group3opcodes.resize(X86.MAX_INSTRUCTION);

group3opcodes[X86.NOT] = 2;
group3opcodes[X86.NEG] = 3;
group3opcodes[X86.MUL] = 4;
group3opcodes[X86.IMUL] = 5;
group3opcodes[X86.DIV] = 6;
group3opcodes[X86.IDIV] = 7;
