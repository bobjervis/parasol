/*
	Copyright (c) 1993 by Robert Jervis
	All rights reserved.

	Permission to use, copy, modify and distribute this software is
	subject to the license described in the READ.ME file.
 */
include	file, filesys;

include	hash;
include	scanner;
include	errmsg;
include	sbuffer;
include	ptree;
include	i386back, backend;
include	tparams, target;
include	symtab;
include	types, functype;

Build:	public	ref build_s;
BuildUnit:	ref csourceUnit_s;

targetType_t:	public	type	byte = {
	TT_NONE,
	TT_COMPILE,
	TT_ASSEMBLE
	};

build_s:	public	type	{
	public:
	sourceName:	[:] char;
	targetType:	targetType_t;
	targetName:	[:] char;
	debugInfo:	boolean;
	optimize:	boolean;
	parser:		ref sourceParserC;

constructor:	() =
	{
	debugInfo = FALSE;
	optimize = TRUE;
	targetType = TT_NONE;
	}

build:	() =
	{
	name:		[:] char;
	s:		[:] char;
	u:		ref csourceUnit_s;

	CurrentContext = [];
	enable386backend(optimize);
	if	(FileSystem access(sourceName, AR_READ) != 0){
		printf("Unable to find source file '%S'\n", sourceName);
		exit(1);
		}
	name = stripExtension(targetName);
	u = new csourceUnit_s[ hash(name), sourceName ];
	BuildUnit = u;
	CurrentContext->obj = u;

	parser = new sourceParserC[ u, sourceName ];
	CurrentContext->phase = PH_INTERFACE;
	u reconnectInterfaces();
	u constructInterfaces();
	switch	(targetType){
	case	TT_COMPILE:
		u constructValues();
		u saveLibrary(targetName);
		break;

	case	TT_ASSEMBLE:
		u constructValues();
		break;
		}
	}

	// Build styles

compile:	(s: [:] char) =
	{
	targetName = s;
	targetType = TT_COMPILE;
	}

assemble:	(s: [:] char) =
	{
	targetName = s;
	targetType = TT_ASSEMBLE;
	}

	// Options setting

debugging:	() =
	{
	debugInfo = TRUE;
	}

sourceFilename:	(s: [:] char) =
	{
	sourceName = s;
	}

setOptimize:	(b: boolean) =
	{
	optimize = b;
	}

	};

csourceUnit_s:	type	inherit	sourceUnit_s {
	public:

addDeclarationC:	(n: ref identifier, off: fileOffset,
				hasError: boolean, d: ref declaration_p,
				dt: ref type_s) ref symbol_s =
	{
	sym:	ref symbol_s;
	nsym:	ref symbol_s;

	sym = symbol_s createC(self, n, off, hasError, d, dt);
	if	(symbols == 0)
		symbols = sym;
	else	{
		for	(nsym = symbols; nsym->next; nsym = nsym->next)
			;
		nsym->next = sym;
		}
	return sym;
	}

	};


SC_ERROR:	const	storageClasses = SC_BASED;	// not used in C
SC_NONE:	const	storageClasses = SC_PARM;	// not used in C (in
							// this phase)

declaratorContext:	type	byte = {
	DC_EXTERN,
	DC_MEMBER,
	DC_FUNCTION,
	DC_PROTOTYPE
	};

sourceParserC:	public	type	inherit	tokenStream {
	Curctx:			ref cntxt;
	Curswitch:		ref switchCases;
	DefaultCase:		ref label_x;
	StatementList:		ref stmt_x;
	ConstFlag:		boolean;
	VolatileFlag:		boolean;
	StorageClassSpecifier:	storageClasses;
	SpecifiedType:		ref type_s;
	CurrentScope:		ref scope_s;

	public:

constructor:	(u: ref unit_s, fname: [:] char) =
	{
	pu:		ref unit_p;

	super constructor(fname);
	if	(isNew()){
		CurrentContext clear();
		errorContext errorX("ErrOpen", fname, "", 0);
		}
	pu = unit_p create(u->name, self);
	openRange([ 0, BUF_SEEK_END ]);
	CurrentUnit = pu;
	initC();
	compilerMessages = new CompilerMessages[ fname, self ];
	CurrentContext->obj = compilerMessages;
	CurrentScope = u;
	parse();
	}

parse:	() =
	{
	BuildMachine = 0;
	for	(;;){
		scan();
		CurrentContext->offset = Token.offset;
		switch	(Token.lex){
		case	EOF_TOK:
			return;

			// This is here purely for proper resynchronization
			// of bad input

		case	RC:
			errorContext error("ErrDeclarationSyntax");
			break;

			// This is here as an extension that allows for
			// extra semi-colons

		case	SM:
			break;

		default:
			parseExternalDeclaration();
			}
		}
	}

parseExternalDeclaration:	() =
	{
	parseTypeClassSpecifiers();
	parseDeclaratorList(DC_EXTERN);
	}

parseDeclaratorList:	(dc: declaratorContext) =
	{
	for	(;;){
		di:	ref declaratorItem;
		t:	ref type_s;
		id:	ref identifier;
		he:	boolean;
		d:	declaration_p;
		off:	fileOffset;
		sym:	ref symbol_s;

		di = parseDeclarator(0);
		if	(di == 0)
			return;
		if	(SpecifiedType == 0){
			if	(!ConstFlag &&
				 !VolatileFlag &&
				 StorageClassSpecifier == SC_NONE &&
				 (di->topType == T_VOID ||
				  di->topType == T_NAME))
				errorContext error("ErrTypeNeeded");
			t = IntType;
			}
		else
			t = SpecifiedType;
		id = di declaredName(&off);
		if	(id == 0){
			errorContext error("ErrNameNeeded");
			t = ErrorType;
			off = 0;
			}
		if	(t->topType != T_ERROR){
			xdi:	ref declaratorItem;

			he = FALSE;
			for	(xdi = di; xdi; xdi = xdi->next){
				t = xdi unwind(t);
				if	(t->topType == T_ERROR)
					he = TRUE;
				}
			delete di;
			}
		else
			he = TRUE;
		switch	(StorageClassSpecifier){
		case	SC_NONE:
			switch	(dc){
			case	DC_EXTERN:
				d.storageClass = SC_STATIC;
				d.visibility = V_PUBLIC;
				break;

			case	DC_MEMBER:
				d.storageClass = SC_MEMBER;
				d.visibility = V_PUBLIC;
				break;

			case	DC_FUNCTION:
				d.storageClass = SC_AUTO;
				d.visibility = V_PRIVATE;
				break;

			case	DC_PROTOTYPE:
				d.storageClass = SC_PARM;
				d.visibility = V_PRIVATE;
				}
			break;

		case	SC_ERROR:
			he = TRUE;
			d.storageClass = SC_STATIC;
			d.visibility = V_PRIVATE;
			break;

		case	SC_STATIC:
			if	(dc != DC_EXTERN &&
				 dc != DC_FUNCTION){
				errorContext error("ErrBadStorageClass");
				he = TRUE;
				}
			d.storageClass = SC_STATIC;
			d.visibility = V_PRIVATE;
			break;

		case	SC_AUTO:
			if	(dc != DC_FUNCTION){
				errorContext error("ErrBadStorageClass");
				he = TRUE;
				}
			d.storageClass = SC_AUTO;
			d.visibility = V_PRIVATE;
			break;

		case	SC_EXTERN:
			if	(dc != DC_EXTERN &&
				 dc != DC_FUNCTION){
				errorContext error("ErrBadStorageClass");
				he = TRUE;
				}
			d.storageClass = SC_EXTERN;
			d.visibility = V_PUBLIC;
			break;

		case	SC_REGISTER:
			if	(dc != DC_FUNCTION &&
				 dc != DC_PROTOTYPE){
				errorContext error("ErrBadStorageClass");
				he = TRUE;
				}
			if	(dc == DC_PROTOTYPE)
				d.storageClass = SC_PARM;
			else
				d.storageClass = SC_AUTO;
			d.visibility = V_PRIVATE;
			break;
			}
		d.qualifier = 0;
		if	(ConstFlag)
			d.qualifier |= DQ_CONST;
		if	(VolatileFlag)
			d.qualifier |= DQ_VOLATILE;
		d.location = 0;
		d.initializer = NO_RANGE;
		d.initBase = 0;
		sym = BuildUnit addDeclarationC(id, off, he, &d, t);
		if	(Token.lex == SM)
			break;
		else if	(Token.lex == CM)
			scan();
		else if	(Token.lex == LC){	// ANSI function definition
						// or parameterless old style
			parseFunctionBody(sym);
			break;
			}
		else if	(Token.lex == ASG){	// initializer
			}
		else	{			// check for old-style function
						// definition
			}
		}
	}

parseDeclarator:	(di: ref declaratorItem) ref declaratorItem =
	{
	while	(Token.lex == MUL){
		di = new ptrDeclaratorItem[ di, T_REF, 0 ];
		scan();
		}		
	switch	(Token.lex){
	case	LP:
		if	(scan() == RP)
			di = new declaratorItem[ di, T_VOID ];
		else	{
			di = parseDeclarator(di);
			if	(Token.lex != RP){
				delete di;
				resync("ErrDeclarationSyntax");
				return 0;
				}
			}
		break;

	case	ID:
		di = new nameDeclaratorItem[ di, T_NAME, 
						Token.iden, Token.offset ];
		break;

	default:
		if	(di == 0)
			di = new declaratorItem[ di, T_VOID ];
		return di;
		}
	for	(;;){
		switch	(scan()){
		case	LP:
			while	(scan() != RP && Token.lex != EOF_TOK)
				;
			di = new funcDeclaratorItem[ di, T_FUNC, TRUE, 
							FC_NORMAL, 0 ];
			break;

		case	LB:
			while	(scan() != RB && Token.lex != EOF_TOK)
				;
			di = new arrayDeclaratorItem[ di, T_ARRAY, 0 ];
			break;

		default:
			return di;
			}
		}
	}

isTypeClassSpecifier:	(t: tokenNames) boolean =
	{
	switch	(t){
	case	CHAR:
	case	SHORT:
	case	INT:
	case	LONG:
	case	FLOAT:
	case	DOUBLE:
	case	SIGNED:
	case	UNSIGNED:
	case	STRUCT:
	case	UNION:
	case	ENUM:
	case	VOID:

	case	EXTERN:
	case	STATIC:
	case	AUTO:
	case	REGISTER:

	case	CONST:
	case	VOLATILE:
		return TRUE;

	case	ID:		// support typedefs later
		return FALSE;

	default:
		return FALSE;
		}
	}

parseTypeClassSpecifiers:	() =
	{
	typeSpecifier, signedNess:	tokenNames;
	longFlag, shortFlag:		boolean;

	StorageClassSpecifier = SC_NONE;
	typeSpecifier = signedNess = 0;
	ConstFlag = VolatileFlag = longFlag = shortFlag = FALSE;
	for	(;;){
		CurrentContext->offset = Token.offset;
		switch	(Token.lex){
		case	CHAR:
		case	INT:
		case	FLOAT:
		case	DOUBLE:
		case	STRUCT:
		case	UNION:
		case	ENUM:
		case	VOID:
			if	(typeSpecifier &&
				 typeSpecifier != ERROR){
				errorContext error("ErrTooManyTypes");
				typeSpecifier = ERROR;
				}
			else
				typeSpecifier = Token.lex;
			break;

		case	SHORT:
			if	(shortFlag || longFlag){
				if	(typeSpecifier != ERROR)
					errorContext error("ErrTooManyTypes");
				typeSpecifier = ERROR;
				}
			else
				shortFlag = TRUE;
			break;

		case	LONG:
			if	(shortFlag || longFlag){
				if	(typeSpecifier != ERROR)
					errorContext error("ErrTooManyTypes");
				typeSpecifier = ERROR;
				}
			else
				longFlag = TRUE;
			break;

		case	SIGNED:
		case	UNSIGNED:
			if	(signedNess){
				if	(typeSpecifier != ERROR)
					errorContext error("ErrTooManyTypes");
				typeSpecifier = ERROR;
				}
			signedNess = Token.lex;
			break;

		case	EXTERN:
		case	STATIC:
		case	AUTO:
		case	REGISTER:
			if	(StorageClassSpecifier != SC_NONE &&
				 StorageClassSpecifier != SC_ERROR){
				errorContext error("ErrTooManyClasses");
				StorageClassSpecifier = SC_ERROR;
				}
			else	{
				switch	(Token.lex){
				case	EXTERN:
					StorageClassSpecifier = SC_EXTERN;
					break;

				case	AUTO:
					StorageClassSpecifier = SC_AUTO;
					break;

				case	STATIC:
					StorageClassSpecifier = SC_STATIC;
					break;

				case	REGISTER:
					StorageClassSpecifier = SC_REGISTER;
					}
				}
			break;

		case	CONST:
			if	(ConstFlag){
				errorContext error("ErrTooManyConsts");
				typeSpecifier = ERROR;
				}
			else
				ConstFlag = TRUE;
			break;

		case	VOLATILE:
			if	(VolatileFlag){
				errorContext error("ErrTooManyVolatiles");
				typeSpecifier = ERROR;
				}
			else
				VolatileFlag = TRUE;
			break;

		case	ID:		// support typedefs later
		default:
			switch	(typeSpecifier){
			case	ERROR:
				SpecifiedType = ErrorType;
				break;

			case	VOID:
				SpecifiedType = VoidType;
				break;

			case	CHAR:
				if	(shortFlag || longFlag){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else	{
					if	(signedNess == UNSIGNED)
						SpecifiedType = UcharType;
					else if	(signedNess == SIGNED)
						SpecifiedType = ScharType;
					else
						SpecifiedType = CharType;
					}
				break;

			case	INT:
				if	(shortFlag && longFlag){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else if	(shortFlag){
					if	(signedNess == UNSIGNED)
						SpecifiedType = UshortType;
					else
						SpecifiedType = ShortType;
					}
				else if	(longFlag){
					if	(signedNess == UNSIGNED)
						SpecifiedType = UlongType;
					else
						SpecifiedType = LongType;
					}
				else	{
					if	(signedNess == UNSIGNED)
						SpecifiedType = UintType;
					else
						SpecifiedType = IntType;
					}
				break;

			case	FLOAT:
				if	(shortFlag || longFlag || signedNess){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else
					SpecifiedType = FloatType;
				break;

			case	DOUBLE:
				if	(shortFlag || signedNess){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else if	(longFlag)
					SpecifiedType = LongDoubleType;
				else
					SpecifiedType = DoubleType;
				break;

			case	STRUCT:
				if	(shortFlag || longFlag || signedNess){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else
					SpecifiedType = IntType;
				break;

			case	UNION:
				if	(shortFlag || longFlag || signedNess){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else
					SpecifiedType = IntType;
				break;

			case	ENUM:
				if	(shortFlag || longFlag || signedNess){
					errorContext error("ErrTooManyTypes");
					SpecifiedType = ErrorType;
					}
				else
					SpecifiedType = IntType;
				break;

			default:
				SpecifiedType = 0;
				}
			return;
			}
		scan();
		}
	}

parseFunctionBody:	(sym: ref symbol_s) =
	{
	x:	ref stmt_x;
	ft:	ref function_z;

	clearLoops();
	Curctx = 0;
	sc: blockScope = [ sym->enclosing, sym ];
	ft = ref function_z(sym->dtype);
	Func startFunction(&sc, ft, sym);
	sc defineParameters(ft->parameters, sym->qualifier);
	x = parseBlock();
	if	(x == 0)
		return;
	x assignTypes(&sc, FALSE);
	Func generateCode(sym, x, &sc);
	}

parseWholeExpression:	(r: textRange) ref tree_p =
	{
	openRange(r);
	scan();
	return parseExpression(0, 0, 0, XC_NORMAL);
	}

private:

parseIdList:	(s: ref scope_p, d: ref declaration_p) boolean =
	{
	for	(;;){
		CurrentContext->offset = Token.offset;
		if	(s == 0 ||
			 !s isDuplicated(Token.iden))
			d addName(Token.iden, Token.offset);
		scan();
		if	(Token.lex == CO)
			return TRUE;
		else if	(Token.lex == CM &&
			 scan() == ID)
			continue;
		else	{
			resync("ErrDeclarationSyntax");
			return FALSE;
			}
		}
	}

parseDeclaratorX:	(d: ref declaration_p, context: parseContexts) = 
	{
	switch	(scan()){
	case	PUBLIC:
		if	(context == PX_FUNCTION)
			errorContext error("ErrPublic");
		d->visibility = V_PUBLIC;
		break;

	case	VISIBLE:
		if	(context != PX_MEMBER)
			errorContext errorX("ErrStructOnly", "visible", "", 0);
		d->visibility = V_VISIBLE;
		break;

	case	PRIVATE:
		if	(context != PX_MEMBER)
			errorContext errorX("ErrStructOnly", "private", "", 0);
		d->visibility = V_PRIVATE;
		break;

	default:
		unscan();
		}
	d->qualifier = parseQualifiers();
	if	(context != PX_MEMBER &&
		 d->qualifier & DQ_DYNAMIC)
		errorContext errorX("ErrStructOnly", "dynamic", "", 0);
	switch	(scan()){
	case	ENTRY:
		if	(context != PX_FILE)
			errorContext errorX("ErrMisplacedToken", "entry", "", 0);
		else
			d->qualifier |= DQ_ENTRY;
		break;

	case	CLEANUP:
		if	(context != PX_FILE)
			errorContext errorX("ErrMisplacedToken", "cleanup", "", 0);
		else
			d->qualifier |= DQ_CLEANUP;
		break;

	case	EXTERN:
		if	(context != PX_FILE)
			errorContext errorX("ErrMisplacedToken", "extern", "", 0);
		else
			d->storageClass = SC_EXTERN;
		break;

	case	REMOTE:
		if	(context != PX_MEMBER)
			errorContext errorX("ErrMisplacedToken", "remote", "", 0);
		else
			d->storageClass = SC_REMOTE;
		break;

	case	FACTORY:
		if	(context != PX_MEMBER)
			errorContext errorX("ErrMisplacedToken", "factory", "", 0);
		else	{
			d->storageClass = SC_STATIC;
			d->qualifier |= DQ_FACTORY|DQ_MEMBERFUNC;
			}
		break;

	case	STATIC:
		d->storageClass = SC_STATIC;
		break;

	case	TYPE:
		d->storageClass = SC_TYPE;
		break;

	case	REGISTER:
		if	(context != PX_FILE)
			errorContext error("ErrRegister");
		d->storageClass = SC_REGISTER;
		break;

	default:
		unscan();
		}
	if	(scan() == DOT){
		if	(scan() != ID){
			resync("ErrDeclarationSyntax");
			return;
			}
		d->location = Token.iden;
		}
	else
		unscan();
	d->dtype = parseType();
	if	(d->dtype == 0)
		return;

	b:	balancedDescriptor;

		// Functions inside structures have static storage class
		// by default

	if	(d->dtype->topType == T_FUNC &&
		 d->storageClass == SC_MEMBER){
		d->storageClass = SC_STATIC;
		d->qualifier |= DQ_MEMBERFUNC;
		}
	if	(scan() == ASG){
		if	(d->idList &&
			 d->idList->next != 0){
			resync("ErrInitDisallowed");
			d flagError();
			return;
			}
		switch	(d->storageClass){
		case	SC_TYPE:
			parseEnumeration(d);
			break;

		case	SC_REGISTER:
			if	(scan() != MAGIC ||
				 scan() != SM){
				resync("ErrDeclarationSyntax");
				d flagError();
				return;
				}
			d->initBase = Token.icon;
			break;

		case	SC_AUTO:
			d->initializer.start = tell();
			unscan();
			balanced(XC_NORMAL, &b);
			d->initializer.end = b.source.end;
			d->dtype commaCount(b.commaCount);
			if	(Token.lex != SM)
				resync("ErrDeclarationSyntax");
			break;

		case	SC_REMOTE:
			d->initializer.start = tell();
			balanced(XC_NORMAL, &b);
			if	(b.singleConstant){
				d->initializer.start = 0;
				d->initBase = b.value;
				}
			else
				d->initializer.end = b.source.end;
			if	(Token.lex != SM)
				resync("ErrDeclarationSyntax");
			break;

		default:
			d->initializer.start = tell();
			if	(scan() == MAGIC){
				d->storageClass = SC_INTRINSIC;
				d->initializer.start = 0;
				d->initBase = Token.icon;
				if	(scan() != SM)
					resync("ErrDeclarationSyntax");
				}
			else if	(Token.lex == LC){
				unscan();
				balanced(XC_NORMAL, &b);
				d->initializer.end = b.source.end;
				}
			else	{
				unscan();
				balanced(XC_NORMAL, &b);
				if	(b.singleConstant){
					d->initializer.start = 0;
					d->initBase = b.value;
					}
				else
					d->initializer.end = b.source.end;
				d->dtype commaCount(b.commaCount);
				if	(Token.lex != SM)
					resync("ErrDeclarationSyntax");
				}
			}
		}
	else if	(Token.lex != SM){
		resync("ErrDeclarationSyntax");
		return;
		}
	else	{
		if	(d->dtype->topType == T_FUNC){
			if	(context == PX_FUNCTION){
				errorContext errorX("ErrMisplacedToken", 
					"function definition", "", 0);
				return;
				}	
			}
//		if	(d->qualifier & DQ_DYNAMIC == 0)
//			error(ErrDefinitionNeeded, ???);
		}
/*
	d:		* type_p;
	sym:		* symbol;
	symOffset:	addr_t;
	i:		int;


	if	(d->dtype->topType == LP){
		if	(d->storageClass != SC_INTRINSIC &&
			 d->storageClass != SC_REMOTE){
			if	(s2 == 0){
				error(ErrDefinitionNeeded, 
						&d->idList->name->spelling);
				return;
				}
			if	(d->storageClass == SC_DYNAMIC)
				flags |= SY_DYNAMIC;
			d->storageClass = SC_STATIC;
			if	(context == PX_MEMBER)
				flags |= SY_MFUNC;
			}
		}
	else	{
		if	(d->qualifier & DQ_DYNAMIC){
			error(ErrDynamicNotFunc);
			d->qualifier &= ~DQ_DYNAMIC;
			}
		}
 */
	}

parseQualifiers:	() dQualifiers =
	{
	q:	dQualifiers;

	q = 0;
	for	(;;){
		switch	(scan()){
		case	CONST:
			if	(q & DQ_CONST)
				errorContext errorX("ErrMisplacedToken", 
						"const", "", 0);
			q |= DQ_CONST;
			break;

		case	VOLATILE:
			if	(q & DQ_VOLATILE)
				errorContext errorX("ErrMisplacedToken", 
						"volatile", "", 0);
			q |= DQ_VOLATILE;
			break;

		case	DYNAMIC:
			if	(q & DQ_DYNAMIC)
				errorContext errorX("ErrMisplacedToken", 
						"dynamic", "", 0);
			q |= DQ_DYNAMIC;
			break;

		case	FAR:
			if	(q & DQ_FAR)
				errorContext errorX("ErrMisplacedToken", 
						"far", "", 0);
			q |= DQ_FAR;
			break;

		default:
			unscan();
			return q;
			}
		}
	}

parseEnumeration:	(d: ref declaration_p) =
	{
	source:		textRange;
	x:		int;
	v:		visibilities;
	locv:		visibilities;
	id:		ref identifier;
	b:		balancedDescriptor;
	dt:		ref type_p;

	if	(scan() != LC){
		resync("ErrDeclarationSyntax");
		return;
		}
	b.source = NO_RANGE;
	x = 0;
	v = d->visibility;
	if	(d->idList)
		dt = namedType_p create(d->idList->name, d->idList->offset);
	else
		dt = 0;
	while	(scan() != RC && Token.lex != 0){
		if	(Token.lex == PUBLIC){
			locv = V_PUBLIC;
			scan();
			if	(Token.lex == CO){
				v = V_PUBLIC;
				scan();
				}
			}
		else if	(Token.lex == PRIVATE){
			locv = V_PRIVATE;
			scan();
			if	(Token.lex == CO){
				v = V_PRIVATE;
				scan();
				}
			}
		else
			locv = v;
		if	(Token.lex != ID)
			break;
		id = Token.iden;

		offset:	int;

		offset = Token.offset;
		scan();
		if	(Token.lex == ASG){
			b.source.start = tell();
			balanced(XC_ENUM, &b);
			if	(b.singleConstant){
				x = b.value;
				b.source = NO_RANGE;
				}
			else
				x = 0;
			}

		sym:	ref declaration_p;

		sym = declaration_p create(offset, locv, SC_STATIC);
		CurrentUnit addDecl(sym);
		CurrentContext->offset = offset;
		if	(!CurrentUnit isDuplicated(id))
			sym addName(id, offset);
		sym->dtype = dt;
		sym->qualifier = DQ_CONST;
		sym->initializer = b.source;
		sym->initBase = x;
		x++;
		if	(Token.lex != CM)
			break;
		}
	if	(Token.lex != RC){
		resync("ErrEnumerationSyntax");
		return;
		}
	scan();
	if	(Token.lex != SM)
		resync("ErrEnumerationSyntax");
	}

/*
	FUNCTION:	parseType()

	DESCRIPTION:

		This function parses a type-specifier.

	OUTPUTS:

		The resulting type is returned.  A return value of 0 indicates
		some sort of parsing error.

		The next token scanned will be the first token of the type.
		The scan point is left with
		Token.lex containing the last token of the type-specifier.
 */
parseType:	() ref type_p =
	{
	callingConvention:	fConventions;
	packflag:		packingMethods;
	d:			ref type_p;
	b:			balancedDescriptor;
	offs:			fileOffset;
	id:			ref identifier;

	CurrentContext->offset = Token.offset;
	packflag = PM_STRUCT;
	callingConvention = FC_NORMAL;
	switch	(scan()){
	case	INHERIT:
		d = parseType();
		if	(d == 0)
			return 0;
		if	(scan() == PACKED){
			packflag = PM_PACKED;
			scan();
			}
		if	(Token.lex != LC){
			resync("ErrSubtypeSyntax");
			return 0;
			}
		return parseStructure(d, packflag);

	case	PACKED:
		packflag = PM_PACKED;
		if	(scan() != LC){
			resync("ErrDeclarationSyntax");
			return 0;
			}

	case	LC:
		return parseStructure(0, packflag);

	case	UNION:
		if	(scan() != LC){
			resync("ErrDeclarationSyntax");
			return 0;
			}
		return parseStructure(0, PM_UNION);

	case	ID:
		id = Token.iden;
		offs = Token.offset;
		if	(scan() == QUAL){
			if	(scan() != ID){
				resync("ErrDeclarationSyntax");
				return 0;
				}
			return namedType_p create(Token.iden, Token.offset);
			}
		else	{
			unscan();
			return namedType_p create(id, offs);
			}

	case	SIGNED:
	case	UNSIGNED:
	case	FLOAT:
		sv:	int;
		tt:	topTypes;

		b.source = NO_RANGE;
		if	(Token.lex == FLOAT){
			sv = FLOATBITS;
			tt = T_FLOAT;
			}
		else	{
			sv = INTBITS;
			if	(Token.lex == SIGNED)
				tt = T_SIGNED;
			else
				tt = T_UNSIGNED;
			}
		if	(scan() == LB){
			b.source.start = tell();
			balanced(XC_NORMAL, &b);
			if	(b.singleConstant){
				b.source = NO_RANGE;
				sv = b.value;
				}
			if	(Token.lex != RB){
				resync("ErrArraySyntax");
				return 0;
				}
			}
		else
			unscan();
		return numberType_p create(tt, b.source, sv);

	case	REF:
	case	MUL:
		pToken:	boolean;
		q:	dQualifiers;

		pToken = Token.lex == MUL;
		q = parseQualifiers();
		d = parseType();
		if	(d == 0)
			return 0;
		return ptrType_p create(pToken, d, q);

	case	POINTER:
		q = parseQualifiers();
		d = voidType_p create();
		return ptrType_p create(REF, d, q);

	case	INLINE:
	case	GATE:
	case	INTERRUPT:
		if	(Token.lex == GATE){
			callingConvention = FC_GATE;
			if	(scan() != NOT)
				unscan();
			}
		else if	(Token.lex == INLINE)
			callingConvention = FC_INLINE;
		else	{
			if	(scan() != NOT){
				unscan();
				callingConvention = FC_INTERRUPT;
				}
			else
				callingConvention = FC_INTERRUPT2;
			}
		if	(scan() != LP){
			resync("ErrDeclarationSyntax");
			return 0;
			}

	case	LP:
		func:	ref functionType_p;

		func = functionType_p create(callingConvention);
		if	(!parseFunctionParameters(func))
			return 0;
		scan();				// Look ahead to next token
		unscan();			// but don't read it.
		if	(isTypeToken(Token.lex)){
			d = parseType();
			if	(d == 0)
				return 0;
			if	(d->topType == T_FUNC){	// function
				badtype();
				break;
				}
			}
		else
			d = voidType_p create();
		func->returnType = d;
		return func;

	case	LB:
		vArray:		topTypes;

		b.source.start = tell();
		b.value = 0;
		if	(scan() == CO){
			scan();
			vArray = T_DESCRIPTOR;
			}
		else
			vArray = T_ARRAY;
		if	(Token.lex != RB){
			unscan();
			balanced(XC_NORMAL, &b);
			if	(b.singleConstant)
				b.source = NO_RANGE;
			if	(Token.lex != RB){
				resync("ErrArraySyntax");
				return 0;
				}
			}
		else
			b.source = NO_RANGE;
		d = parseType();
		if	(d == 0)
			return 0;
		if	(d->topType == T_FUNC)		// function
			badtype();
		return arrayType_p create(vArray, b.source, b.value, d);

	default:
		resync("ErrDeclarationSyntax");
		return 0;
		}
	}

parseStructure:	(par: ref type_p, packflag: packingMethods) ref type_p =
	{
	ds:	ref structType_p;
	v:	visibilities;

	ds = structType_p create(par, packflag);
	v = V_PRIVATE;
	while	(scan() != RC && Token.lex != 0){
		if	(Token.lex == PUBLIC){
			v = V_PUBLIC;
			if	(scan() != CO){
				resync("ErrDeclarationSyntax");
				continue;
				}
			scan();
			}
		else if	(Token.lex == PRIVATE){
			v = V_PRIVATE;
			if	(scan() != CO){
				resync("ErrDeclarationSyntax");
				continue;
				}
			scan();
			}
		else if	(Token.lex == VISIBLE){
			v = V_VISIBLE;
			if	(scan() != CO){
				resync("ErrDeclarationSyntax");
				continue;
				}
			scan();
			}

		d:	ref declaration_p;

		d = declaration_p create(Token.offset, v, SC_MEMBER);
		ds addDecl(d);
		if	(Token.lex == ID){
			scan();
			if	(Token.lex == CO ||
				 Token.lex == CM){
				unscan();
				parseMember(ds, d);
				}
			else if	(Token.lex == QUAL)
				resync("ErrUnfinished");
			else if	(Token.lex == SM)
				d->dtype = namedType_p create(Token.iden, 
								Token.offset);
			else
				resync("ErrDeclarationSyntax");
			}
		else	{
			unscan();
			d->dtype = parseType();
			if	(d->dtype == 0)
				continue;
			if	(scan() != SM)
				resync("ErrDeclarationSyntax");
			}
		}
	return ds;
	}

parseMember:	(ds: ref structType_p, d: ref declaration_p) =
	{
	if	(parseIdList(ds, d))
		parseDeclaratorX(d, DC_MEMBER);
	}

parseFunctionParameters:	(func: ref functionType_p) boolean =
	{
	p:		ref parameter_p;
	id:		ref identifier;
	d:		ref type_p;
	i:		int;

       	if	(scan() == RP)
		return TRUE;
	p = 0;
	for	(;;){
		if	(Token.lex == ELLIPSIS){
			scan();
			func->fixedCalls = FALSE;
			break;
			}
		if	(Token.lex == ID){
			id = Token.iden;
			i = Token.offset;
			if	(scan() == QUAL){
				resync("ErrUnfinished");
				return FALSE;
				}
			if	(Token.lex != CO){
				unscan();
				d = namedType_p create(id, i);
				id = 0;
				}
			else
				d = parseType();
			}
		else	{
			id = 0;
			i = 0;
			unscan();
			d = parseType();
			}
		if	(d == 0)
			return FALSE;
		p = parameter_p create(p, id, i, d);
		if	(scan() != CM)
			break;
		scan();
		}
	if	(Token.lex == RP){
		func->parameters = p;
		return TRUE;
		}
	resync("ErrDeclarationSyntax");
	return FALSE;
	}

badtype:	() =
	{
	errorContext error("ErrBadType");
	}

balancedDescriptor:	type	{
	public:

	source:		textRange;
	commaCount:	int;
	singleConstant:	boolean;
	value:		long;
	};

balanced:	(context: expressionContexts, 
			b: ref balancedDescriptor) =
	{
	t:	int;

	setScanMode(FALSE);
	b->singleConstant = FALSE;
	for	(t = 0;; t++){
		switch	(scan()){
		case	CM:
			if	(context == XC_ENUM){
				if	(t != 1)
					b->singleConstant = FALSE;
				b->source.end = Token.offset;
				setScanMode(TRUE);
				return;
				}
			break;

		case	CO:
			if	(context == XC_QUESCO){
				if	(t != 1)
					b->singleConstant = FALSE;
				b->source.end = Token.offset;
				setScanMode(TRUE);
				return;
				}
			break;

		case	LC:
			parenthetical(RC);

		case	EOF_TOK:
		case	SM:
		case	RP:
		case	RB:
		case	RC:
			if	(t != 1)
				b->singleConstant = FALSE;
			b->source.end = tell();
			setScanMode(TRUE);
			return;

		case	LP:
			parenthetical(RP);
			break;

		case	LB:
			cc:	int;

			cc = parenthetical(RB);
			if	(t == 0)
				b->commaCount = cc;
			break;

		case	STRING:
			if	(t == 0){
				b->commaCount = Token.stringLength;
				while	(scan() == STRING)
					b->commaCount += Token.stringLength;
				unscan();
				}
			break;

		case	ICON:
			b->singleConstant = TRUE;
			b->value = Token.icon;
			}
		}
	}

parenthetical:	(terminator: tokenNames) int =
	{
	cc:	int;

	for	(cc = 0;;){
		switch	(scan()){
		case	EOF_TOK:
			return cc;

		case	LP:
			parenthetical(RP);
			break;

		case	CM:

				/*
					Since an extra comma can appear 
					before a right bracket, it should
					not be counted.
				 */

			if	(terminator == RB){
				if	(scan() == RB)
					return cc;
				unscan();
				}
			cc++;
			break;

		case	LB:
			parenthetical(RB);
			break;

		case	LC:
			parenthetical(RC);
			break;

		case	RC:
			if	(terminator != RC)
				unscan();
			return cc;

		default:
			if	(Token.lex == terminator)
				return cc;
			}
		}
	}

isTypeToken:	(tok: tokenNames) boolean =
	{
	switch	(tok){
	case	LP:
	case	LB:
	case	LC:
	case	MUL:
	case	REF:
	case	UNION:
	case	INHERIT:
	case	PACKED:
	case	UNSIGNED:
	case	SIGNED:
	case	FLOAT:
	case	POINTER:
	case	ID:
		return TRUE;
		}
	return FALSE;
	}

parseBlock:	() ref stmt_x =
	{
	x:	ref stmt_x;
	y:	ref stmt_x;

	x = StatementList;
	StatementList = 0;
	while	(scan() != RC && Token.lex != 0){
		if	(isTypeClassSpecifier(Token.lex)){
			parseTypeClassSpecifiers();
			parseDeclaratorList(DC_FUNCTION);
			}
		else	{
			unscan();
			parseStatement();
			}
		}
	if	(Token.lex != RC)
		errorContext error("ErrBlockMissingRC");
	y = Func block(StatementList);
	StatementList = x;
	return y;
	}

post:	(x: ref stmt_x) =
	{
	if	(x == 0)
		return;
	if	(StatementList == 0)
		StatementList = x;
	else	{
		y:	ref stmt_x;

		y = StatementList->prev;
		y->next = x;
		x->prev = y;
		}
	while	(x->next)
		x = x->next;
	StatementList->prev = x;
	}

parseStatement:	() =
	{
	saveDefault:		ref tree_p;
	p:			ref stmt_x;
	q:			ref tree_p;
	stest:			ref tree_p;
	sincr:			ref tree_p;
	stmt:			ref char;
	lastCase:		ref switchCases;
	saveCases:		ref switchCases;
	sc:			ref switchCases;
	t:			ref tree_p;
	s:			ref tree_p;
	x:			ref tree_p;
	r:			int;
	li:			int;
	i:			int;
	cxp:			ref cntxt;
	offset:			fileOffset;
	start_offset:		fileOffset;
	end_offset:		fileOffset;
	iden:			ref identifier;

	for	(;;){
		iden = 0;
		scan();
		CurrentContext->offset = Token.offset;
		offset = Token.offset;
		saveCases = Curswitch;
		saveDefault = DefaultCase;
		switch	(Token.lex){
		case	CASE:
			scan();
			t = parseExpression(0, 0, 0, XC_QUESCO);
			if	(t == 0){
				post(Func errorStmt(offset));
				return;
				}
			else if	(Token.lex != CO)
				errorContext error("ErrCaseSyntax");
			else if	(Curctx == 0 ||
				 (Curctx->x_statement != SWITCH &&
				  Curctx->x_statement != EXCEPT))
				errorContext errorX("ErrMisplacedToken", 
						"case", "", 0);
			else	{
				p:	ref label_x;

				p = Func label_();
				sc = alloc(sizeof switchCases);
				sc->next = Curswitch;
				Curswitch = sc;
				sc->target = p;
				sc->caseValue = t;
				sc->offset = offset;
				post(p);
				}
			break;

		case	DEFAULT:
			if	(scan() != CO){
				errorContext error("ErrDefaultSyntax");
				unscan();
				}
			else if	(Curctx == 0 ||
				 (Curctx->x_statement != SWITCH &&
				  Curctx->x_statement != EXCEPT))
				errorContext errorX("ErrMisplacedToken", 
							"default", "", 0);
			else if	(DefaultCase)
				errorContext error("ErrDuplicateDefault");
			else	{
				DefaultCase = Func label_();
				post(DefaultCase);
				}
			break;

		case	LABEL:
			if	(scan() != ID){
				resync("ErrGotoLabel");
				post(Func errorStmt(Token.offset));
				return;
				}
			post(Func namedLabel(Token.iden, Token.offset));
			if	(scan() != CO){
				errorContext error("ErrLabelSyntax");
				unscan();
				}
			break;

		case	SM:
			return;

		case	RC:
			unscan();

		case	EOF_TOK:
			errorContext error("ErrStmtMissingSM");
			post(Func errorStmt(offset));
			return;

		case	ELSE:
			errorContext errorX("ErrMisplacedToken", "else", "", 0);
			post(Func errorStmt(offset));
			break;

		case	TRY:	parseTry();		return;
		case	IF:	parseIf();		return;
		case	FOR:	parseFor();		return;
		case	DO:	parseDo();		return;
		case	WHILE:	parseWhile();		return;
		case	SWITCH:	parseSwitch();		return;
		case	RETURN:	parseReturn();		return;
		case	CRITICAL:parseCritical();	return;

		case	BREAK:
			if	(scan() != SM){
				resyncX("ErrMissingSM", "Break", "", 0);
				post(Func errorStmt(Token.offset));
				}
			else if	(Curctx == 0 ||
				 Curctx->x_brk == 0){
				errorContext errorX("ErrMisplacedToken", 
							"break", "", 0);
				post(Func errorStmt(offset));
				}
			else	{
				if	(Curctx->x_statement == TRY)
					post(Func endTry(Curctx->x_try));
				post(Func jump(Curctx->x_brk, 
						[ offset, Token.offset ]));
				}
			return;

		case	CONTINUE:
			if	(scan() != SM){
				resyncX("ErrMissingSM", "Continue", "", 0);
				post(Func errorStmt(Token.offset));
				}
			else if	(Curctx == 0 ||
				 Curctx->x_cont == 0){
				errorContext errorX("ErrMisplacedToken", 
							"continue", "", 0);
				post(Func errorStmt(offset));
				}
			else
				post(Func jump(Curctx->x_cont, 
						[ offset, Token.offset ]));
			return;

		case	REPLY:
			if	(scan() != SM){
				t = parseExpression(0, 0, 0, XC_NORMAL);
				if	(t == 0)
					t = Func error();
				else if	(Token.lex != SM){
					resyncX("ErrMissingSM", "Reply", "", 0);
					t = Func error();
					}
				}
			else
				t = 0;
			post(Func reply_(t, [ offset, Token.offset ]));
			return;

		case	FORWARD:
			scan();
			t = parseExpression(0, 0, 0, XC_NORMAL);
			if	(t == 0)
				p = Func errorStmt(offset);
			else if	(Token.lex != SM){
				resyncX("ErrMissingSM", "Forward", "", 0);
				p = Func errorStmt(Token.offset);
				}
//			else
//				stmtForward(t, offset);
			post(p);
			return;

		case	ASSERT:
			scan();
			t = parseExpression(0, 0, 0, XC_NORMAL);
			if	(t == 0)
				p = Func errorStmt(offset);
			else if	(Token.lex != SM){
				resyncX("ErrMissingSM", "Assert", "", 0);
				p = Func errorStmt(Token.offset);
				}
			else
				p = Func assert_(t, [ offset, Token.offset ]);
			post(p);
			return;

		case	LC:
			post(parseBlock());
			return;

		case	GOTO:
			if	(scan() != ID){
				resync("ErrGotoLabel");
				post(Func errorStmt(Token.offset));
				return;
				}

				// Check for any ill effects of try clauses

			for	(cxp = Curctx; cxp; cxp = cxp->x_next){
				if	(cxp->x_statement == TRY ||
					 cxp->x_statement == EXCEPT)
					errorContext warnX("ErrMisplacedToken", 
						"goto inside try", "", 0);
				}
			if	(scan() != SM){
				resyncX("ErrMissingSM", "Goto", "", 0);
				p = Func errorStmt(Token.offset);
				}
			else
				p = Func goto_(Token.iden, 
						[ offset, Token.offset ]);
			post(p);
			return;

		case	ID:
			offset = Token.offset;
			iden = Token.iden;
			if	(scan() == CO ||
				 Token.lex == CM){
				d:	ref declaration_p;

				d = declaration_p create(offset, V_PRIVATE, 
								SC_AUTO);

					/*
					   This code fakes out the scanner.
					   The identifier pointer is not
					   touched by a comma or semicolon
					   token, but the offset is, so it
					   must be reset.
					 */

				unscan();
				Token.offset = offset;
				if	(parseIdList(0, d))
					parseDeclaratorX(d, DC_FUNCTION);
				post(Func decl(d, [ offset, Token.offset ]));
				return;
				}

		default:
			t = parseExpression(0, iden, offset, XC_NORMAL);
			if	(t == 0)
				t = Func error();
			else if	(Token.lex != SM){
				resync("ErrStmtMissingSM");
				t = Func error();
				}
			post(Func expr(t, [ offset, Token.offset ]));
			return;
			}
		}
	}

parseTry:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	t:			ref tree_p;
	exceptClause:		ref label_x;
	nextDefault:		ref label_x;
	mergePoint:		ref label_x;
	exceptBody:		ref label_x;
	nextCases:		ref switchCases;

	exceptClause = Func label_();
	ctx.x_try = Func try_(exceptClause);
	post(ctx.x_try);
	ctx.x_next = Curctx;
	ctx.x_statement = TRY;
	ctx.x_brk = Func label_();
	if	(Curctx)
		ctx.x_cont = Curctx->x_cont;
	else
		ctx.x_cont = 0;
	mergePoint = Func label_();
	Curctx = &ctx;
	parseStatement();
	Curctx = ctx.x_next;
	post(ctx.x_brk);
	post(Func endTry(ctx.x_try));
	post(Func jump(mergePoint, NO_RANGE));
	post(exceptClause);

		/* except clauses are optional.  The following are
		   equivalent:

			try A;
			except ;

			try A;
		 */
	if	(scan() != EXCEPT){
		unscan();
		post(Func exceptClause(ctx.x_try, 0, NO_RANGE));
		post(Func endExcept(ctx.x_try));
		post(mergePoint);
		return;
		}
	if	(scan() == LP){
		scan();
		offset = Token.offset;
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0){
			post(Func errorStmt(offset));
			return;
			}
		if	(Token.lex != RP){
			resyncX("ErrMissingRP", "Try", "", 0);
			post(Func errorStmt(Token.offset));
			return;
			}
		}
	else	{
		unscan();
		t = 0;
		}

	xx:	ref except_x;
	jj:	ref jump_x;

	xx = Func exceptClause(ctx.x_try, t, [ offset, Token.offset ]);
	post(xx);
	jj = Func jump(0, NO_RANGE);
	post(jj);
	ctx.x_brk = Func label_();
	ctx.x_cont = Func label_();
	exceptBody = Func label_();
	post(ctx.x_cont);
	post(Func continueExcept());
	post(exceptBody);
	ctx.x_statement = EXCEPT;
	nextCases = Curswitch;
	nextDefault = DefaultCase;
	DefaultCase = 0;
	Curswitch = 0;
	Curctx = &ctx;
	parseStatement();
	if	(DefaultCase)
		jj->target = DefaultCase;
	else if	(Curswitch)
		jj->target = ctx.x_cont;
	else
		jj->target = exceptBody;
	Curctx = ctx.x_next;
	xx table(Curswitch);
	Curswitch = nextCases;
	DefaultCase = nextDefault;
	post(ctx.x_brk);
	post(Func endExcept(ctx.x_try));
	post(mergePoint);
	}

parseIf:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	p:			ref label_x;
	q:			ref label_x;
	s:			ref tree_p;
	t:			ref tree_p;
	stest:			ref tree_p;
	sincr:			ref tree_p;
	start_offset:		fileOffset;
	end_offset:		fileOffset;

	if	(scan() != LP){
		resyncX("ErrMissingLP", "If", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	scan();
	p = Func label_();
	offset = Token.offset;
	t = parseExpression(0, 0, 0, XC_NORMAL);
	if	(t == 0){
		post(Func errorStmt(offset));
		return;
		}
	else if	(Token.lex != RP){
		resyncX("ErrMissingRP", "If", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	post(Func testFalse(t, p, [ offset, Token.offset ]));
	parseStatement();
	offset = Token.offset;
	if	(scan() == ELSE){
		q = Func label_();
		post(Func jump(q, [ offset, 0 ]));
		post(p);
		parseStatement();
		post(q);
		}
	else	{
		unscan();
		post(p);
		}
	}

parseCritical:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	p:			ref label_x;
	q:			ref critical_x;
	s:			ref tree_p;
	t:			ref tree_p;
	stest:			ref tree_p;
	sincr:			ref tree_p;
	range:			textRange;
	start_offset:		fileOffset;
	end_offset:		fileOffset;

	if	(scan() == LP){
		scan();
		offset = Token.offset;
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0){
			post(Func errorStmt(offset));
			return;
			}
		else if	(Token.lex != RP){
			resyncX("ErrMissingRP", "Critical", "", 0);
			post(Func errorStmt(Token.offset));
			return;
			}
		range = [ offset, Token.offset ];
		}
	else	{
		unscan();
		t = 0;
		range = [ 0, 0 ];
		}
	ctx.x_next = Curctx;
	ctx.x_brk = Func label_();
	ctx.x_try = 0;
	ctx.x_cont = 0;
	ctx.x_statement = CRITICAL;
	ctx.x_critical = Func criticalRegion(t, range);
	post(ctx.x_critical);
	Curctx = &ctx;
	parseStatement();
	Curctx = ctx.x_next;
	offset = Token.offset;
	post(ctx.x_brk);
	post(Func endCritical(ctx.x_critical));
	}

parseFor:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	p:			ref label_x;
	q:			ref label_x;
	s:			ref tree_p;
	t:			ref tree_p;
	stest:			ref stmt_x;
	sincr:			ref stmt_x;
	start_offset:		fileOffset;
	end_offset:		fileOffset;

	ctx.x_next = Curctx;
	ctx.x_brk = Func label_();
	ctx.x_try = 0;
	ctx.x_cont = Func label_();
	ctx.x_statement = FOR;
	q = Func label_();
	if	(scan() != LP){
		resyncX("ErrMissingLP", "For", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	if	(scan() != SM){
		offset = Token.offset;
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			t = Func error();
		post(Func expr(t, [ offset, Token.offset ]));
		offset = Token.offset;
		if	(Token.lex != SM){
			resyncX("ErrMissingSM", "For", "", 0);
			post(Func errorStmt(Token.offset));
			return;
			}
		}
	enterLoop();
	if	(scan() != SM){
		start_offset = Token.offset;
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			t = Func error();
		if	(Token.lex != SM){
			resyncX("ErrMissingSM", "For", "", 0);
			post(Func errorStmt(Token.offset));
			return;
			}
		end_offset = Token.offset;
		stest = Func test(t, q, [ start_offset, end_offset ]);
		}
	else
		stest = 0;
	if	(scan() != RP){
		offset = Token.offset;
		s = parseExpression(0, 0, 0, XC_NORMAL);
		if	(s == 0)
			s = Func error();
		if	(Token.lex != RP){
			resyncX("ErrMissingRP", "For", "", 0);
			post(Func errorStmt(Token.offset));
			return;
			}
		sincr = Func expr(s, [ offset, Token.offset ]);
		}
	else
		sincr = 0;
	if	(stest){
		p = Func label_();
		post(Func jump(p, NO_RANGE));
		}
	post(q);
	Curctx = &ctx;
	parseStatement();
	exitLoop();
	Curctx = ctx.x_next;
	post(ctx.x_cont);
	if	(sincr)
		post(sincr);
	if	(stest){
		post(p);
		post(stest);
		}
	else
		post(Func jump(q, NO_RANGE));
	post(ctx.x_brk);
	}

parseDo:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	p:			ref label_x;
	t:			ref tree_p;

	ctx.x_next = Curctx;
	ctx.x_try = 0;
	ctx.x_statement = DO;
	ctx.x_cont = Func label_();
	ctx.x_brk = Func label_();
	p = Func label_();
	post(p);
	Curctx = &ctx;
	enterLoop();
	parseStatement();
	Curctx = ctx.x_next;
	if	(scan() != WHILE){
		resync("ErrMissingWhile");
		post(Func errorStmt(Token.offset));
		return;
		}
	if	(scan() != LP){
		resyncX("ErrMissingLP", "Do-while", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	scan();
	offset = Token.offset;
	post(ctx.x_cont);
	t = parseExpression(0, 0, 0, XC_NORMAL);
	if	(t == 0)
		post(Func errorStmt(offset));
	else
		post(Func test(t, p, [ offset, Token.offset ]));
	exitLoop();
	post(ctx.x_brk);
	if	(Token.lex != RP){
		resyncX("ErrMissingRP", "Do-while", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	if	(scan() != SM){
		resyncX("ErrMissingSM", "Do-while", "", 0);
		post(Func errorStmt(Token.offset));
		}
	}

parseWhile:	() =
	{
	offset:	fileOffset;
	ctx:	cntxt;
	t:	ref tree_p;
	p:	ref label_x;
	stest:	ref stmt_x;

	if	(scan() != LP){
		resyncX("ErrMissingLP", "While", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	ctx.x_next = Curctx;
	ctx.x_try = 0;
	ctx.x_statement = WHILE;
	ctx.x_cont = Func label_();
	ctx.x_brk = Func label_();
	scan();
	offset = Token.offset;
	t = parseExpression(0, 0, 0, XC_NORMAL);
	if	(t == 0)
		t = Func error();
	else if	(Token.lex != RP){
		resyncX("ErrMissingRP", "While", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	post(Func jump(ctx.x_cont, [0, 0]));
	p = Func label_();
	post(p);
	enterLoop();
	stest = Func test(t, p, [ offset, Token.offset ]);
	Curctx = &ctx;
	parseStatement();
	exitLoop();
	Curctx = ctx.x_next;
	post(ctx.x_cont);
	post(stest);
	post(ctx.x_brk);
	}

parseSwitch:	() =
	{
	offset:			fileOffset;
	ctx:			cntxt;
	p:			ref tree_p;
	q:			ref tree_p;
	s:			ref tree_p;
	t:			ref tree_p;
	nextDefault:		ref label_x;
	nextCases:		ref switchCases;

	if	(scan() != LP){
		resyncX("ErrMissingLP", "Switch", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	scan();
	offset = Token.offset;
	t = parseExpression(0, 0, 0, XC_NORMAL);
	if	(t == 0){
		post(Func errorStmt(offset));
		return;
		}

	sw:	ref switch_x;

	sw = Func switch_(t, [ offset, Token.offset ]);
	post(sw);
	if	(Token.lex != RP){
		resyncX("ErrMissingRP", "Switch", "", 0);
		post(Func errorStmt(Token.offset));
		return;
		}
	ctx.x_brk = Func label_();
	if	(Curctx)
		ctx.x_cont = Curctx->x_cont;
	else
		ctx.x_cont = 0;
	ctx.x_next = Curctx;
	ctx.x_try = 0;
	ctx.x_statement = SWITCH;
	nextCases = Curswitch;
	nextDefault = DefaultCase;
	DefaultCase = 0;
	Curswitch = 0;
	Curctx = &ctx;
	parseStatement();
	if	(DefaultCase == 0){
		DefaultCase = Func label_();
		post(DefaultCase);
		}
	sw table(DefaultCase, Curswitch);
	Curswitch = nextCases;
	DefaultCase = nextDefault;
	Curctx = ctx.x_next;
	post(ctx.x_brk);
	}

parseReturn:	() =
	{
	t:			ref tree_p;
	cxp:			ref cntxt;
	offset:			fileOffset;

	offset = Token.offset;
	if	(scan() != SM){
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			t = Func error();
		else if	(Token.lex != SM){
			resyncX("ErrMissingSM", "Return", "", 0);
			t = Func error();
			}
		}
	else
		t = 0;

		// Undo any ill effects of try clauses

	for	(cxp = Curctx; cxp; cxp = cxp->x_next){
		if	(cxp->x_statement == TRY)
			post(Func endTry(cxp->x_try));
		else if	(cxp->x_statement == CRITICAL)
			post(Func endCritical(cxp->x_critical));
		}
	post(Func return_(t, [ offset, Token.offset ]));
	}

parseExpression:	(lastPrecedence: int, iden: ref identifier, 
						offset: fileOffset,
						context: int) ref tree_p =
	{
	t:		ref tree_p;
	s:		ref tree_p;
	u:		ref tree_p;
	assoc:		int;
	opos:		int;
	op:		int;
	newPrecedence:	int;

//	printf("parseExpression line %d SP = %x\n", tellLine(tell()), _ESP);
	if	(iden)
		t = parseSuffix(iden, offset);
	else
		t = parseUnary();
	if	(t == 0)
		return 0;
	assoc = Assoc[lastPrecedence];
	for	(;;){
		if	(context == XC_ENUM &&
			 Token.lex == CM)
			break;
		if	(context == XC_QUESCO &&
			 Token.lex == CO)
			break;
		newPrecedence = cprecedence(Token.lex);
		if	(newPrecedence == 0)
			break;
		op = binaryOperator(Token.lex);
		offset = Token.offset;
		if	(lastPrecedence > newPrecedence)
			break;
		if	(lastPrecedence == newPrecedence &&
			 assoc == LEFT)
			break;
		if	(op == O_QUES){
			scan();
			s = parseExpression(0, 0, 0, XC_QUESCO);
			if	(s == 0)
				return(0);
			if	(Token.lex != CO){
				CurrentContext->offset = Token.offset;
				resync("ErrExpressionSyntax");
				return 0;
				}
			scan();
			u = parseExpression(cprecedence(QUES), 0, 0, context);
			if	(u == 0)
				return 0;
			t = Func conditional(t, s, u, offset);
			continue;
			}
		scan();
		s = parseExpression(newPrecedence, 0, 0, context);
		if	(s == 0)
			return 0;
		if	(op == O_SEQ &&
			 context == XC_CALL)
			t = Func argument(t, s, offset);
		else
			t = Func binary(op, t, s, offset);
		}
	return t;	
	}

parseUnary:	() ref tree_p =
	{
	t:		ref tree_p;
	s:		ref tree_p;
	d:		ref type_p;
	offset:		fileOffset;

	offset = Token.offset;
	switch	(Token.lex){
	case	MUL:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_IND, t, 0, offset);
		break;

	case	AND:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_ADR, t, 0, offset);
		break;

	case	OR:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_BOUND, t, 0, offset);
		break;

	case	LOR:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_MBOUND, t, 0, offset);
		break;

	case	SUB:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_NEG, t, 0, offset);
		break;

	case	ADD:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_PLUS, t, 0, offset);
		break;

	case	NOT:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_NOT, t, 0, offset);
		break;

	case	COM:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_COM, t, 0, offset);
		break;

	case	INC:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		s = Func icon(1L, -INTBITS);
		t = Func binary(O_ADA, t, s, offset);
		break;

	case	DEC:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		s = Func icon(1L, -INTBITS);
		t = Func binary(O_SBA, t, s, offset);
		break;

	case	SIZEOF:
		scan();
		if	(Token.lex == REF ||
			 Token.lex == FLOAT ||
			 Token.lex == POINTER ||
			 Token.lex == SIGNED ||
			 Token.lex == UNSIGNED){
			unscan();
			d = parseType();
			if	(d == 0)
				return 0;
			scan();
			t = Func sizeof_(d);
			}
		else	{
			t = parseUnary();
			if	(t == 0)
				return 0;
			t = Func binary(O_SIZEOF, t, 0, offset);
			}
		break;

	case	OFFSETOF:
		d = parseType();
		if	(d == 0)
			return 0;
		scan();
		if	(Token.lex != DOT){
			CurrentContext->offset = Token.offset;
			resync("ErrOffsetofSyntax");
			return 0;
			}
		if	(scan() != ID){
			CurrentContext->offset = Token.offset;
			resync("ErrOffsetofSyntax");
			return 0;
			}
		t = Func offsetof_(d, Token.iden);
		scan();
		break;

	case	TYPEOF:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_TYPEOF, t, 0, offset);
		break;

	case	SEND:
		scan();
		t = parseUnary();
		if	(t == 0)
			return 0;
		t = Func binary(O_SEND, t, 0, offset);
		break;

	default:
		t = parseSuffix(0, 0);
		}
	return t;
	}

parseSuffix:	(iden: ref identifier, offset: fileOffset) ref tree_p =
	{
	t:		ref tree_p;
	s:		ref tree_p;
	r:		ref tree_p;
	d:		ref type_p;
	isSlice:	boolean;
	i:		int;

	if	(iden == 0)
		t = parsePrimary();
	else	{
		t = checkIdentifier(iden, offset);
		}
	for	(;;){
		CurrentContext->offset = Token.offset;
		switch	(Token.lex){
		case	INC:
			t = Func binary(O_INA, t, 0, Token.offset);
			break;

		case	DEC:
			t = Func binary(O_DEA, t, 0, Token.offset);
			break;

		case	LB:
			offset = Token.offset;
			r = 0;
			s = 0;
			isSlice = FALSE;
			if	(scan() == CO){
				isSlice = TRUE;
				scan();
				}
			if	(Token.lex != RB){
				s = parseExpression(0, 0, 0, XC_CALL);
				if	(s == 0)
					return 0;
				if	(!isSlice &&
					 Token.lex == CO){
					r = s;
					s = 0;
					isSlice = TRUE;
					scan();
					if	(Token.lex != RB){
						s = parseExpression(0, 0, 0, XC_CALL);
						if	(s == 0)
							return 0;
						}
					}
				if	(Token.lex != RB){
					CurrentContext->offset = Token.offset;
					resync("ErrSubscriptSyntax");
					return 0;
					}
				}
			if	(isSlice)
				t = Func slice(t, r, s, offset);
			else
				t = Func binary(O_SUBSCRIPT, t, s, offset);
			break;
 
		case	ID:
			iden = Token.iden;
			offset = Token.offset;
			if	(scan() != NOT)
				unscan();
			if	(scan() != LP){
				CurrentContext->offset = Token.offset;
				resync("ErrMCallSyntax");
				return 0;
				}
			if	(scan() == RP)
				s = 0;
			else	{
				s = parseExpression(0, 0, 0, XC_CALL);
				if	(s == 0)
					return 0;
				if	(Token.lex != RP){
					CurrentContext->offset = Token.offset;
					resync("ErrCallSyntax");
					return 0;
					}
				}
			t = Func methodCall(t, iden, s, offset, FALSE);
			break;

		case	LP:
			offset = Token.offset;
			if	(scan() == RP)
				s = 0;
			else	{
				s = parseExpression(0, 0, 0, XC_CALL);
				if	(s == 0)
					return 0;
				if	(Token.lex != RP){
					CurrentContext->offset = Token.offset;
					resync("ErrCallSyntax");
					return 0;
					}
				}
			t = Func staticCall(t, s, offset);
			break;

		case	DOT:
			if	(scan() != ID){
				resync("ErrDotSyntax");
				return 0;
				}
			t = Func reference(O_DOT, t, Token.iden, Token.offset);
			break;

		case	ARROW:
			if	(scan() != ID){
				resync("ErrArrowSyntax");
				return 0;
				}
			t = Func reference(O_ARROW, t, Token.iden, Token.offset);
			break;

		case	NEW:
			t = parseNewExpression(t);
			break;

		default:
			return t;
			}
		scan();
		}
	}

checkIdentifier:	(iden: ref identifier, offset: fileOffset) ref tree_p =
	{
	t:		ref tree_p;
	sym:		ref symbol_s;

	if	(CurrentScope){
		sym = CurrentScope lookup(iden, CurrentScope);
		if	(sym == 0){
			d:	declaration_p;
			t:	ref type_s;

			errorContext warnX("WarnUndeclaredFunc", 
						iden spelling(), "", 0);
			d.offset = offset;
			d.idList = 0;
			d.visibility = V_PUBLIC;
			d.storageClass = SC_EXTERN;
			d.qualifier = 0;
			d.location = 0;
			d.initializer = [ 0, 0 ];
			d.initBase = 0;
			t = function_z create(IntType, FALSE, FC_NORMAL, 0);
			BuildUnit addDeclarationC(iden, offset, FALSE, &d, t);
			}
		}
//	if	(Token.lex == QUAL){
//		if	(scan() != ID){
//			resync(ErrExpressionSyntax);
//			return 0;
//			}
//		t = Func iden(iden, offset, Token.iden, Token.offset);
//		scan();
//		}
//	else
		t = Func iden(0, 0, iden, offset);
	return t;
	}

parsePrimary:	() ref tree_p =
	{
	t:		ref tree_p;
	s:		ref tree_p;
	d:		ref type_p;
	offset:		fileOffset;
	id:		ref identifier;

	switch	(Token.lex){
	case	ID:
		t = checkIdentifier(Token.iden, Token.offset);
		break;

	case	ICON:
		t = Func icon(Token.icon, Token.constType);
		scan();
		break;

	case	FCON:
		t = Func fcon(&Token.fcon, Token.constType);
		scan();
		break;

	case	ELLIPSIS:
		t = Func ellipsis();
		scan();
		break;

	case	SELF:
		t = Func self_(O_SELF, Token.offset);
		scan();
		break;

	case	SUPER:
		t = Func self_(O_SUPER, Token.offset);
		scan();
		break;

	case	STRING:
		lt:	ref literal_x;

		lt = Func literal();
		do
			lt addStringItem(Token.stringValue, 
							Token.stringLength);
			while	(scan() == STRING);
		t = lt;
		break;

	case	LB:		// A structure constant
		offset = Token.offset;
		if	(scan() == RB)
			s = 0;
		else	{
			s = parseStrConst();
			if	(s == 0)
				return 0;
			if	(Token.lex != RB){
				CurrentContext->offset = Token.offset;
				resync("ErrStrConstSyntax");
				return 0;
				}
			}
		t = Func sconst(s, offset);
		scan();
		break;

	case	LP:
		scan();
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			return 0;
		if	(Token.lex != RP){
			CurrentContext->offset = Token.offset;
			resync("ErrExpressionSyntax");
			return 0;
			}
		scan();
		break;

	case	NEW:
		t = parseNewExpression(0);
		scan();
		break;

	case	SIGNED:
	case	UNSIGNED:
	case	FLOAT:
	case	POINTER:
	case	REF:
		offset = Token.offset;
		unscan();
		d = parseType();
		if	(d == 0)
			return 0;
		if	(scan() != LP){
			CurrentContext->offset = Token.offset;
			resync("ErrExpressionSyntax");
			return 0;
			}
		scan();
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			return 0;
		if	(Token.lex != RP){
			CurrentContext->offset = Token.offset;
			resync("ErrExpressionSyntax");
			return 0;
			}
		scan();
		t = Func cast(d, t, offset);
		break;
/*
	case	ARRAY:
		offset = Token.offset;
		d = parseType();
		if	(d == 0)
			return 0;
		if	(scan() != LP || isarray(d->topType)){
			CurrentContext.offset = Token.offset;
			resync(ErrExpressionSyntax);
			return 0;
			}
		scan();
		t = parseExpression(0, 0, 0, XC_NORMAL);
		if	(t == 0)
			return 0;
		if	(Token.lex != RP){
			CurrentContext.offset = Token.offset;
			resync(ErrExpressionSyntax);
			return 0;
			}
		scan();
		t = Func cast(d, t, offset);
		break;
 */
	default:
		CurrentContext->offset = Token.offset;
		resync("ErrExpressionSyntax");
		return 0;
		}
	return t;
	}

parseNewExpression:	(heapArg: ref tree_p) ref tree_p =
	{
	t:		ref tree_p;
	s:		ref tree_p;
	d:		ref type_p;
	offset:		fileOffset;

	offset = Token.offset;
	d = parseType();
	if	(d == 0)
		return 0;

	s = 0;
	if	(scan() == LB){
		if	(scan() != RB){
			s = parseStrConst();
			if	(s == 0)
				return 0;
			if	(Token.lex != RB){
				CurrentContext->offset = Token.offset;
				resync("ErrStrConstSyntax");
				return 0;
				}
			s = Func sconst(s, offset);
			}
		}
	else
		unscan();
	return Func new_(heapArg, d, s, offset);
	}

parseStrConst:	() ref tree_p =
	{
	s:	ref tree_p;
	list:	ref tree_p;
	list2:	ref tree_p;

	s = parseExpression(0, 0, 0, XC_ENUM);
	if	(s == 0)
		return 0;
	if	(Token.lex == RB)
		return s;
	if	(Token.lex != CM){
		CurrentContext->offset = Token.offset;
		resync("ErrStrConstSyntax");
		return 0;
		}
	scan();
	if	(Token.lex == RB)
		return s;
	list = s;
	for	(;;){
		s = parseExpression(0, 0, 0, XC_ENUM);
		if	(s == 0)
			return 0;
		list = Func argument(list, s, Token.offset);
		if	(Token.lex == CM){
			scan();
			if	(Token.lex == RB)
				break;
			}
		else if	(Token.lex == RB)
			break;
		else	{
			CurrentContext->offset = Token.offset;
			resync("ErrStrConstSyntax");
			return 0;
			}
		}

		/* Rearrange the list from a left-associative chain to
		   a right-associative one.
		 */

	return list makeRightAssociative();
	}

	};

parseContexts:	type	char = {
	PX_FILE,
	PX_FUNCTION,
	PX_MEMBER
	};

expressionContexts:	type	int = {
	XC_NORMAL,
	XC_CALL,
	XC_ENUM,
	XC_QUESCO
	};

cntxt:	public	type	{
	public:
	x_next:		ref cntxt;
	x_brk:		ref label_x;
	x_cont:		ref label_x;
	x_try:		ref try_x;
	x_critical:	ref critical_x;
	x_statement:	char;
        };

LEFT:	const	char = 1;
RIGHT:	const	char = 2;

Assoc:	const [] char = [
	0,
	RIGHT,					/* cm */
	RIGHT,					/* asgop */
	RIGHT,					/* ques */
	RIGHT,					/* - unused - */
	LEFT,					/* lor */
	LEFT,					/* land */
	LEFT,					/* eq ne */
	LEFT,					/* relop */
	LEFT,					/* or */
	LEFT,					/* xor */
	LEFT,					/* and */
	LEFT,					/* add sub */
	LEFT,					/* shift op */
	LEFT					/* mul div mod */
	];

compilerMessages:	ref CompilerMessages;

CompilerMessages:	type inherit	messageGenerator {
	fname:		[:] char;
	srcParser:	ref sourceParserC;

	public:

constructor:	(fn: [:] char, sp: ref sourceParserC) =
	{
	fname = fn;
	srcParser = sp;
	}

objectName:	dynamic	() [:] char =
	{
	return fname;
	}

lineno:	dynamic	(f: fileOffset) int =
	{
	return srcParser tellLine(f);
	}

	};

cTypes:	entry	() =
	{
	CharType = number_z create(T_UNSIGNED, NO_RANGE, 	BYTEBITS);
	ScharType = number_z create(T_SIGNED, NO_RANGE, 	BYTEBITS);
	UcharType = number_z create(T_UNSIGNED, NO_RANGE, 	BYTEBITS);
	ShortType = number_z create(T_SIGNED, NO_RANGE, 	SHORTBITS);
	UshortType = number_z create(T_UNSIGNED, NO_RANGE, 	SHORTBITS);
	UintType = number_z create(T_UNSIGNED, NO_RANGE,	INTBITS);
	LongType = number_z create(T_SIGNED, NO_RANGE,		LONGBITS);
	UlongType = number_z create(T_UNSIGNED, NO_RANGE,	LONGBITS);
	FloatType = number_z create(T_FLOAT, NO_RANGE,		FLOATBITS);
	DoubleType = number_z create(T_FLOAT, NO_RANGE,		DOUBLEBITS);
	LongDoubleType = number_z create(T_FLOAT, NO_RANGE,	EXTENDBITS);
	VoidType = void_z create();
	}

CharType:	ref number_z;
ScharType:	ref number_z;
UcharType:	ref number_z;
ShortType:	ref number_z;
UshortType:	ref number_z;
UintType:	ref number_z;
LongType:	ref number_z;
UlongType:	ref number_z;
FloatType:	ref number_z;
DoubleType:	ref number_z;
LongDoubleType:	ref number_z;
VoidType:	ref void_z;

declaratorItem:	type	{
	public:

	next:		ref declaratorItem;
	topType:	topTypes;

display:	dynamic	() =
	{
	printf("%d ", topType);
	if	(next)
		next display();
	}

declaredName:	dynamic	(offp: ref fileOffset) ref identifier =
	{
	if	(next)
		return next declaredName(offp);
	else
		return 0;
	}

destructor:	() =
	{
	if	(next)
		delete next;
	}

unwind:	dynamic	(t: ref type_s) ref type_s =
	{
	return t;
	}

	};

nameDeclaratorItem:	type	inherit	declaratorItem {
	public:

	iden:		ref identifier;
	offset:		fileOffset;

display:	dynamic	() =
	{
	printf("%S ", iden spelling());
	super display();
	}

declaredName:	dynamic	(offp: ref fileOffset) ref identifier =
	{
	*offp = offset;
	return iden;
	}

	};

ptrDeclaratorItem:	type	inherit declaratorItem {
	public:

	qualifier:		dQualifiers;

unwind:	dynamic	(t: ref type_s) ref type_s =
	{
	return ptr_z create(FALSE, t, qualifier);
	}

	};

arrayDeclaratorItem:	type	inherit declaratorItem {
	public:

	dimension:		int;

unwind:	dynamic	(t: ref type_s) ref type_s =
	{
	return array_z create(NO_RANGE, dimension, t);
	}

	};

funcDeclaratorItem:	type	inherit	declaratorItem {
	public:

	fixedCalls:		boolean;
	callingConvention:	fConventions;
	parameters:		ref parameter_s;

unwind:	dynamic	(t: ref type_s) ref type_s =
	{
	return function_z create(t, fixedCalls, callingConvention, 
							parameters);
	}

	};


/*
	This function returns the precedence of the C operator token passed
	as an argument.  Note that if the token is not a binary operator,
	the function returns zero.  Precedences range from 1 through 14
	(varying from comma to multiply/divide/remainder).  A higher
	numerical value indicates a higher precedence.
 */
cprecedence:	(t: tokenNames) int =
	{
	if	(t >= CM &&
		 t <= IOARROW)
		return Cprec[t - CM];
	else
		return 0;
	}

Cprec:	const [] char = [
	1,					/* CM */
	2,					/* ASG */
	2,					/* ADA */
	2,					/* SBA */
	2,					/* MUA */
	2,					/* DVA */
	2,					/* MOA */
	2,					/* ANA */
	2,					/* ORA */
	2,					/* XRA */
	2,					/* LSA */
	2,					/* RSA */
	13,					/* ADD */
	13,					/* SUB */
	14,					/* MUL */
	14,					/* DIV */
	14,					/* MOD */
	9,					/* AND */
	7,					/* OR */
	8,					/* XOR */
	12,					/* LSH */
	12,					/* RSH */
	3,					/* QUES */
	5,					/* LOR */
	6,					/* LAND */
	10,					/* EQ */
	10,					/* NE */
	11,					/* LT */
	11,					/* GT */
	11,					/* LE */
	11,					/* GE */
	11,					/* UNORD */
	11,					/* LT_GT */
	11,					/* ORD */
	11,					/* NLE */
	11,					/* NLT */
	11,					/* NGE */
	11,					/* NGT */
	11,					/* NLT_GT */
	2,					/* IOARROW */
	];

