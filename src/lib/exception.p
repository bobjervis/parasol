/*
   Copyright 2015 Robert Jervis

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
/**
 * The exception namespace defines facilities for performing exception handling and
 * also a set of commonly thrown exceptions.
 *
 * Much of the code in this namespace is present there (and not public) to proide support to
 * throw and try-catch code generated by the compiler.
 *
 * THhe included exceptions are the common exceptions either thrown due to hardware exceptions or
 * common runtime library conditions.
 */
namespace parasol:exception;

import parasol:compiler.BuiltInType;
import parasol:compiler.FileStat;
import parasol:compiler.Type;
import parasol:x86_64.ExceptionEntry;
import parasol:memory;
import parasol:process;
import parasol:runtime;
import parasol:thread;
import native:windows;
import native:linux;
import native:C;
/**
 * This function throws an AssertionFailedException if the test is false.
 *
 * @exception AssertionFailedException when the test argument value is false.
 */
public void assert(boolean test) {
	if (!test)
		throw AssertionFailedException();
}

int EXCEPTION_ACCESS_VIOLATION	= int(0xc0000005);
int EXCEPTION_IN_PAGE_ERROR		= int(0xc0000006);
/**
 * This is the base class for all exceptions.
 *
 * An object must have a class that extends Exception to be used as an operand of a {@code throw}
 * statement.
 *
 * Note: Currently, a thrown exception caches an ExceptionContext object to hold the stack trace
 * of the exception. This memory is not re-claimed.
 * 
 * @threading It is not thread safe to throw the same exception object in two different threads
 * at the same time.
 */
public class Exception {
	protected ref<ExceptionContext> _exceptionContext;
	string _message;
	/**
	 * Constructs a new Exception with no message text.
	 */
	public Exception() {
		
	}
	/**
	 * Constructs a new Exception with message text.
	 *
	 * @param message The text of the message to be printed.
	 */
	public Exception(string message) {
		_message = message;
	}
	
	Exception(ref<ExceptionContext> exceptionContext) {
		_exceptionContext = exceptionContext;
	}
	
	ref<Exception> clone() {
		ref<Exception> n = new Exception(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
	/**
	 * Retrieves the value of the Exception message text, if any.
	 *
	 * @return If not null, the message text of the Exception.
	 */
	public string message() {
		return _message;
	}
	/**
	 * Write the contents of the {@link textStackTrace} return value
	 * to the process standard output.
	 */
	public void printStackTrace() {
		string s = textStackTrace();
		if (s == null)
			s = "Exception was never thrown, no stack trace.\n";
		process.stdout.write(s);
	}
	/**
	 * Compose a text stack trace.
	 *
	 * @return If the exception was thrown, then this returns the text stack trace. If the
	 * Exception has never been thrown, then it returns null.
	 */
	public string textStackTrace() {
		if (_exceptionContext == null)
			return null;
		string output;
		boolean locationIsExact = true;

		if (_exceptionContext.exceptionType == 0)
			locationIsExact = false;
//		printf("    failure address %p\n", _exceptionContext.exceptionAddress);
		address stackHigh = pointer<byte>(_exceptionContext.stackPointer) + _exceptionContext.stackSize;
		address ip = _exceptionContext.exceptionAddress;
		string tag = "->";
		int lowCode = int(runtime.lowCodeAddress());
		int staticMemoryLength = int(runtime.highCodeAddress()) - lowCode;
		int ignoreFrames = ignoreTopFrames();
		pointer<address> frame;
		int(address, address) comparator = comparatorCurrentIp;
		for (;;) {
			ref<ExceptionEntry> ee;
			address ip;
			(ee, frame, ip) = nextFrame(frame, false, comparator);
			if (frame == null)
				break;
			comparator = comparatorReturnAddress;

			int relative = int(ip) - lowCode;
			if (ignoreFrames > 0)
				ignoreFrames--;
			else {
				string locationLabel;
				if (relative >= staticMemoryLength || relative < 0)
					locationLabel = formattedExternalLocation(ip);
				else
					locationLabel = formattedLocation(ip, relative, locationIsExact);
				output.printf(" %2s %s\n", tag, locationLabel);
				tag = "";
			}
		}
		return output;
	}
	
	int ignoreTopFrames() {
		return 0;
	}
	
	void throwNow(address framePointer, address stackPointer) {
		
		// The default treatment is that the return address just under the stackPointer is the starting point for
		// 'throw' resolution. That will cover the cases where the exception context doesn't exist (this is a plain
		// 'throw' statement), or this is a re-thrown exception (in which case the lastCrawledFramePointer will not be
		// null). If there is an _exceptionContext set but no lastCrawledFramePointer, we are processing a hardware
		// exception for the first time.
		
		int(address, address) comparator = comparatorReturnAddress;
		pointer<address> frame;
		boolean useRealStack;
		if (_exceptionContext == null) {
			// An inital throw statement of an unthrown exception
			_exceptionContext = createExceptionContext(stackPointer);
			_exceptionContext.framePointer = framePointer;
			_exceptionContext.exceptionAddress = pointer<address>(stackPointer)[-1];
		} else if (_exceptionContext.lastCrawledFramePointer == null) {
			// first time handling of a hardware exception
			comparator = comparatorCurrentIp;
		} else { // else a re-thrown exception
			frame = pointer<address>(stackPointer) + -2;
			useRealStack = true;
		}
		for (;;) {
			ref<ExceptionEntry> ee;
			address ip;
			(ee, frame, ip) = nextFrame(frame, useRealStack, comparator);
			if (frame == null)
				break;
			comparator = comparatorReturnAddress;

			if (ee != null) {
				_exceptionContext.lastCrawledFramePointer = frame;
				callCatchHandler(this, frame, ee.handler);
				process.exit(1);
			}
		}
		printf("\nFATAL: Could not find a stack handler for this address.\n");
		_exceptionContext.print();
		printf(textStackTrace());
		process.exit(1);
	}

	private ref<ExceptionEntry>, pointer<address>, address nextFrame(pointer<address> lastFrame, boolean useRealStack, int comparator(address ip, address elem)) {
//		printf("nextFrame(%p, %s)\n", lastFrame, comparator == comparatorCurrentIp ? "current ip" : "return address");
		pointer<address> frame;
		pointer<byte> ip;

		pointer<byte> lowCode = runtime.lowCodeAddress();
		pointer<byte> highCode = runtime.highCodeAddress();
		pointer<ExceptionEntry> ee = pointer<ExceptionEntry>(exceptionsAddress());
		int count = exceptionsCount();
		if (count == 0) {
			printf("No exceptions table for this image.\n");
			process.exit(1);
		}

		if (lastFrame == null) {
			frame = pointer<address>(_exceptionContext.framePointer);
			ip = pointer<byte>(_exceptionContext.exceptionAddress);
			// The initial 'lastFrame' starting point (as if there was a saved RBP, IP pair there) would
			// be just below the stack pointer.
			lastFrame = pointer<address>(_exceptionContext.stackPointer) + -2;
		} else {
			if (useRealStack) {
				frame = pointer<address>(lastFrame[0]);
				ip = pointer<byte>(lastFrame[1]);
			} else {
				frame = pointer<address>(_exceptionContext.slot(lastFrame));
				ip = pointer<byte>(_exceptionContext.slot(lastFrame + 1));
			}
		}
		address stackTop = address(long(_exceptionContext.stackBase) + _exceptionContext.stackSize);
		pointer<address> searchEnd = pointer<address>(stackTop) + -2;
		int location = int(ip - lowCode);
//		printf("location %x %p ? %p ? %p\n", location, address(lastFrame + 2), frame, searchEnd);


		if (frame < lastFrame + 2 || frame >= searchEnd) {
			// For whatever reason, the frame we are trying to use as the next place to start looking
			// for a return address is no good, so guess by checking all possible values. As soon as we
			// see a stack slot containing a possible next 
			for (frame = lastFrame + 2; ; frame++) {
				if (frame >= searchEnd) {
					frame = null;
					break;
				}
				pointer<address> nextFrame;
				if (useRealStack)
					nextFrame = pointer<address>(*frame);
				else
					nextFrame = pointer<address>(_exceptionContext.slot(frame));
				if (nextFrame >= frame + 2 && nextFrame < searchEnd)
					break;
			}
		}

		if (ip >= lowCode && ip < highCode) {
			int location = int(ip - lowCode);
//			printf("%x Checking location %x", frame, location);
			address result = bsearch(&location, ee, count, ExceptionEntry.bytes, comparator);
//			printf(" -> found %p", result);
			if (result != null) {
				ref<ExceptionEntry> ee = ref<ExceptionEntry>(result);

//				printf("(handler %x)\n", ee.handler);

				// If we have a handler, call it.
				if (ee.handler != 0)
					return ee, frame, ip;
			} //else 
//				printf("\n");
		} //else
//			printf("frame with non-Parasol ip %x\n", frame);

		return null, frame, ip;
	} 
	/*
	 * findStack confirms whether there are any valid stack frames (ones with Parasol code from
	 * this image in them). Second, if it is valid, it counts how many frames there are so calling code
	 * can allocate storage for the stack walk.
	 * 
	 * 
	 * RETURNS:	-1 if this could not be confirmed to be a valid Parasol stack, or >= 1 for
	 * 			valid stacks (the number is the number of stack frames found).
	 */
	private int countStackFrames(pointer<address> frame) {
		pointer<address> oldRbp;
		pointer<ExceptionEntry> ee = pointer<ExceptionEntry>(exceptionsAddress());
		int count = exceptionsCount();
		if (count == 0) {
			printf("No exceptions table for this image.\n");
			process.exit(1);
		}
		pointer<byte> lowCode = runtime.lowCodeAddress();
		pointer<byte> highCode = runtime.highCodeAddress();
		int(address, address) comparator = comparatorCurrentIp;
		address stackTop = address(long(_exceptionContext.stackBase) + _exceptionContext.stackSize);
		pointer<address> plausibleEnd = pointer<address>(stackTop) + -2;
		int frames = 0;
		boolean confirmed;
		do {
			oldRbp = frame;
			pointer<byte> ip = pointer<byte>(frame[1]);
			if (ip >= lowCode && ip < highCode)
				confirmed = true;
			frame = pointer<address>(*frame);
			comparator = comparatorReturnAddress;
			frames++;
		} while (frame > oldRbp && frame < plausibleEnd);
		if (confirmed)
			return frames;
		else
			return -1;
	}
	
	ref<ExceptionContext> exceptionContext() {
		return _exceptionContext;
	}
}

private address bsearch(address key, address tableAddress, int tableSize, int rowSize, int comparator(address a, address b)) {
	pointer<byte> table = pointer<byte>(tableAddress);
	while (tableSize > 0) {
		int midIndex = tableSize / 2;
		pointer<byte> midPoint = table + midIndex * rowSize;
		int comp = comparator(key, midPoint);
		if (comp < 0)
			tableSize = midIndex;
		else if (comp > 0) {
			table = midPoint + rowSize;
			tableSize -= midIndex + 1; 
		} else
			return midPoint;
	}
	return null;
}

private int comparatorCurrentIp(address ip, address elem) {
	int location = *ref<int>(ip);
	pointer<ExceptionEntry> ee = pointer<ExceptionEntry>(elem);

	if (location < ee[0].location)
		return -1;
	else if (location < ee[1].location)
		return 0;
	else
		return 1;
}

private int comparatorReturnAddress(address ip, address elem) {
	int location = *ref<int>(ip);
	pointer<ExceptionEntry> ee = pointer<ExceptionEntry>(elem);

	if (location <= ee[0].location)
		return -1;
	else if (location <= ee[1].location)
		return 0;
	else
		return 1;
}
/**
 * This exception is thrown by array subscript operations that are out of bounds for the array.
 */
public class BoundsException extends Exception {
	public BoundsException() {
	}
	
	public BoundsException(string message) {
		super(message);
	}

	ref<BoundsException> clone() {
		ref<BoundsException> n = new BoundsException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}	
}
/**
 * This exception is thrown by a variety of runtime functions if an invalid argument value
 * is supplied.
 */
public class IllegalArgumentException extends Exception {
	public IllegalArgumentException() {
	}

	public IllegalArgumentException(string message) {
		super(message);
	}

	ref<IllegalArgumentException> clone() {
		ref<IllegalArgumentException> n = new IllegalArgumentException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
}
/**
 * This exception is thrown by a variety of runtime functions if an invalid call is mode.
 *
 * This is usually caused when a method on an object is called and the object is not in a valid
 * state for that method.
 */
public class IllegalOperationException extends Exception {
	public IllegalOperationException() {
	}

	public IllegalOperationException(string message) {
		super(message);
	}

	ref<IllegalOperationException> clone() {
		ref<IllegalOperationException> n = new IllegalOperationException(_message);
		n._exceptionContext = _exceptionContext;
		return n;
	}
}
/**
 * This exception is triggered by a SIGABRT signal and is generally a symptom of a
 * C runtime library failure. Most commonly, this is caused by corruption of the C memory heap.
 */
public class CRuntimeException extends RuntimeException {
	public CRuntimeException() {
		
	}

	CRuntimeException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<CRuntimeException> clone() {
		ref<CRuntimeException> n = new CRuntimeException();
		n._exceptionContext = _exceptionContext;
		return n;
	}	
}
/**
 * This is the base class for a group of (usually) hardware-detected exceptions.
 */
public class RuntimeException extends Exception {
	RuntimeException() {
	}
	
	RuntimeException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	public string message() {
		if (_exceptionContext == null)
			return "RuntimeException (not thrown)\n";
		string output;
		output.printf("RuntimeException: ");

		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
			pointer<byte> message = formatMessage(unsigned(_exceptionContext.exceptionType));

			string text(message);
			output.printf("%x", _exceptionContext.exceptionType);
			if (message != null) {
				if (text.endsWith("\r\n"))
					text = text.substring(0, text.length() - 2);
				output.printf(" (%s)", text);
			}
			output.printf(" ip %p", _exceptionContext.exceptionAddress);
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX)
			output.printf("%x", _exceptionContext.exceptionType);
		return output;
	}
	
	ref<RuntimeException> clone() {
		ref<RuntimeException> n = new RuntimeException(_exceptionContext);
		return n;
	}	

}

@Linux("libparasol.so.1", "formatMessage")
@Windows("parasol.dll", "formatMessage")
abstract pointer<byte> formatMessage(unsigned ntstatus);
/**
 * This exception is thrown by an integeer divide by zero. Note that a floating point
 * divide by zero will return a value of infinity and will not throw this exception.
 */
public class DivideByZeroException extends RuntimeException {
	DivideByZeroException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}

	ref<DivideByZeroException> clone() {
		ref<DivideByZeroException> n = new DivideByZeroException(_exceptionContext);
		return n;
	}	

}
/**
 * This exception is thrown when the machine executes an illegal instruction. The immediate causes can
 * be quite varied, but traces back to a bad pointer or ref value being used somewhere. 
 */
public class IllegalInstructionException extends RuntimeException {
	IllegalInstructionException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}

	ref<IllegalInstructionException> clone() {
		ref<IllegalInstructionException> n = new IllegalInstructionException(_exceptionContext);
		return n;
	}	

	public string message() {
		if (_exceptionContext == null)
			return "IllegalInstructionException (not thrown)\n";
		return "IllegalInstructionException";
	}
	
}
/**
 * This exception is raised by a call to assert with a false value.
 */
public class AssertionFailedException extends RuntimeException {
	AssertionFailedException() {
	}

	ref<AssertionFailedException> clone() {
		ref<AssertionFailedException> n = new AssertionFailedException();
		n._exceptionContext = _exceptionContext;
		return n;
	}	

	public string message() {
		if (_exceptionContext == null)
			return "AssertionFailedException (not thrown)\n";
		return "Assertion failed";
	}
	
	int ignoreTopFrames() {
		return 1;
	}
}
/**
 * This exception is returned when the Parasol memory allocation code detects a corrupted heap
 * data structure.
 */
public class CorruptHeapException extends RuntimeException {
	CorruptHeapException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<CorruptHeapException> clone() {
		ref<CorruptHeapException> a = new CorruptHeapException(_exceptionContext);
		return a;
	}
}
/**
 * This exception is generated in response to a stack overflow on some operating systems, such as Windows.
 * Linux systems do not give the failing thread any opportunity to process an exception for this condition.
 */
public class StackOverflowException extends RuntimeException {
	StackOverflowException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<StackOverflowException> clone() {
		ref<StackOverflowException> a = new StackOverflowException(_exceptionContext);
		return a;
	}
}
/**
 * This exception is thrown is response to a reference to an invalid address value, other than zero.
 */
public class AccessException extends RuntimeException {
	AccessException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<AccessException> clone() {
		ref<AccessException> a = new AccessException(_exceptionContext);
		return a;
	}

	public string message() {
		if (_exceptionContext == null)
			return "AccessException (not thrown)\n";
		string output;
		output.printf("AccessException: flags %d referencing %p", _exceptionContext.exceptionFlags, _exceptionContext.memoryAddress);
		return output;
	}
}
/**
 * This exception is thrown when a zero address value is referenced. Due to the way that hardware
 * instructions report failures, the detected failing address could be a small offset from zero, even
 * though any user visible object contains a zero address. For that reason, it is better to catch an
 * AccessException (this classes base class), which will include all invalid memory references.
 */
public class NullPointerException extends AccessException {
	NullPointerException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<NullPointerException> clone() {
		ref<NullPointerException> n = new NullPointerException(_exceptionContext);
		return n;
	}
}
/**
 * This is a variation of AccessException caused by inappropriate permissions on the memory location in
 * question. Typically, this will be caused by trying to write to read-only memory or trying to 
 * execute an instruction in data-only memory.
 */
public class PermissionsException extends AccessException {
	PermissionsException(ref<ExceptionContext> exceptionContext) {
		super(exceptionContext);
	}
	
	ref<PermissionsException> clone() {
		ref<PermissionsException> n = new PermissionsException(_exceptionContext);
		return n;
	}
}
/**
 * Throw an exception. It performs the exact same semantics as the throw statement.
 * The throw statement will generate this call (and provide the magic frame and stack pointer).
 *  
 * Note: This function does not return.
 * 
 * @param e The non-null Exception to be thrown.
 * @param frame The frame pointer when the exception was thrown.
 * @param stackPointer The stack pointer when the exception was thrown.
 */
void throwException(ref<Exception> e, address frame, address stackPointer) {
	e.clone().throwNow(frame, stackPointer);
	printf("Thrown!\n");
}
/**
 * Intercept an uncaught exception. This code is called from the catch handler that encloses the static initializers.
 * 
 * It is called under the scope of the ExecutionContext of the code throwing the exception. Doing this inside the
 * enclosed ExecutionContext means that the source locations are correctly aligned for the stack trace.
 * 
 * Note that this handler also exposes the exception so that the caller to eval knows that the call failed because of an
 * uncaught exception.
 * 
 * @param e The uncaught exeption.  
 */
void uncaughtException(ref<Exception> e) {
	printf("\nUncaught exception!\n\n%s\n", e.message());
	e.printStackTrace();
	process.stdout.flush();
	exposeException(e);
}
/**
 * The default hardware exception handler. This is registered early in the process start-up initialization.
 *
 * It can be replaced with a call to {@link setHardwareExceptionHandler}. You may use the address of this
 * function to restore the default handler if you have replaced it.
 *
 * This function will only throw an exception and will never return normally.
 *
 * @param info The {@link HardwareException} object containing the detailed information about the exception.
 */
public void hardwareExceptionHandler(ref<HardwareException> info) {
	ref<ExceptionContext> context = createExceptionContext(info.stackPointer);
	context.framePointer = info.framePointer;
	context.exceptionAddress = info.codePointer;
	context.memoryAddress = address(info.exceptionInfo0);
	context.exceptionFlags = info.exceptionInfo1;
	context.exceptionType = info.exceptionType;
	if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
		if (info.exceptionType == 0xffffffffc0000374) {
			throw CorruptHeapException(context);
		} else if (info.exceptionType == 0xffffffffc00000fd) {
			throw StackOverflowException(context);
		} else if (info.exceptionType == 0xffffffffc0000005) {
			if (context.memoryAddress == null)
				throw NullPointerException(context);
			else
				throw AccessException(context);
		} else if (info.exceptionType == int(0xc0000094))
			throw DivideByZeroException(context);
	} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
		switch (info.exceptionType) {
		case 0xb80:						// SIGSEGV + SI_KERNEL
		case 0xb01:						// SIGSEGV + SEGV_MAPERR
			if (context.memoryAddress == null)
				throw NullPointerException(context);
			else
				throw AccessException(context);	
			
		case 0xb02:						// SIGSEGV + SEGV_ACCERR
			throw PermissionsException(context);	
			
		case 0x801:						// SIGFPE + FPE_INTDIV
			throw DivideByZeroException(context);
			
		case 0x402:						// SIGILL + ILL_ILLOPN
			throw IllegalInstructionException(context);
			
		case 0x6fa:						// SIGABRT + tkill
			throw CRuntimeException(context);

		case 0x300:						// SIGQUIT - dump all threads
			dumpAllThreads(context);
			thread.exit(0);

		case 0x3fa:						// SIGQUIT sent from inside the house - just dump me.
			dumpMyThread(context);
			thread.exit(0);

		case 0x5fa:						// SIGTRAP + SI_TKILL = tkill system call.				
			throw CRuntimeException(context);

		case 0xf00:						// SIGTERM (simple kill command).
			if (interruptResponse.interrupt())
				return;
		}
	}
	printf("exception %x at %p\n", info.exceptionType, info.codePointer);
	printf("Unexpected exception type\n");
	throw RuntimeException(context);
}

public boolean(address), address handleInterrupt(boolean(address) handler, address argument) {
	return interruptResponse.handleInterrupt(handler, argument);
}

monitor class InterruptResponse {
	private boolean(address) _handler;
	private address _argument;

	public boolean interrupt() {
		if (_handler != null)
			return _handler(_argument);
		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
			linux.signal(linux.SIGTERM, linux.SIG_DFL);
			linux.kill(linux.getpid(), linux.SIGTERM);
		}
		return false;
	}

	public boolean(address), address handleInterrupt(boolean(address) handler, address argument) {
		boolean(address) oldHandler = _handler;
		address oldArgument = _argument;
		_handler = handler;
		_argument = _argument;
		return oldHandler, oldArgument;
	}
}

InterruptResponse interruptResponse;

/*
 * dispatchException is called from the compiler when deciding which catch clause to execute when an exception is
 * thrown.
 * 
 * Note that the body of the exception is copied from the tmeporary location to the destination if there is a match.
 * 
 * PARAMETERS
 * 	e			The thrown exception. May be any type derived from Exception.
 * 	t			The type record of the Exception class that this handler matches.
 * 	destination	If the thrown exception's type matches the passed type, then the exception is copied.
 * 	size		The amount to copy.
 * 	
 * RETURNS	true if the exception should be handled, false if it should not
 */
private boolean dispatchException(ref<Exception> e, ref<Type> t, ref<Exception> destination, int size) {
	ref<Type> actual = **ref<ref<ref<Type>>>(e);

//	printf("dispatchException %p actual %p t %p equals %s isSubtype %s\n", e, actual, t, actual.equals(t) ? "true" : "false", actual.isSubtype(t) ? "true" : "false");
//		printf("actual class %x t class %x\n", pxiOffset(**ref<ref<address>>(actual)), pxiOffset(**ref<ref<address>>(t)));
//		printf("actual vtable %x t vtable %x\n", pxiOffset(*ref<address>(actual)), pxiOffset(*ref<address>(t)));
//		printf("actual family %s t family %s\n", string(actual.family()), string(t.family()));
//	}
//	if (t.class == BuiltInType) {
//		printf("t._classType = %x\n", pxiOffset(ref<BuiltInType>(t).classType()));
//		printf("t._classType vatble %x\n", pxiOffset(*ref<address>(ref<BuiltInType>(t).classType())));
//	}
	if (actual.equals(t) || actual.isSubtype(t)) {
		C.memcpy(destination, e, size);
		return true;
	} else
		return false;
}

private int pxiOffset(address a) {
	return int(a) - int(runtime.lowCodeAddress());
	
}

ref<ExceptionContext> createExceptionContext(address stackPointer) {
	address top = runtime.stackTop();
	
	long stackSize = long(top) - long(stackPointer);
	pointer<byte> mem = pointer<byte>(memory.alloc(stackSize + ExceptionContext.bytes));
	ref<ExceptionContext> results = ref<ExceptionContext>(mem);
	results.stackCopy = mem + ExceptionContext.bytes;
	C.memcpy(results.stackCopy, stackPointer, int(stackSize));
	results.stackPointer = stackPointer;
	results.stackBase = stackPointer;
	results.stackSize = int(stackSize);
	return results;
}

/**
 * This method records in the runtime's ExecutionContext the given exception, if this is passed a null,
 * the 'uncaught exception' indicator is effectively reset. If passed a null, the enclosing ExecutionContext
 * will detect that an uncaught exception terminated execution.
 */
@Linux("libparasol.so.1", "exposeException")
@Windows("parasol.dll", "exposeException")
private abstract void exposeException(ref<Exception> e);
/**
 * Sets the process's hardware exception handler to the argument value.
 *
 * Your process starts executing with {@link hardwareExceptionHandler} as this value. If you want to
 * handle these conditions in your own way, this can achieve that goal.
 *
 * This handler is called on the thread that triggered the hardware condition being reported.
 *
 * @param handler The new hardware exception handler.
 */
@Linux("libparasol.so.1", "registerHardwareExceptionHandler")
@Windows("parasol.dll", "registerHardwareExceptionHandler")
public abstract void registerHardwareExceptionHandler(void handler(ref<HardwareException> info));
/**
 * This function is a support routine the Parasol compiler uses when running a compiled image.
 *
 * After calling the image entry point and returning, the compiler code calls this function to
 * retrieve any uncaught exception thrown in the Parasol image. If the return value is null, the
 * image code returned normally. If not null, it is the address of the uncaught exception.
 *
 * @return The function returns the address of any uncaught exception, or null if the image returned
 * normally.
 */
@Linux("libparasol.so.1", "fetchExposedException")
@Windows("parasol.dll", "fetchExposedException")
public abstract ref<Exception> fetchExposedException();

@Linux("libparasol.so.1", "exceptionsAddress")
@Windows("parasol.dll", "exceptionsAddress")
abstract address exceptionsAddress();
@Linux("libparasol.so.1", "exceptionsCount")
@Windows("parasol.dll", "exceptionsCount")
abstract int exceptionsCount();

@Linux("libparasol.so.1", "callCatchHandler")
@Windows("parasol.dll", "callCatchHandler")
abstract void callCatchHandler(ref<Exception> exception, address frame, int handler);

class ExceptionContext {
	address exceptionAddress;		// The machine instruction causing the exception
	address stackPointer;			// The thread stack point at the moment of the exception
	address framePointer;			// The hardware frame pointer at the moment of the exception
	address lastCrawledFramePointer;	// Used when re-throwing an exception to ensure proper crawl.

	// This is a copy of the hardware stack at the time of the exception.  It may extend beyond the actual
	// hardware stack at the moment of the exception because, for example, the call to create the copy used
	// the address of a local variable to get a stack offset.
	
	// To compute the address in the copy from a forensic machine address, use the following:
	//
	//	COPY_ADDRESS = STACK_ADDRESS - stackBase + stackCopy;
	
	address stackBase;			// The machine address of the hardware stack this copy was taken from
	pointer<byte> stackCopy;		// The first byte of the copy
	address memoryAddress;		// Valid only for access exceptions: memory location referenced
	int exceptionType;			// Exception type
	int exceptionFlags;			// Flags (dependent on type).
	int stackSize;				// The length of the copy
	
	boolean valid(address stackAddress) {
		return pointer<byte>(stackBase) <= pointer<byte>(stackAddress) &&
				pointer<byte>(stackAddress) < pointer<byte>(stackBase) + stackSize;
	}

	long slot(address stackAddress) {
		if (!valid(stackAddress))
			return 0;
		long addr = long(stackAddress);
		long base = long(stackBase);
		long copy = long(address(stackCopy));
		long target = addr - base + copy;
		ref<long> copyAddress = ref<long>(address(target));
		return *copyAddress;
	}
	
	void print() {
		printf("    exception address          %p\n", exceptionAddress);
		printf("    stack pointer              %p\n", stackPointer);
		printf("    frame pointer              %p\n", framePointer);
		printf("    last crawled frame pointer %p\n", lastCrawledFramePointer);
		printf("    stack base                 %p\n", stackBase);
		printf("    stack top                  %p\n", long(stackBase) + stackSize);
		printf("    exception type             %x\n", unsigned(exceptionType));
		printf("    exception flags            %x\n", unsigned(exceptionFlags));
	}
}
/**
 * This information is passed to the registered hardware exception handler.
 *
 * The contents of {@link exceptionInfo0}, {@link exceptionInfo1} and {@link exceptionType}
 * are operating-system specific.
 */
@Header
public class HardwareException {
	public address codePointer;
	public address framePointer;
	public address stackPointer;
	public long exceptionInfo0;
	public int exceptionInfo1;
	public int exceptionType;
}
/**
 * Construct a string representing a machine location, including information about relative location
 * within a compiled image.
 *
 * @param ip The machine address to obtain a source location for.
 *
 * @param offset The offset into the Parasol code image where the symbol could be found. If
 * the value is negative, then only the ip is used and it is assumed to be outside Parasol code.
 *
 * @param locationIsExact true if this is the exact address you care about. For example, if
 * it is the return address from a function, it may be pointing to the next source line so
 * pass false to this parameter and the code will adjust to look for the location one byte before
 * the given address.
 *
 * @return The formatted string.
 *
 * If the location is outside a compiled Parasol image, a native operating system utility is used to obtain
 * as good a symbolic address as reasonably possible. If no good symbolic address is available, then the
 * hex address is formatted.
 *
 * If the location is inside a compile Parasol image, the Parasol source filename and line number is returned,
 * along with the image-relative offset of the machine code.
 */
public string formattedLocation(address ip, int offset, boolean locationIsExact) {
	ref<runtime.SourceLocation> sl = runtime.getSourceLocation(ip, locationIsExact);
	if (sl == null)
		return formattedExternalLocation(ip);
	else {
		string result;

		ref<FileStat> file = sl.file;
		result.printf("%s %d (@%x)", file.filename(), file.scanner().lineNumber(sl.location) + 1, offset);
		return result;
	}
}

private string formattedExternalLocation(address ip) {
	string result;
	if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
	} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
		linux.Dl_info info;

		if (ip != null && linux.dladdr(ip, &info) != 0) {
			long symOffset = long(ip) - long(info.dli_saddr);
			if (info.dli_sname == null)
				result.printf("%s (@%p)", string(info.dli_fname), ip); 
			else
				result.printf("%s %s+0x%x (@%p)", string(info.dli_fname), string(info.dli_sname), symOffset, ip); 
			return result;
		}
	}
	result.printf("@%p", ip);
	return result;
}

private Monitor serializeDumps;

private void dumpMyThread(ref<ExceptionContext> context) {
	ref<thread.Thread> t = thread.currentThread();
	Exception e(context);
	lock (serializeDumps) {
		printf("\nThread %s (%d) stack\n", t.name(), t.id());
		process.stdout.flush();
		string s = e.textStackTrace();
		if (s.length() == 0)
			context.print();
		else
			printf("%s", s);
	}
}

private void dumpAllThreads(ref<ExceptionContext> context) {
	printf("\n\nSIGQUIT dump:\n\n");
	dumpMyThread(context);
	ref<thread.Thread> t = thread.currentThread();
	ref<thread.Thread>[] threads = thread.getActiveThreads();
	int pid = linux.getpid();
	for (int i = 0; i < threads.length(); i++) {
		if (threads[i] == t || threads[i] == null)
			continue;
//		printf("t %p thread %p\n", t, threads[i]);
		linux.tgkill(pid, int(threads[i].id()), linux.SIGQUIT);
	}
	thread.sleep(1000);
}
