/*
   Copyright 2015 Rovert Jervis

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
namespace parasol:x86_64;

import native:C;
import parasol:file;
import parasol:compiler.Arena;
import parasol:compiler.Binary;
import parasol:compiler.Block;
import parasol:compiler.ClassScope;
import parasol:compiler.CompileContext;
import parasol:compiler.CompileString;
import parasol:compiler.Constant;
import parasol:compiler.EnumInstanceType;
import parasol:compiler.FileStat;
import parasol:compiler.Function;
import parasol:compiler.FunctionType;
import parasol:compiler.Location;
import parasol:compiler.MessageId;
import parasol:compiler.Node;
import parasol:compiler.NodeList;
import parasol:compiler.Operator;
import parasol:compiler.operatorMap;
import parasol:compiler.OverloadInstance;
import parasol:compiler.ParameterScope;
import parasol:compiler.PlainSymbol;
import parasol:compiler.Reference;
import parasol:compiler.Scope;
import parasol:compiler.Selection;
import parasol:compiler.StorageClass;
import parasol:compiler.StorageClassMap;
import parasol:compiler.Symbol;
import parasol:compiler.Target;
import parasol:compiler.Type;
import parasol:compiler.TypedefType;
import parasol:compiler.TypeFamily;
import parasol:compiler.typeFamilyMap;
import parasol:compiler.Unary;
import parasol:compiler.Variable;
import parasol:pxi.Pxi;
import parasol:runtime;
import parasol:text;
/*
 * X86-64 instruction mnemonics generated by the compiler.
 */
enum X86 {
	ADD,
	ADDSD,
	ADDSS,
	AND,
	CALL,
	CMP,
	CVTSD2SI,
	CVTSD2SS,
	CVTSI2SD,
	CVTSI2SS,
	CVTSS2SD,
	CVTSS2SI,
	CWD,
	DIV,
	DIVSD,
	DIVSS,
	ENTER,
	IDIV,
	IMUL,
	LEA,
	LEAVE,
	MOV,
	MOVSD,
	MOVSS,
	MOVSX,
	MOVSX_REX_W,
	MOVSXD,
	MOVZX,
	MUL,
	MULSD,
	MULSS,
	NEG,
	NOT,
	OR,
	POP,
	PUSH,
	RET,
	SAL,
	SAR,
	SBB,
	SHR,
	SUB,
	SUBSD,
	SUBSS,
	TEST,
	UCOMISD,
	UCOMISS,
	XCHG,
	XOR,
	XORPD,
	XORPS,
	MAX_INSTRUCTION
}

int REGISTER_PARAMETER_STACK_AREA = 4 * address.bytes;

enum JumpDistance {
	UNKNOWN,
	SHORT,
	NEAR
}

class SourceLocation {
	ref<FileStat>	file;			// Source file contianing this location
	Location		location;		// Source byte offset
	int				offset;			// Code location
}

class ExceptionEntry {
	public int location;
	public int handler;
}

private int FIRST_STACK_PARAM_OFFSET = 16;

class X86_64Encoder extends Target {
	protected X86_64SectionHeader _pxiHeader;
	protected pointer<byte> _staticMemory;
	protected int _staticMemoryLength;
	protected byte[] _builtInsList;
	protected ExceptionEntry[] _exceptionTable;
	protected SourceLocation[] _sourceLocations;
	
	private ref<CodeSegment>[] _exceptionHandlers;
	private int[] _staticDataSize;
	private byte[] _imageData;								// Used to persist the symbol table
	private ref<Symbol>[][] _dataMap;
	private ref<Scope>[] _functionMap;
	private ref<FunctionState> _f;
	private byte[] _functionCode;
	private byte[] _strings;
	private ref<ClassScope>[] _vtables;
	private ref<JumpContext> _jumpContext;
	private TempStack _t;
	private byte[] _code;
	private int[] _dataOffsets;
	private ref<Fixup> _fixups;
	private int[] _pxiFixups;
	private int[] _builtIns;								// The set of built-ins referenced by this
															// file.
	
	boolean generateCode(ref<FileStat> mainFile, int valueOffset, ref<CompileContext> compileContext) {
		
		// Initialize storage - somewhere along here needs to happen
		// 
		_pxiHeader.entryPoint = generateFunction(mainFile.fileScope(), compileContext);

		if (_code.length() == 0) {
			mainFile.tree().root().add(MessageId.NO_CODE, compileContext.pool());
			return false;
		}
		appendExceptionEntry(int.MAX_VALUE, null);
		_pxiHeader.builtInOffset = _code.length();
		
		for (ref<Fixup> f = _fixups; f != null; f = f.next) {
			if (f.kind == FixupKind.BUILTIN32) {
				int b = int(f.value) - 1;
				f.value = address(assignBuiltInVector(b));
			}
		}
		_pxiHeader.builtInCount = _builtIns.length();
		for (int i = 0; i < _builtIns.length(); i++) {
			long filler = _builtIns[i];
			
			_code.append(pointer<byte>(&filler), long.bytes);
		}

		_pxiHeader.vtablesOffset = _code.length();
		
		_code.resize(_code.length() + _pxiHeader.vtableData * address.bytes);
		
		_dataOffsets.resize(address.bytes + 1);

		for (ref<Fixup> f = _fixups; f != null; f = f.next) {
			if (f.kind == FixupKind.RELATIVE32_FPDATA) {
				ref<Constant> con = ref<Constant>(f.value);
				if (con.type.family() == TypeFamily.FLOAT_32) {
					con.offset = _staticDataSize[4];
					_staticDataSize[4] += 4;
				} else {
					con.offset = _staticDataSize[8];
					_staticDataSize[8] += 8;
				}
			}
		}
		
		relocateStaticData(8);

		_pxiHeader.typeDataOffset = _code.length();
		
		populateVTables(compileContext);
		
		_pxiHeader.typeDataLength = _imageData.length();
		_code.append(_imageData);
		
		_pxiHeader.stringsOffset = _code.length();
		_pxiHeader.stringsLength = _strings.length();
		
		_code.append(_strings);

		relocateStaticData(4);
		relocateStaticData(2);
		relocateStaticData(1);
		
		_pxiHeader.relocationOffset = _code.length();

		for (ref<Fixup> f = _fixups; f != null; f = f.next) {
			switch (f.kind) {
			case	RELATIVE32_CODE:				// Fixup value is a ref<Scope>
				ref<ParameterScope> functionScope = ref<ParameterScope>(f.value);
				int target = int(functionScope.value) - 1;
				*ref<int>(&_code[f.location]) = int(target) - (f.location + int.bytes);
				break;
				
			case	RELATIVE32_DATA:				// Fixup value is a ref<Symbol>
				ref<Symbol> sym = ref<Symbol>(f.value);
				int alignment = sym.type().alignment();
				target = sym.offset;
				int ipAdjust = *ref<int>(&_code[f.location]);
				*ref<int>(&_code[f.location]) = int(sym.offset + ipAdjust - (f.location + int.bytes));
				break;
			
			case	RELATIVE32_FPDATA:				// Fixup value is a ref<Constant>
				ref<Constant> con = ref<Constant>(f.value);
				pointer<byte> endPtr;
				int targetOffset;
				if (con.type.family() == TypeFamily.FLOAT_32) {
					targetOffset = _dataOffsets[4] + con.offset;
					ref<float> target = ref<float>(&_code[targetOffset]);
					string s(con.value().data, con.value().length - 1); 
					double x = C.strtod(s.c_str(), &endPtr);
					assert(endPtr == s.c_str() + s.length());
					float y = float(x);
					*target = y;
				} else {
					targetOffset = _dataOffsets[8] + con.offset;
					ref<double> target = ref<double>(&_code[targetOffset]);
					string s = con.value().asString();
					double x = C.strtod(s.c_str(), &endPtr);
					assert(endPtr == s.c_str() + s.length());
					*target = x;
				}
//				printf("f.location=%x targetOffset=%x\n", f.location, targetOffset);
				*ref<int>(&_code[f.location]) = int(targetOffset - (f.location + int.bytes));

				break;
			
			case	RELATIVE32_TYPE:				// Fixup value is a ref<Type>
				ref<Type> type = ref<Type>(f.value);
				ipAdjust = *ref<int>(&_code[f.location]) - 1;	// copyToImage returns the offset + 1
				*ref<int>(&_code[f.location]) = int(_pxiHeader.typeDataOffset + ipAdjust - (f.location + int.bytes));
//				printf("Reference @%x to image offset %x (ordinal %x) ", f.location, _imageDataOffset + ipAdjust, type.copyToImage(this));
//				type.print();
//				printf("\n");
				break;
				
			case	RELATIVE32_STRING:				// Fixup value is an int offset into the string pool
				*ref<int>(&_code[f.location]) = _pxiHeader.stringsOffset + int(f.value) - (f.location + int.bytes);
				break;
				
			case	RELATIVE32_VTABLE:				// Fixup value is a ref<ClassScope>
				ref<ClassScope> scope = ref<ClassScope>(f.value);
				ipAdjust = *ref<int>(&_code[f.location]);
				*ref<int>(&_code[f.location]) = int(_pxiHeader.vtablesOffset + ipAdjust + (int(scope.vtable) - 1) * address.bytes - (f.location + int.bytes));
				break;
				
			case	ABSOLUTE64_JUMP:				// Fixup value is a ref<CodeSegment>
				printf("    @%x ABSOLUTE64_JUMP %p\n", f.location, f.value);
				break;
				
			case	ABSOLUTE64_CODE:				// Fixup value is a ref<Scope>
				printf("    @%x ABSOLUTE64_CODE %p\n", f.location, f.value);
				break;
				
			case	ABSOLUTE64_DATA:				// Fixup value is a ref<Symbol>
				printf("    @%x ABSOLUTE64_DATA %p\n", f.location, f.value);
				break;
				
			case	BUILTIN32:						// Fixup value is builtIn index
				*ref<int>(&_code[f.location]) = _pxiHeader.builtInOffset + int(f.value) * long.bytes - 
								(f.location + int.bytes);
			}
		}
		
		_pxiHeader.builtInsText = _code.length();
		
		_code.append(_builtInsList);
		
		int len = _code.length();
		int roundUp;
		if ((len & (address.bytes - 1)) == 0)
			roundUp = 0;
		else
			roundUp = address.bytes - (len & (address.bytes - 1));
		for (int i = 0; i < roundUp; i++)
			_code.append(byte('\x0'));
		_pxiHeader.exceptionsOffset = _code.length();
		_pxiHeader.exceptionsCount = _exceptionTable.length();
		pointer<byte> exceptionsTable = pointer<byte>(&_exceptionTable[0]); 
//		memDump(&_code, _code.bytes);
//		printf("_code.length()=%d\n", _code.length());
		_code.append(exceptionsTable, _exceptionTable.length() * ExceptionEntry.bytes);
		
		_staticMemory = &_code[0];
		_staticMemoryLength = _code.length();
		return true;
	}

	private void relocateStaticData(int alignment) {
		_dataOffsets[alignment] = _code.length();
		for (int i = 0; i < _dataMap[alignment].length(); i++) {
//			printf("  Relocating %s from %x to %x\n", _dataMap[alignment][i].name().asString(), _dataMap[alignment][i].offset, _dataMap[alignment][i].offset + _dataOffsets[alignment]);
			_dataMap[alignment][i].offset += _dataOffsets[alignment];
		}
		_dataMap[0].append(_dataMap[alignment]);
		_code.resize(_code.length() + _staticDataSize[alignment]);
		for (int i = 0; i < _dataMap[alignment].length(); i++) {
			ref<Symbol> sym = _dataMap[alignment][i];
			if (sym.type().family() == TypeFamily.TYPEDEF) {
				ref<Scope> s = sym.type().scope();
				pointer<int> p = pointer<int>(&_code[sym.offset]);
				for (ref<Symbol>[string].iterator i = s.symbols().begin(); i.hasNext(); i.next()) {
					ref<Symbol> instance = i.get();
					p[instance.offset] = instance.offset;
				}
			} else if (sym.class == PlainSymbol) {
				if (sym.type().hasVtable()) {
//					sym.print(0, false);
//					assert(false);
				}
				ref<PlainSymbol> ps = ref<PlainSymbol>(sym);
				if (ps.initializer() != null) {
					switch (ps.initializer().op()) {
					case	INTEGER:{
						ref<Constant> c = ref<Constant>(ps.initializer());
						long x = c.intValue();
						address p = &_code[sym.offset];
						C.memcpy(p, &x, sym.type().size());
						break;
					}
				//	default:
				//		target.unfinished(initializer, "initialize storage");
					}
				}
			}
		}
	}
	
	public address, int allocateImageData(int size, int alignment) {
		assert(alignment == 8);
		int blockOffset = _imageData.length();
		_imageData.resize(blockOffset + size);
		return &_imageData[blockOffset], blockOffset + 1;
	}

	public void markRegisterParameters(ref<ParameterScope> scope, ref<CompileContext> compileContext) {
		// Stack will look like:
		//
		// 		  ... stack arguments
		// TODO: Need to insert 32 byte register save area (for full binary compatibility)
		// 		  Return Address
		// RBP -> RBP (saved frame pointer)
		// saved register parameters (for now, see above) as:
		// 		  RCX / XMM0 (as needed)
		// 		  RDX / XMM1 (as needed)
		// 		  R8 / XMM2 (as needed)
		// 		  R9 / XMM3 (as needed)
		// 		  local variables
		//		  possible 8-byte padding to align stack on 16 byte boundary
		//		  32-byte register save area (per Win64 ABI)
		// 
		int assignedFastArgs = 0;
		int regStackOffset = 0;
		if (scope.hasThis()) {
			assignedFastArgs++;
			regStackOffset -= address.bytes;
		}
		if (scope.hasOutParameter(compileContext)) {
			assignedFastArgs++;	
			regStackOffset -= address.bytes;
			_f.outParameterOffset = regStackOffset;
		}
		scope.variableStorage = 0;
		for (int i = 0; i < scope.parameters().length(); i++) {
			ref<Symbol> sym = scope.parameters()[i];
			
			if (sym.deferAnalysis()) {
				sym.offset = 0;
				continue;
			}
			if (sym.type().passesViaStack(compileContext) || assignedFastArgs >= fastArgs.length()) {
				// It's a stack argument
				sym.offset = FIRST_STACK_PARAM_OFFSET + scope.variableStorage;
				scope.variableStorage += sym.type().stackSize();
			} else {
				regStackOffset -= address.bytes;
				sym.offset = regStackOffset;
				assignedFastArgs++;
			}
		}
		_f.registerSaveSize = -regStackOffset;
	}
	
	public byte registerValue(int registerArgumentIndex, TypeFamily family) {
		if (registerArgumentIndex < fastArgs.length()) {
			switch (family) {
			case	FLOAT_32:
			case	FLOAT_64:
				return byte(floatArgs[registerArgumentIndex]);

			default:
				return byte(fastArgs[registerArgumentIndex]);
			}
			return byte(fastArgs[registerArgumentIndex]);
		}
		else
			return 0;
	}
	
	protected void buildVtable(ref<ClassScope> scope, ref<CompileContext> compileContext) {
		if (scope.vtable == null) {
			scope.vtable = address(_pxiHeader.vtableData + 1);
			_pxiHeader.vtableData += scope.methods().length() + 1;
			_vtables.append(scope);
//			ref<VTable>(classScope.vtable).disassemble(0);
			for (int i = 0; i < scope.methods().length(); i++) {
				ref<OverloadInstance> method = scope.methods()[i];
				if (!method.deferAnalysis()) {
					ref<Scope> func = getFunctionAddress(method.parameterScope(), compileContext);
					if (func == null)
						scope.classType.definition().add(MessageId.UNRESOLVED_ABSTRACT, compileContext.pool(), *method.name());
				}
			}
		}
	}
	
	private void populateVTables(ref<CompileContext> compileContext) {
		if (_pxiHeader.vtableData == 0)
			return;
		int tableStart = _pxiHeader.vtablesOffset;
		for (int i = 0; i < _vtables.length(); i++) {
			ref<ClassScope> scope = _vtables[i];
			int entries = scope.methods().length() + 1;
			int tableEnd = tableStart + entries * address.bytes;
			pointer<address> table = pointer<address>(&_code[tableStart]);
			*table = address(_pxiHeader.typeDataOffset + scope.classType.copyToImage(this) - 1);
			for (int j = 1; j <= scope.methods().length(); j++) {
				ref<OverloadInstance> oi = scope.methods()[j - 1];
				ref<ParameterScope> functionScope = oi.parameterScope();
				ref<Scope> func = getFunctionAddress(functionScope, compileContext);
				int target = int(functionScope.value) - 1;
				table[j] = address(target);
			}
			tableStart = tableEnd;
		}
	}

	public void assignStorageToObject(ref<Symbol> symbol, ref<Scope> scope, int offset, ref<CompileContext> compileContext) {
		if (symbol.class == PlainSymbol) {
			ref<Type> type = symbol.assignType(compileContext);
			if (type == null)
				return;
			if (!type.requiresAutoStorage())
				return;
			int size;
			int alignment;
			type.assignSize(this, compileContext);
			switch (symbol.storageClass()) {
			case	STATIC:
				if (symbol.value == null) {
					int size = type.size();
					symbol.value = symbol;
					if (size < 0) {
						symbol.add(MessageId.UNFINISHED_ASSIGN_STORAGE, compileContext.pool(), CompileString(StorageClassMap.name[symbol.storageClass()]));
						break;
					}
					int alignment = type.alignment();
					if (_dataMap.length() <= alignment)
						_dataMap.resize(address.bytes + 1);
					_dataMap[alignment].append(symbol);
					if (_staticDataSize.length() <= alignment)
						_staticDataSize.resize(alignment + 1);
					symbol.offset = _staticDataSize[alignment];
					_staticDataSize[alignment] += size;
				}
				break;

			case	PARAMETER:
				// These were allocated above.
				break;

			case	AUTO:
				// Round auto sizes up to next slot size - do not try to optimize stack frame yet.
				size = type.stackSize();
				scope.variableStorage += size;
				symbol.offset = -scope.variableStorage;
				break;

			case	TEMPLATE_INSTANCE:
				symbol.offset = 0;
				scope.variableStorage = 0;
				break;

			case	MEMBER:
				// Align member fields, but don't reorder them - do not try to optimize stack frame yet.
				size = type.size();
				alignment = type.alignment();
				if (alignment == -1) {
					symbol.add(MessageId.UNFINISHED_ASSIGN_STORAGE, compileContext.pool(), CompileString(StorageClassMap.name[scope.storageClass()]));
				}
				scope.variableStorage = (scope.variableStorage + alignment - 1) & ~(alignment - 1);
				symbol.offset = scope.variableStorage;
				scope.variableStorage += size;
				break;

			case	ENUMERATION:{
				ref<EnumInstanceType> eit = ref<EnumInstanceType>(type);
				ref<Symbol> typeDefinition = eit.symbol();
				if (typeDefinition.value == null)
					assignStorageToObject(typeDefinition, typeDefinition.enclosing(), 0, compileContext);
				symbol.value = typeDefinition.value;
			}	break;

			default:
				symbol.add(MessageId.UNFINISHED_ASSIGN_STORAGE, compileContext.pool(), CompileString(StorageClassMap.name[scope.storageClass()]));
			}
		}
	}

	public boolean disassemble(ref<Arena> arena) {
		Disassembler d(arena, 0, _staticMemoryLength, _staticMemory, &_pxiHeader);
		d.setFixups(&_pxiFixups);
		d.setFixups(_fixups);
		d.setDataMap(&_dataMap[0][0], _dataMap[0].length());
		d.setSourceLocations(&_sourceLocations[0], _sourceLocations.length());
		for (int i = 8; i > 0; i >>= 1) {
			int length = _dataOffsets[i / 2] - _dataOffsets[i];
			if (length > 0)
				printf("  data align %d length %5d\n", i, length);
		}
		printf("  string       length %5d\n", _strings.length());
		return d.disassemble();
	}

	public abstract ref<Scope>, boolean getFunctionAddress(ref<ParameterScope> functionScope, ref<CompileContext> compileContext);
	
	int generateFunction(ref<Scope> scope, ref<CompileContext> compileContext) {
		// Sketch of the code generator:
		// 1 optimization, tree clean up and all tree-level rewrites.
		// 2 block decomposition (partial flattening of control-flow)
		// 3 register allocation
		// 4 instruction selection
		// 5 jump clean-up
		// 6 instruction ordering
		// 7 coding
		FunctionState f;
		RegisterState r(&_t);
		f.r = &r;
		f.firstCode = _functionCode.length();
		f.firstExceptionEntry = _exceptionTable.length();
		f.avail = longMask|floatMask;
		f.current = scope;
		f.oldestUnspilled = f.tempBase = _t.stackDepth();

		ref<FunctionState> savedState = _f;

		_f = &f;
		if (scope.class == ParameterScope) {
			ref<ParameterScope> parameterScope = ref<ParameterScope>(scope);
			markRegisterParameters(parameterScope, compileContext);
		}
		f.autoSize = scope.autoStorage(this, _f.registerSaveSize, compileContext);
		generateFunctionCore(scope, compileContext);
		int offset = packFunction();
		_f = savedState;
		_functionMap.append(scope);
		return offset;
	}

	private int packFunction() {
		closeCodeSegment(CC.NOP, null);
		int length = optimizeJumps(_f.first);
		int allocation = (length + address.bytes - 1) & ~(address.bytes - 1);
		int offset = _code.length();
		_code.resize(offset + allocation);
		for (int i = length; i < allocation; i++)
			_code[offset + i] = 0x37;						// Make it an AAA instruction to fill space.
		
		int nextCopy = offset;
		for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next) {
			for (int i = 0; i < cs.sourceLocations.length(); i++)
				cs.sourceLocations[i].offset += nextCopy;
			_sourceLocations.append(cs.sourceLocations);
			emitExceptionEntry(nextCopy, cs.exceptionHandler);
			C.memcpy(&_code[nextCopy], &_functionCode[cs.codeOffset], cs.length);
			while (cs.fixups != null) {
				ref<Fixup> fx = cs.fixups;
				cs.fixups = fx.next;
				fx.next = _fixups;
				_fixups = fx;
				fx.location += nextCopy;
			}
			nextCopy += cs.length;
			switch (cs.continuation) {
			case	JO:				// Jump on overflow
			case	JNO:			// Jump not overflow
			case	JB:				// Jump below (unsigned <)
			case	JNB:			// Jump not below (unsigned >=)
			case	JE:				// Jump equal / zero
			case	JNE:			// Jump not equal / zero
			case	JNA:			// Jump not above (unsigned <=)
			case	JA:				// Jump above (unsigned >)
			case	JS:				// Jump on sign
			case	JNS:			// Jump on no sign
			case	JP:				// Jump parity even
			case	JNP:			// Jump parity odd
			case	JL:				// Jump less (sign <)
			case	JGE:			// Jump greater or equal (signed >=)
			case	JLE:			// Jump less or equal (signed <=)
			case	JG:				// Jump greater (signed >)
				if (cs.jumpDistance == JumpDistance.SHORT) {
					_code[nextCopy++] = byte(0x70 + int(cs.continuation) - 1);
					_code[nextCopy] = byte(offset + cs.jumpTarget.segmentOffset - (nextCopy + 1));
					nextCopy++;
				} else {
					_code[nextCopy++] = 0x0f;
					_code[nextCopy++] = byte(0x80 + int(cs.continuation) - 1);
					*ref<int>(&_code[nextCopy]) = offset + cs.jumpTarget.segmentOffset - (nextCopy + int.bytes);
					nextCopy += int.bytes;
				}
				break;
				
			case	JMP:
				if (cs.jumpDistance == JumpDistance.SHORT) {
					_code[nextCopy++] = 0xeb;
					_code[nextCopy] = byte(offset + cs.jumpTarget.segmentOffset - (nextCopy + 1));
					nextCopy++;
				} else {
					_code[nextCopy++] = 0xe9;
					*ref<int>(&_code[nextCopy]) = offset + cs.jumpTarget.segmentOffset - (nextCopy + int.bytes);
					nextCopy += int.bytes;
				}
			}
		}
		for (int i = _f.firstExceptionEntry; i < _exceptionTable.length(); i++) {
			if (_exceptionHandlers[i] != null)
				_exceptionTable[i].handler = offset + _exceptionHandlers[i].segmentOffset;
		}
		_functionCode.resize(_f.firstCode);
		return offset;
	}

	public abstract void generateFunctionCore(ref<Scope> scope, ref<CompileContext> compileContext);
	
	class FunctionState {
//		public long allocatedRegisters;
		public int autoSize;
		public int firstCode;
		public int firstExceptionEntry;
		public ref<CodeSegment> first;
		public ref<CodeSegment> last;
		public ref<CodeSegment> emitting;
		public ref<CodeSegment> currentHandler;
		public long avail;
		public long freeRegisters;
		public long usedRegisters;
		public int tempBase;			// Index of the first temp in the function.
		public int oldestUnspilled;		// Index of the oldest unspilled temporary. 
		public ref<RegisterState> r;
		public byte doesFit;
		public byte anyPushed;
		public ref<Scope> current;
		public int outParameterOffset;
		public int registerSaveSize;
	}

	class CodeSegment {
		public ref<CodeSegment> prev;
		public ref<CodeSegment> next;
		public CC continuation;
		public JumpDistance jumpDistance;
		public ref<CodeSegment> jumpTarget;
		public ref<CodeSegment> exceptionHandler;
		public ref<Fixup> fixups;
		public int codeOffset;				// offset in _functionCode array where code is stored.
		public int length;
		public int ordinal;
		public int segmentOffset;
		public SourceLocation[] sourceLocations;
		
		CodeSegment() {
			continuation = CC.NOP;
			jumpDistance = JumpDistance.UNKNOWN;
		}

		void start(ref<X86_64Encoder> encoder) {
			encoder.closeCodeSegment(CC.NOP, null);
			codeOffset = encoder._functionCode.length();
			prev = encoder._f.last;
			if (encoder._f.last == null)
				encoder._f.first = this;
			else
				encoder._f.last.next = this;
			encoder._f.last = this;
			encoder._f.emitting = this;
	//			printf("Starting code segment\n");
	//			print(target);
			exceptionHandler = encoder._f.currentHandler;
		}
		
		void print(ref<X86_64Encoder> encoder) {
			printf("%p: %p %p %s %d[%d] ord %d seg offs %d\n", this, prev, next, ccLabel(continuation), codeOffset, length, ordinal, segmentOffset);
			text.memDump(&encoder._functionCode[codeOffset], length);
			for (ref<Fixup> f = fixups; f != null; f = f.next)
				f.print();
		}
	}

	ref<CodeSegment> pushExceptionHandler(ref<CodeSegment> handler) {
		closeCodeSegment(CC.NOP, null);
		ref<CodeSegment> outerHandler = _f.currentHandler;
		_f.currentHandler = handler;
		return outerHandler;
	}
	
	void emitExceptionEntry(int location, ref<CodeSegment> handler) {
		
		// If we have no table yet, behave as if we are in 'null' state.
		if (handler == null && _exceptionTable.length() == 0)
			return;

		int i = _exceptionTable.length() - 1;
		
		// If we are already under this handler, stay there.
		if (i >= 0 && _exceptionHandlers[i] == handler)
			return;
		appendExceptionEntry(location, handler);
	}
	
	private void appendExceptionEntry(int location, ref<CodeSegment> handler) {
		ExceptionEntry ee;
		
		ee.location = location;
		ee.handler = 0;
		_exceptionTable.append(ee);
		_exceptionHandlers.append(handler);
	}

	void inst(X86 instruction, ref<Node> left, ref<Node> right, ref<CompileContext> compileContext) {
		if (left.deferGeneration() || right.deferGeneration())
			return;
		if (right.op() == Operator.SEQUENCE) {
			inst(instruction, left, ref<Binary>(right).right(), compileContext);
			return;
		}
		if ((left.flags & ADDRESS_MODE) != 0) {
			if (right.register != 0)
				inst(instruction, left, R(int(right.register)), compileContext);
			else if (right.isConstant()) {
				ref<Constant> c = ref<Constant>(right);
				if (c.representedBy(compileContext.arena().builtInType(TypeFamily.SIGNED_32)))
					inst(instruction, left, int(c.intValue()), compileContext);
				else {
					printf("%s - -", opcodeNames[instruction]);
					left.print(4);
					right.print(4);
					assert(false);
				}
			} else {
				printf("%s - -\n", opcodeNames[instruction]);
				left.print(4);
				right.print(4);
				assert(false);
			}
		} else {
			R dest = R(left.register);
			if (right.register != 0) {
				R src = R(right.register);
				inst(instruction, right.type.family(), dest, src);
			} else if (right.op() == Operator.INTEGER) {
				switch (right.type.family()) {
				case	UNSIGNED_8:
				case	UNSIGNED_32:
				case	SIGNED_32:
				case	SIGNED_64:
					ref<Constant> c = ref<Constant>(right);
					inst(instruction, left.type.family(), dest, int(c.intValue()));
					break;
					
				default:
					right.type.print();
					printf("\n");
					assert(false);
				}
			} else if ((right.flags & ADDRESS_MODE) != 0)
				inst(instruction, dest, right, compileContext);
			else {
				R src = R(int(right.register));
				inst(instruction, right.type.family(), dest, src);
			}
		}
	}
	
	/*
	 */
	void inst(X86 instruction, TypeFamily family, R dest, long operand) {
		if (dest == R.NO_REG) {
			printf("%s NO_REG %d\n", opcodeNames[instruction], operand);
			assert(false);
		}
		switch (instruction) {
		case	CALL:				// vtable call
			emit(REX_W);
			emit(0xff);
			if (operand >= -128 && operand <= 127) {
				modRM(1, 2, 0);
				emit(byte(int(operand)));
			} else {
				modRM(2, 2, 0);
				emitInt(int(operand));
			}
			return;
			
		case	CMP:
		case	ADD:
		case	AND:
		case	OR:
		case	XOR:
		case	SUB:
		case	SBB:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, R.NO_REG, dest);
				emit(0x80);
				modRM(3, group1opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(family, null, R.NO_REG, dest);
				if (operand >= -128 && operand <= 127) {
					emit(0x83);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emit(byte(int(operand)));
				} else {
					emit(0x81);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emitShort(int(operand));
				}
				return;

			case	SIGNED_32:
			case	UNSIGNED_32:
			case	ENUM:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	SIGNED_64:
			case	CLASS:
			case	FUNCTION:
				emitRex(family, null, R.NO_REG, dest);
				if (operand >= -128 && operand <= 127) {
					emit(0x83);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emit(byte(int(operand)));
				} else {
					emit(0x81);
					modRM(3, group1opcodes[instruction], rmValues[dest]);
					emitInt(int(operand));
				}
				return;
			}
			break;
			
		case	SAL:
		case	SAR:
		case	SHR:
			switch (family) {
			case	UNSIGNED_8:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xc0);
				modRM(3, group2opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
				
			case	UNSIGNED_16:
				emit(0x66);

			case	UNSIGNED_32:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xc1);
				modRM(3, group2opcodes[instruction], rmValues[dest]);
				emit(byte(int(operand)));
				return;
			}
			break;
				
		case	MOV:
			if (operand == 0) {
				inst(X86.XOR, family, dest, dest);
				return;
			}
			switch (family) {
			case	BOOLEAN:
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb0 + rmValues[dest]));
				emit(byte(int(operand)));
				return;

			case	UNSIGNED_16:
				emit(0x66);
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitShort(int(operand));
				return;

			case	SIGNED_16:
				emit(0x66);
			case	SIGNED_32:
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitInt(int(operand));
				return;
				
			case	CLASS:
			case	SIGNED_64:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	FUNCTION:
			case	ENUM:
				emitRex(family, null, R.NO_REG, dest);
				emit(byte(0xb8 + rmValues[dest]));
				emitLong(operand);
				return;
			}
		}
		printf("%s %s %s %d\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], operand);
		assert(false);
	}

	void inst(X86 instruction, R baseReg, int offset) {
		switch (instruction) {
		case	PUSH:
			emitRex(TypeFamily.VOID, null, R.NO_REG, baseReg);
			emit(0xff);
			if (offset == 0)
				modRM(0, 6, rmValues[baseReg]);
			else if (offset >= -128 && offset <= 127) {
				modRM(1, 6, rmValues[baseReg]);
				emit(byte(offset));
			} else {
				modRM(2, 6, rmValues[baseReg]);
				emitInt(offset);
			}
			return;
			
		case	SAR:
			emitRex(TypeFamily.SIGNED_64, null, R.NO_REG, baseReg);
			emit(0xd1);
			modRM(3, 7, rmValues[baseReg]);
			return;
		}
		printf("%s [%s+%d]\n", opcodeNames[instruction], regNames[baseReg], offset);
		assert(false);
	}
	/*
	 * This is actually ONE LEA instructions.  First.
	 * 
	 * 		LEA		<dest>,[dest+index*4]
	 */
	void loadEnumAddress(R dest, R enumIndex) {
		emit(byte(REX_W | rexValues[dest] | rexbValues[dest] | rexxValues[enumIndex]));
		emit(0x8d);
		modRM(0, rmValues[dest], 4);
		sib(2, rmValues[enumIndex], rmValues[dest]);
	}
	/*
	 * This is actually an LEA instruction.
	 * 
	 * 		LEA		<dest>,&enumSymbol
	 */
	void loadEnumType(R dest, ref<Symbol> enumSymbol, int offset) {
		emit(byte(REX_W | rexValues[dest]));
		emit(0x8d);
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_DATA, enumSymbol);
		emitInt(offset);
	}
	/*
	 * This is actually a SUB instruction (dest contains the negative of an enum address).
	 * 
	 * 		SUB		<dest>,&enumSymbol
	 */
	void subEnumType(R dest, ref<Symbol> enumSymbol, int offset) {
		emit(byte(REX_W | rexValues[dest]));
		emit(0x2b);
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_DATA, enumSymbol);
		emitInt(offset);
	}
	
	void inst(X86 instruction, R dest, R reg, int offset) {
		switch (instruction) {
		case	MOV:
			emitRex(TypeFamily.SIGNED_64, null, dest, reg);
			emit(byte(opcodes[instruction] + 0x03));
			if (offset >= -128 && offset <= 127) {
				modRM(1, rmValues[dest], rmValues[reg]);
				emit(byte(offset));
			} else {
				modRM(2, rmValues[dest], rmValues[reg]);
				emitInt(offset);
			}
			break;
			
		case	LEA:
			emitRex(TypeFamily.SIGNED_64, null, dest, reg);
			emit(0x8d);
			if (reg == R.RSP) {
				if (offset >= -128 && offset <= 127) {
					modRM(1, rmValues[dest], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				if (offset >= -128 && offset <= 127) {
					modRM(1, rmValues[dest], rmValues[reg]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[dest], rmValues[reg]);
					emitInt(offset);
				}
			}
			break;
			
		default:
			printf("%s, %s, %s, %d\n", opcodeNames[instruction], regNames[dest], regNames[reg], offset);
			assert(false);
		}
	}
	
	void inst(X86 instruction, TypeFamily family, R dest, int offset, R reg) {
		switch (instruction) {
		case	MOVSD:
			emit(0xf2);
			emitRex(TypeFamily.FLOAT_64, null, reg, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			if (dest == R.RSP) {
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], 4);
					sib(0, 4, 4);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], 4);
					sib(0, 4, 4);
					emitInt(offset);
				}
			} else {
				printf("%s, %s, %s, %d, %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], offset, regNames[reg]);
				assert(false);
			}
			break;
			
		case	MOV:
		case	CMP:
			emitRex(TypeFamily.SIGNED_64, null, reg, dest);
			if (dest == R.RSP) {
				switch (family) {
				case	UNSIGNED_8:
					emit(opcodes[instruction]);
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				case	SIGNED_32:
					emit(byte(opcodes[instruction] + 0x01));
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				case	REF:
				case	POINTER:
					emit(byte(opcodes[instruction] + 0x01));
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				default:
					printf("%s, %s, %s, %d, %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], offset, regNames[reg]);
					assert(false);
				}
/*
				switch (reg) {
				case	RAX:
				case	RCX:
				case	RSP:
					emit(byte(REX_W | REX_B | rexValues[reg]));
					emit(byte(opcodes[instruction] + 0x01));
					if (offset >= -128 || offset <= 127) {
						modRM(1, rmValues[reg], 4);
						sib(0, 4, 4);
						emit(byte(offset));
					} else {
						modRM(2, rmValues[reg], 4);
						sib(0, 4, 4);
						emitInt(offset);
					}
					break;
					
				default:
					printf("%s, %s, %d, %s\n", opcodeNames[instruction], regNames[dest], offset, regNames[reg]);
					assert(false);
				}
				*/
			} else {
				emit(byte(opcodes[instruction] + 0x01));
				if (offset >= -128 || offset <= 127) {
					modRM(1, rmValues[reg], rmValues[dest]);
					emit(byte(offset));
				} else {
					modRM(2, rmValues[reg], rmValues[dest]);
					emitInt(offset);
				}
				break;
			}
			break;
			
		default:
			printf("%s, %s, %d, %s\n", opcodeNames[instruction], regNames[dest], offset, regNames[reg]);
			assert(false);
		}
	}
	
	void inst(X86 instruction, TypeFamily family, R dest, R src) {
		switch (instruction) {
		case	SAL:
			switch (family) {
			case	SIGNED_32:
				emitRex(family, null, dest, R.NO_REG);
				emit(0xd3);
				modRM(3, 4, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], regNames[src]);
				assert(false);
			}
			break;
			
		case	SHR:
			switch (family) {
			case	SIGNED_32:
				emitRex(family, null, dest, R.NO_REG);
				emit(0xd3);
				modRM(3, 5, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], regNames[src]);
				assert(false);
			}
			break;
			
		case	SAR:
			switch (family) {
			case	SIGNED_32:
				emitRex(family, null, R.NO_REG, dest);
				emit(0xd3);
				modRM(3, 7, rmValues[dest]);
				return;
				
			default:
				printf("%s %s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], regNames[src]);
				assert(false);
			}
			break;
			
		case	UCOMISD:
			emit(0x66);
		case	UCOMISS:
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x2e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSD2SS:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;

		case	CVTSS2SI:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2d);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSD2SI:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_64, null, dest, src);
			emit(0x0f);
			emit(0x2d);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSI2SS:
			emit(0xf3);
			emitRex(family, null, dest, src);
			emit(0x0f);
			emit(0x2a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	CVTSI2SD:
			emit(0xf2);
			emitRex(family, null, dest, src);
			emit(0x0f);
			emit(0x2a);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x58);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x58);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5c);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MULSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x59);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MULSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x59);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	DIVSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	DIVSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x5e);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	XORPD:
			emit(0x66);
		case	XORPS:
			emitRex(TypeFamily.SIGNED_32, null, dest, src);
			emit(0x0f);
			emit(0x57);
			modRM(3, rmValues[dest], rmValues[src]);
			return;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, src, dest);
			emit(0x0f);
			emit(0x11);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, src, dest);
			emit(0x0f);
			emit(0x11);
			modRM(3, rmValues[src], rmValues[dest]);
			return;
			
		case	MOVSXD:
			emitRex(TypeFamily.SIGNED_64, null, src, dest);
			emit(0x63);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	MOVSX_REX_W:
			emitRex(TypeFamily.SIGNED_64, null, src, dest);
			emit(0x0f);
			emit(0xbf);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	XCHG:
			emitRex(family, null, src, dest);
			emit(0x87);
			modRM(3, rmValues[src], rmValues[dest]);
			return;

		case	CMP:
		case	ADD:
		case	SUB:
		case	OR:
		case	XOR:
		case	MOV:
		case	AND:
			switch (family) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x02));
				modRM(3, rmValues[dest], rmValues[src]);
				return;
				
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			case	CLASS:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	STRING:
			case	SIGNED_64:
			case	FUNCTION:
			case	ENUM:
			case	VAR:
			case	TYPEDEF:
				emitRex(family, null, dest, src);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(3, rmValues[dest], rmValues[src]);
				return;

			default:
				printf("%s %s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], regNames[src]);
				assert(false);
			}
		}
		printf("%s %s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[dest], regNames[src]);
		assert(false);
	}
	
	void inst(X86 instruction, ref<Node> operand) {
		if ((operand.flags & ADDRESS_MODE) == 0) {
			inst(instruction, operand.type.family(), R(int(operand.register)));
			return;
		}
		switch (instruction) {
		case	CALL:
			emit(0xff);
			modRM(operand, 2, 0, 0);
			break;
			
		case	NEG:
		case	NOT:
			switch (operand.type.family()) {
			case	UNSIGNED_8:
				emitRex(operand.type.family(), operand, R.NO_REG, R.NO_REG);
				emit(0xf6);
				modRM(operand, group3opcodes[instruction], 0, 0);
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	SIGNED_64:
				emitRex(operand.type.family(), operand, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(operand, group3opcodes[instruction], 0, 0);
				break;
				
			default:
				printf("%s\n", opcodeNames[instruction]);
				operand.print(0);
				assert(false);
			}
			break;
			
		default:
			printf("%s\n", opcodeNames[instruction]);
			operand.print(0);
			assert(false);
		}
	}

	void inst(X86 instruction, ref<Node> operand, ref<CompileContext> compileContext) {
		if (operand.register != 0) {
			inst(instruction, operand.type.family(), R(int(operand.register)));
			return;
		}
		switch (instruction) {
		case	PUSH:
			
		default:
			printf("%s -\n", opcodeNames[instruction]);
			operand.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, TypeFamily family, R reg) {
		switch (instruction) {
		case	CWD:
			switch (family) {
			case	SIGNED_32:
				emit(0x99);
				return;
				
			case	SIGNED_64:
				emit(REX_W);
				emit(0x99);
				return;
			}
			break;
			
		case	IDIV:
		case	NOT:
		case	NEG:
			emitRex(family, null, R.NO_REG, reg);
			emit(0xf7);
			modRM(3, group3opcodes[instruction], rmValues[reg]);
			return;			

		case	CALL:
			switch (reg) {
			case	RAX:
				emit(0xff);
				modRM(3, 2, rmValues[reg]);
				return;
			}
			break;
			
		case	PUSH:
			emitRex(TypeFamily.SIGNED_32, null, R.NO_REG, reg);
			emit(byte(0x50 + rmValues[reg]));
			return;
			
		case	POP:
			emitRex(TypeFamily.SIGNED_32, null, R.NO_REG, reg);
			emit(byte(0x58 + rmValues[reg]));
			return;
		}
		printf("%s %s %s\n", opcodeNames[instruction], typeFamilyMap.name[family], regNames[reg]);
		assert(false);
	}
	/*
	 * The left must represent an address mode.
	 */
	void inst(X86 instruction, ref<Node> left, R right, ref<CompileContext> compileContext) {
		switch (instruction) {
		case	MOVSS:
			emit(0xf3);
			emitRex(left.type.family(), left, right, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			modRM(left, rmValues[right], 0, 0);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(left.type.family(), left, right, R.NO_REG);
			emit(0x0f);
			emit(0x11);
			modRM(left, rmValues[right], 0, 0);
			break;
			
		case	CMP:
		case	AND:
		case	OR:
		case	MOV:
		case	XOR:
		case	ADD:
		case	SUB:
			switch (left.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, right, R.NO_REG);
				emit(opcodes[instruction]);
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(left.type.family(), left, right, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x01));
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	STRING:
			case	ENUM:
			case	SIGNED_64:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	FUNCTION:
				emitRex(left.type.family(), left, right, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x01));
				modRM(left, rmValues[right], 0, 0);
				break;
				
			case	CLASS:
				switch (left.type.size()) {
				case	1:
					emitRex(TypeFamily.SIGNED_8, left, right, R.NO_REG);
					emit(opcodes[instruction]);
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	2:
					emit(0x66);
					emitRex(TypeFamily.SIGNED_16, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	4:
					emitRex(TypeFamily.SIGNED_32, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				case	8:
					emitRex(TypeFamily.SIGNED_64, left, right, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x01));
					modRM(left, rmValues[right], 0, 0);
					break;
					
				default:
					printf("%s - %s\n", opcodeNames[instruction], regNames[right]);
					left.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s - %s\n", opcodeNames[instruction], regNames[right]);
				left.print(4);
				assert(false);
			}
			break;
			
		default:
			printf("%s - %s\n", opcodeNames[instruction], regNames[right]);
			left.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, R left, ref<Node> right, ref<CompileContext> compileContext) {
		if (right.deferGeneration())
			return;
		switch (instruction) {
		case	LEA:
			emitRex(TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x8d);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	MOVZX:
			emitRex(right.type.family(), right, left, R.NO_REG);
			emit(0x0f);
			emit(0xb6);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSX:
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0xbf);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSX_REX_W:
			emitRex(TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x0f);
			emit(0xbf);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSXD:
			emitRex(TypeFamily.SIGNED_64, right, left, R.NO_REG);
			emit(0x63);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MULSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x59);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	MULSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x59);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	DIVSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5e);
			modRM(right, rmValues[left], 0, 0);
			break;
			
		case	DIVSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5e);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	CVTSS2SD:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5a);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	CVTSD2SS:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x5a);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	UCOMISD:
			emit(0x66);
		case	UCOMISS:
			emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
			emit(0x0f);
			emit(0x2e);
			modRM(right, rmValues[left], 0, 0);
			break;

		case	MOV:
		case	ADD:
		case	SUB:
		case	OR:
		case	XOR:
		case	AND:
			switch (right.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x02));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	UNSIGNED_16:
			case	SIGNED_16:
				emit(0x66);
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
			case	ADDRESS:
			case	FUNCTION:
			case	REF:
			case	POINTER:
			case	STRING:
			case	ENUM:
			case	VAR:
			case	TYPEDEF:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(byte(opcodes[instruction] + 0x03));
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	CLASS:
				switch (right.type.size()) {
				case	1:
					emitRex(TypeFamily.SIGNED_8, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x02));
					modRM(right, rmValues[left], 0, 0);
					break;

				case	2:
					emit(0x66);
					emitRex(TypeFamily.SIGNED_16, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				case	4:
					emitRex(TypeFamily.SIGNED_32, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				case	8:
					emitRex(TypeFamily.SIGNED_64, right, left, R.NO_REG);
					emit(byte(opcodes[instruction] + 0x03));
					modRM(right, rmValues[left], 0, 0);
					break;
					
				default:
					printf("%s %s - (%d)\n", opcodeNames[instruction], regNames[left], right.type.size());
					right.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s %s -\n", opcodeNames[instruction], regNames[left]);
				right.print(4);
				assert(false);
			}
			break;
			
		case	DIV:
		case	IDIV:
		case	MUL:
			assert(left == R.RAX);
			switch (right.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(TypeFamily.SIGNED_8, right, left, R.NO_REG);
				emit(0xf6);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0xf7);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0xf7);
				modRM(right, group3opcodes[instruction], 0, 0);
				break;
				
			default:
				printf("%s %s -\n", opcodeNames[instruction], regNames[left]);
				right.print(4);
				assert(false);
			}
			break;
				
		case	IMUL:
			switch (right.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x0f);
				emit(0xaf);
				modRM(right, rmValues[left], 0, 0);
				break;
				
			default:
				printf("%s %s -\n", opcodeNames[instruction], regNames[left]);
				right.print(4);
				assert(false);
			}
			break;
				
		default:
			printf("%s %s -\n", opcodeNames[instruction], regNames[left]);
			right.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, R left, ref<Node> right, int immediate) {
		switch (instruction) {
		case	IMUL:
			switch (right.type.family()) {
			case	UNSIGNED_8:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x6b);
				modRM(right, rmValues[left], byte.bytes, 0);
				emit(byte(immediate));
				break;
/*				
			case	UNSIGNED_16:
				if (rexValues[left] != 0)
					emit(rexValues[left]);
				emit(0x66);
				emit(0x69);
				modRM(right, rmValues[left]);
				emitShort(immediate);
				break;
 */				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x69);
				modRM(right, rmValues[left], int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	SIGNED_64:
				emitRex(right.type.family(), right, left, R.NO_REG);
				emit(0x69);
				modRM(right, rmValues[left], int.bytes, 0);
				emitInt(immediate);
				break;
				
			default:
				printf("%s %s -, %d\n", opcodeNames[instruction], regNames[left], immediate);
				right.print(4);
				assert(false);
			}
			break;
				
		default:
			printf("%s %s -, %d\n", opcodeNames[instruction], regNames[left], immediate);
			right.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, ref<Node> left, int immediate, ref<CompileContext> compileContext) {
		switch (instruction) {
		case	IMUL:
			emitRex(left.type.family(), left, R(int(left.register)), R.NO_REG);
			if (immediate >= -128 || immediate <= 127) {
				emit(0x6b);
				modRM(left, rmValues[R(int(left.register))], byte.bytes, 0);
				emit(byte(immediate));
			} else {
				emit(0x69);
				modRM(left, rmValues[R(int(left.register))], int.bytes, 0);
				emitInt(immediate);				
			}
			break;
			
		case	TEST:
			switch (left.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf6);
				modRM(left, 0, int.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	SIGNED_64:
			case	STRING:
			case	ENUM:
			case	ADDRESS:
			case	REF:
			case	POINTER:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xf7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;

			default:
				printf("%s - %d\n", opcodeNames[instruction], int(immediate));
				left.print(4);
				assert(false);
			}
			break;
				
		case	CMP:
		case	AND:
		case	OR:
		case	XOR:
		case	ADD:
		case	SUB:
			switch (left.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x80);
				modRM(left, group1opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x81);
				modRM(left, group1opcodes[instruction], int.bytes, 0);
				emitShort(immediate);
				break;

			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
			case	STRING:
			case	ENUM:
			case	ADDRESS:
			case	REF:
			case	POINTER:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0x81);
				modRM(left, group1opcodes[instruction], int.bytes, 0);
				emitInt(immediate);
				break;

			default:
				printf("%s - %d\n", opcodeNames[instruction], int(immediate));
				left.print(4);
				assert(false);
			}
			break;
				
		case	SAL:
		case	SAR:
		case	SHR:
			switch (left.type.family()) {
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc0);
				modRM(left, group2opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_16:
				emit(0x66);
				
			case	SIGNED_32:
			case	UNSIGNED_32:
			case	SIGNED_64:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc1);
				modRM(left, group2opcodes[instruction], byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			default:
				printf("%s - %d\n", opcodeNames[instruction], int(immediate));
				left.print(4);
				assert(false);
			}
			break;
			
		case	MOV:
			switch (left.type.family()) {
			case	BOOLEAN:
			case	UNSIGNED_8:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc6);
				modRM(left, 0, byte.bytes, 0);
				emit(byte(immediate));
				break;
				
			case	UNSIGNED_32:
			case	SIGNED_32:
			case	STRING:
			case	ENUM:
			case	ADDRESS:
			case	REF:
			case	POINTER:
			case	SIGNED_64:
				emitRex(left.type.family(), left, R.NO_REG, R.NO_REG);
				emit(0xc7);
				modRM(left, 0, int.bytes, 0);
				emitInt(immediate);
				break;
				
			case	CLASS:
				switch (left.type.size()) {
				case	1:
					emit(0xc6);
					modRM(left, 0, byte.bytes, 0);
					emit(byte(immediate));
					break;
					
				case	2:
					emit(0x66);
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitShort(immediate);
					break;
					
				case	4:
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitInt(immediate);
					break;
					
				case	8:
					emit(REX_W);
					emit(0xc7);
					modRM(left, 0, int.bytes, 0);
					emitInt(immediate);
					break;
					
				default:
					printf("%s - %d\n", opcodeNames[instruction], int(immediate));
					left.print(4);
					assert(false);
				}
				break;
				
			default:
				printf("%s - %d\n", opcodeNames[instruction], int(immediate));
				left.print(4);
				assert(false);
			}
			break;
						
		default:
			printf("%s - %d\n", opcodeNames[instruction], immediate);
			left.print(4);
			assert(false);
		}
	}
	
	void inst(X86 instruction, int immediate) {
		switch (instruction) {
		case	ENTER:
			emit(0xc8);
			emit(byte(immediate));
			emit(byte(immediate >> 8));
			emit(0);
			break;
		
		case	PUSH:
			emit(REX_W);
			if (immediate >= -128 && immediate <= 127) {
				emit(0x6a);
				emit(byte(immediate));
			} else {
				emit(0x6b);
				emitInt(immediate);
			}
			break;
			
		case	RET:
			if (immediate > 0) {
				emit(0xc2);
				emitShort(immediate);
			} else
				emit(0xc3);
			break;
			
		default:
			printf("%s %d\n", opcodeNames[instruction], immediate);
			assert(false);
		}
	}
	
	void inst(X86 instruction) {
		switch (instruction) {
		case	LEAVE:
			emit(0xc9);
			return;
			
		case	RET:
			emit(0xc3);
			return;
		}
		assert(false);
	}
	
	boolean instCall(ref<ParameterScope> functionScope, ref<CompileContext> compileContext) {
		ref<Scope> func;
		boolean isBuiltIn;
		
		(func, isBuiltIn) = getFunctionAddress(functionScope, compileContext);
		if (func == null)
			return false;
		if (isBuiltIn) {
			emit(0xff);
			modRM(0, 2, 5);
			fixup(FixupKind.BUILTIN32, functionScope.value);
			emitInt(0);
		} else {
			emit(0xe8);
			fixup(FixupKind.RELATIVE32_CODE, func);
			emitInt(0);
		}
		return true;
	}
	
	boolean instLoadFunctionAddress(R dest, ref<ParameterScope> functionScope, ref<CompileContext> compileContext) {
		ref<Scope> func;
		boolean isBuiltIn;
		
		(func, isBuiltIn) = getFunctionAddress(functionScope, compileContext);
		if (func == null)
			return false;
		emit(byte(REX_W | rexValues[dest]));
		if (isBuiltIn) {
			// MOV
			emit(0x8b);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.BUILTIN32, functionScope.value);
			emitInt(0);
		} else {
			// LEA
			emit(0x8d);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.RELATIVE32_CODE, func);
		}
		emitInt(0);
		return true;
	}

	void instFunc(X86 instruction, R dest, ref<Scope> func) {
		switch (instruction) {
		case	MOV:			
			emit(byte(REX_W | rexbValues[dest]));
			emit(byte(0xb8 + rmValues[dest]));
			fixup(FixupKind.ABSOLUTE64_CODE, func);
			emitLong(0);
			break;
			
		default:
			assert(false);
		}
	}
	
	void instBuiltIn(X86 instruction, R dest, address builtInId) {
		switch (instruction) {
		case	MOV:			
			emit(byte(REX_W | rexValues[dest]));
			emit(0x8b);
			modRM(0, rmValues[dest], 5);
			fixup(FixupKind.BUILTIN32, builtInId);
			emitInt(0);
			break;
			
		default:
			assert(false);
		}
	}
	
	void instPush(ref<Node> node, int offset) {
		if (node.register != 0) {
			inst(X86.PUSH, TypeFamily.ADDRESS, R(int(node.register)));
			return;
		}
		switch (node.op()) {
		case	DOT:
		case	IDENTIFIER:
			ref<Symbol> sym = node.symbol();
			if (sym == null) {
				node.print(0);
				assert(false);
			}
			switch (sym.storageClass()) {
			case	STATIC:
				emit(0xff);
				modRM(0, 6, 5);
				fixup(FixupKind.RELATIVE32_DATA, sym);
				emitInt(offset);
				break;
				
			case	AUTO:
			case	PARAMETER:
				emit(0xff);
				offset += sym.offset;
				if (offset >= -128 && offset <= 127) {
					modRM(1, 6, 5);
					emit(byte(offset));
				} else {
					modRM(2, 6, 5);
					emitInt(offset);
				}
				break;
				
			case	ENUMERATION:
				ref<EnumInstanceType> t = ref<EnumInstanceType>(node.type);
				loadEnumType(R.RAX, t.symbol(), 0);
				inst(X86.PUSH, TypeFamily.ADDRESS, R.RAX);
				break;

			case	MEMBER:
				offset += sym.offset;
				if (node.op() == Operator.DOT && !ref<Selection>(node).indirect()) {
					ref<Selection> dot = ref<Selection>(node);
					instPush(dot.left(), offset);
					break;
				}
				emit(0xff);
				int regValue;
				if (node.op() == Operator.DOT) {
					ref<Selection> dot = ref<Selection>(node);
					regValue = rmValues[R(int(dot.left().register))];
				} else
					regValue = rmValues[R.RSI];
				if (offset >= -128 && offset <= 127) {
					modRM(1, 6, regValue);
					emit(byte(offset));
				} else {
					modRM(2, 6, regValue);
					emitInt(offset);
				}
				break;

			default:
				printf("StorageClass %s\n", StorageClassMap.name[sym.storageClass()]);
				node.print(0);
				assert(false);
			}
			break;
			
		case	INDIRECT:
			ref<Unary> u = ref<Unary>(node);
			R reg = R(int(u.operand().register));
			emit(0xff);
			if (offset == 0)
				modRM(0, 6, rmValues[reg]);
			else if (offset >= -128 && offset <= 127) {
				modRM(1, 6, rmValues[reg]);
				emit(byte(offset));
			} else {
				modRM(2, 6, rmValues[reg]);
				emitInt(offset);
			}
			break;
			
		case	VARIABLE:
			emit(0xff);
			ref<Variable> v = ref<Reference>(node).variable();
			offset += v.offset + ref<Reference>(node).offset(); 
			if (offset >= -128 && offset <= 127) {
				modRM(1, 6, 5);
				emit(byte(offset));
			} else {
				modRM(2, 6, 5);
				emitInt(offset);
			}
			break;
			
		case	SEQUENCE:
			ref<Binary> b = ref<Binary>(node);
			instPush(b.right(), offset);
			break;
			
		default:
			node.print(0);
			assert(false);
		}
	}
	
	public void inst(X86 instruction, R dest, ref<Symbol> constant) {
		switch (instruction) {
		case	XORPD:
			emit(0x66);
		case	XORPS:
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x57);
			break;
			
		case	MOVSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			break;
			
		case	MOVSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x10);
			break;
			
		case	ADDSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			break;
			
		case	ADDSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x58);
			break;
			
		case	SUBSD:
			emit(0xf2);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			break;
			
		case	SUBSS:
			emit(0xf3);
			emitRex(TypeFamily.SIGNED_32, null, dest, R.NO_REG);
			emit(0x0f);
			emit(0x5c);
			break;
			
		default:
			printf("%s %s \n", opcodeNames[instruction], regNames[dest]);
			constant.print(0, false);
			assert(false);
			emit(0x10);
		}
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_DATA, constant);
		emitInt(0);
	}
	
	public void instLoadType(R destination, ref<Type> type) {
		emit(REX_W);
		emit(0x8d);			// LEA
		modRM(0, rmValues[destination], 5);
		fixup(FixupKind.RELATIVE32_TYPE, type);
		emitInt(type.copyToImage(this));
	}
	
	public void instStoreVTable(R thisPointer, R tempRegister, ref<ClassScope> scope) {
		instLoadVtable(tempRegister, scope);
		emit(REX_W);
		emit(0x89);			// MOV
		modRM(0, rmValues[tempRegister], rmValues[thisPointer]);
	}
	
	public void instLoadVtable(R dest, ref<ClassScope> scope) {
		emit(REX_W);
		emit(0x8d);			// LEA
		modRM(0, rmValues[dest], 5);
		fixup(FixupKind.RELATIVE32_VTABLE, scope);
		emitInt(0);
	}
	/*
	 * ipAdjust is an adjustment that should be applied to ip relative address modes.
	 * allAdjust is an adjustment that should be applied to all address modes.
	 */
	private void modRM(ref<Node> addressMode, int regOpcode, int ipAdjust, int allAdjust) {
		if (addressMode.register != 0) {
			modRM(3, regOpcode, rmValues[R(int(addressMode.register))]);
			return;
		}
		switch (addressMode.op()) {
		case	SEQUENCE:
			b = ref<Binary>(addressMode);
			modRM(b.right(), regOpcode, ipAdjust, allAdjust);
			break;
			
		case	THIS:
		case	SUPER:
			modRM(3, regOpcode, 6);
			break;
			
		case	VARIABLE:
			ref<Variable> v = ref<Reference>(addressMode).variable();
			int offset = v.offset + ref<Reference>(addressMode).offset() + allAdjust;
			if (offset >= -128 && offset <= 127) {
				modRM(1, regOpcode, 5);
				emit(byte(offset));
			} else {
				modRM(2, regOpcode, 5);
				emitInt(offset);
			}
			break;
			
		case	DOT:
		case	IDENTIFIER:
			ref<Symbol> sym = addressMode.symbol();
			if (sym == null) {
				addressMode.print(0);
				assert(false);
			}
			switch (sym.storageClass()) {
			case	STATIC:
				modRM(0, regOpcode, 5);
				if (addressMode.type.family() == TypeFamily.TYPEDEF) {
					ref<TypedefType> tt = ref<TypedefType>(addressMode.type);
					ref<Type> t = tt.wrappedType();
					fixup(FixupKind.RELATIVE32_TYPE, t);
					emitInt(t.copyToImage(this));
				} else {
					fixup(FixupKind.RELATIVE32_DATA, sym);
					emitInt(-ipAdjust + allAdjust);
				}
				break;
				
			case	ENUMERATION:
				modRM(0, regOpcode, 5);
				ref<EnumInstanceType> t = ref<EnumInstanceType>(addressMode.type);
				fixup(FixupKind.RELATIVE32_DATA, t.symbol());
				emitInt(-ipAdjust + allAdjust + sym.offset * int.bytes);
				break;
				
			case	AUTO:
			case	PARAMETER:
				int offset = sym.offset + allAdjust;
				if (offset >= -128 && offset <= 127) {
					modRM(1, regOpcode, 5);
					emit(byte(offset));
				} else {
					modRM(2, regOpcode, 5);
					emitInt(offset);
				}
				break;
				
			case	MEMBER:
				int baseReg;
				if (addressMode.op() == Operator.IDENTIFIER)
					baseReg = 6;
				else {
					ref<Selection> dot = ref<Selection>(addressMode);
					ref<Node> object = dot.left();
					while (object.op() == Operator.SEQUENCE) {
						ref<Binary> b = ref<Binary>(object);
						object = b.right();
					}
					if ((object.flags & ADDRESS_MODE) != 0) {
						modRM(object, regOpcode, ipAdjust, sym.offset + allAdjust);
						return;
					} else
						baseReg = rmValues[R(int(object.register))];
				}
				allAdjust += sym.offset;
				if (allAdjust >= -128 && allAdjust <= 127) {
					modRM(1, regOpcode, baseReg);
					emit(byte(allAdjust));
				} else {
					modRM(2, regOpcode, baseReg);
					emitInt(allAdjust);
				}
				break;

			default:
				printf("modRM(Identifier, %d)\n", regOpcode);
				addressMode.print(4);
				assert(false);
			}
			break;
			
		case	FLOATING_POINT:
			modRM(0, regOpcode, 5);
			fixup(FixupKind.RELATIVE32_FPDATA, addressMode);
			emitInt(0);
			break;
			
		case	TEMPLATE_INSTANCE:
			modRM(0, regOpcode, 5);
			ref<TypedefType> tt = ref<TypedefType>(addressMode.type);
			ref<Type> tp = tt.wrappedType();
			fixup(FixupKind.RELATIVE32_TYPE, tp);
			emitInt(tp.copyToImage(this));
			break;
			
		case	INDIRECT:
			ref<Unary> u = ref<Unary>(addressMode);
			ref<Node> ptr = u.operand();
			int baseReg;
			if (ptr.op() == Operator.THIS || ptr.op() == Operator.SUPER)
				baseReg = 6;
			else if (ptr.register != 0)
				baseReg = rmValues[R(int(ptr.register))];
			else if (ptr.deferGeneration())
				baseReg = 0;
			else {
				printf("modRM(-, %d)\n", regOpcode);
				addressMode.print(4);
				assert(false);
			}
			if (allAdjust == 0) {
				modRM(0, regOpcode, baseReg);
			} else if (allAdjust >= -128 && allAdjust <= 127) {
				modRM(1, regOpcode, baseReg);
				emit(byte(allAdjust));
			} else {
				modRM(2, regOpcode, baseReg);
				emitInt(allAdjust);
			}
			break;
			
		case	SUBSCRIPT:
			ref<Binary> b = ref<Binary>(addressMode);
			int mod = 0;
			if (b.left().type.family() == TypeFamily.STRING)
				mod = 1;
			modRM(mod, regOpcode, 4);
			R r1 = R(int(b.left().register));
			R r2 = R(int(b.right().register));
			int scale = 0;
			int sz = b.type.size();
			assert(sz <= address.bytes);
			while (sz > 1) {
				scale += 1;
				sz >>= 1;
			}
			sib(scale, rmValues[r2], rmValues[r1]);
			if (mod == 1)
				emit(4);
			break;
			
		case	STRING:
			ref<Constant> c = ref<Constant>(addressMode);
			CompileString cs = c.value();
			string s(cs.data, cs.length);
			string output;
			boolean result;
			(output, result) = s.unescapeC();
			offset = _strings.length();
			int sLength = output.length();
			_strings.resize(offset + int.bytes);
			C.memcpy(&_strings[offset], &sLength, int.bytes);
			for (int i = 0; i < sLength; i++)
				_strings.append(output[i]);
			_strings.append(0);
			int used = (_strings.length() - offset) & 3;
			if (used > 0) {
				while (used < 4) {
					_strings.append(0);
					used++;
				}
			}
			modRM(0, regOpcode, 5);
			fixup(FixupKind.RELATIVE32_STRING, address(offset));
			emitInt(0);
			break;
			
		default:
			printf("modRM(-, %d)\n", regOpcode);
			addressMode.print(4);
			assert(false);
		}
	}
	/*
	 * Calculate the necessary REX bits for this addressmode.
	 */
	private void emitRex(TypeFamily family, ref<Node> addressMode, R regField, R baseField) {
		byte rex = 0;
		if (addressMode == null)
			rex |= rexbValues[baseField];
		else if (addressMode.register != 0)
			rex |= rexbValues[R(int(addressMode.register))];
		else {
			switch (addressMode.op()) {
			case	SEQUENCE:
				b = ref<Binary>(addressMode);
				emitRex(family, b.right(), regField, baseField);
				return;
				
			case	THIS:
			case	SUPER:
			case	VARIABLE:
			case	TEMPLATE_INSTANCE:
			case	STRING:
			case	FLOATING_POINT:
				break;
				
			case	DOT:
			case	IDENTIFIER:
				ref<Symbol> sym = addressMode.symbol();
				if (sym == null) {
					addressMode.print(0);
					assert(false);
				}
				switch (sym.storageClass()) {
				case	STATIC:
				case	AUTO:
				case	PARAMETER:
				case	ENUMERATION:
					break;
					
				case	MEMBER:
					int baseReg;
					if (addressMode.op() != Operator.IDENTIFIER) {
						ref<Selection> dot = ref<Selection>(addressMode);
						ref<Node> object = dot.left();
						while (object.op() == Operator.SEQUENCE) {
							ref<Binary> b = ref<Binary>(object);
							object = b.right();
						}
						rex |= rexbValues[R(object.register)];
					}
					break;

				default:
					printf("emitRex(-, %s, %s)\n", regNames[regField], regNames[baseField]);
					addressMode.print(4);
					assert(false);
				}
				break;
				
			case	INDIRECT:
				ref<Unary> u = ref<Unary>(addressMode);
				ref<Node> ptr = u.operand();
				rex |= rexbValues[R(int(ptr.register))];
				break;
				
			case	SUBSCRIPT:
				ref<Binary> b = ref<Binary>(addressMode);
				R r1 = R(int(b.left().register));
				R r2 = R(int(b.right().register));
				rex |= rexbValues[r1];
				rex |= rexxValues[r2];
				break;
				
			default:
				printf("emitRex(-, %s, %s)\n", regNames[regField], regNames[baseField]);
				addressMode.print(4);
				assert(false);
			}
		}
		switch (family) {
		case	SIGNED_64:
		case	UNSIGNED_64:
		case	STRING:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	ENUM:
		case	FUNCTION:
		case	CLASS:
		case	FLOAT_64:
		case	TYPEDEF:
			rex |= REX_W;
		}
		rex |= rexValues[regField];
		if (rex != 0)
			emit(rex);
	}
		
	private void modRM(int mod, int regOpcode, int rm) {
//		printf("modRM(%d, %d, %d)\n", mod, regOpcode, rm);
		assert(regOpcode >= 0 && regOpcode < 8);
		assert(rm >= 0 && rm < 8);
		assert(mod >= 0 && mod < 4);
		emit(byte((mod << 6) | (regOpcode << 3) | rm));
	}
	
	private void sib(int scale, int index, int base) {
		emit(byte((scale << 6) | (index << 3) | base));
	}
	
	private void emit(byte b) {
		ensureCodeSegment();
		_functionCode.append(b);
	}
	
	private void emitShort(int immediate) {
		for (int i = 0; i < char.bytes; i++) {
			emit(byte(immediate));
			immediate >>= 8;
		}
	}
	
	private void emitInt(int immediate) {
		for (int i = 0; i < int.bytes; i++) {
			emit(byte(immediate));
			immediate >>= 8;
		}
	}
	
	private void emitLong(long immediate) {
		for (int i = 0; i < address.bytes; i++) {
			emit(byte(int(immediate)));
			immediate >>= 8;
		}
	}
	
	int tempStackDepth() {
		return _t.stackDepth();
	}
	
	void emitSourceLocation(ref<FileStat> file, Location location) {
		ensureCodeSegment();

		SourceLocation loc;
		
		loc.file = file;;
		loc.location = location;
		loc.offset = _functionCode.length() - _f.emitting.codeOffset;
		_f.emitting.sourceLocations.append(loc);
	}
	
	protected boolean inlineEllipsisArguments(ref<NodeList> args, ref<NodeList> params) {
		ref<Unary> ellipsis = params.node.getProperEllipsis();
		
		// If there is no delcared ellipsis, this is not an inline array call
		if (ellipsis == null)
			return false;
		
		// A call with no optional inline arguments is an inline call.
		if (args == null)
			return true;
		
		// A call with more arguments than parameters is an inline call.
		if (args.next != null)
			return true;
		
		// If the one argument is not the correct array type, it is inline
		return !args.node.type.equals(params.node.type);
	}

	protected boolean usesStack(int i, ref<Type> t, ref<CompileContext> compileContext) {
		if (i >= fastArgs.length())
			return true;
		else
			return t.passesViaStack(compileContext);
	}
	
	void ensureCodeSegment() {
		if (_f.emitting == null) {
			ref<CodeSegment> cs = new CodeSegment();
			cs.start(this);
		}
	}
	
	private int optimizeJumps(ref<CodeSegment> code) {
		int i = 1;
		for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next) {
			cs.ordinal = i++;
			if (cs.continuation == null) {
				for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next)
					cs.print(this);
				assert(false);
			}
		}

		int size;
		boolean changed;
		do {
			changed = false;
			size = 0;
			for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next) {
				cs.segmentOffset = size;
				if (cs.continuation != CC.NOP) {
					if (cs.jumpDistance == JumpDistance.UNKNOWN) {
						if (cs.jumpTarget.ordinal < cs.ordinal) {
		
						} else {
							
						}
					}
					size += cs.jumpDistance == JumpDistance.SHORT ? minCCSize[cs.continuation] :
							maxCCSize[cs.continuation];
				}
				size += cs.length;
			}		
		} while (changed);
//		printf("After:\n");
//		for (ref<CodeSegment> cs = _f.first; cs != null; cs = cs.next)
//			cs.print(this);

		return size;
	}
	
	class JumpContext {
		private ref<CodeSegment>[] _caseLabels;
		private int _nextCase;
		private ref<JumpContext> _next;
		private ref<Node> _controller;
		private ref<CodeSegment> _breakLabel;
		private ref<CodeSegment> _continueLabel;

		public JumpContext(ref<Node> controller, ref<CodeSegment> breakLabel, ref<CodeSegment> continueLabel, ref<ref<Node>[]> nodes, ref<X86_64> target, ref<JumpContext> next) {
			_next = next;
			_controller = controller;
			_breakLabel = breakLabel;
			_continueLabel = continueLabel;
			if (nodes != null) {
				for (int i = 0; i < nodes.length(); i++) {
					_caseLabels.append(new CodeSegment);
					_nextCase++;
				}
			}
		}

		public ref<JumpContext> next() { 
			return _next; 
		}

		public ref<CodeSegment> breakLabel() {
			return _breakLabel; 
		}

		public ref<CodeSegment> continueLabel() {
			if (_controller.op() == Operator.SWITCH)
				return _next.continueLabel();
			else
				return _continueLabel;
		}

		public ref<CodeSegment> defaultLabel() {
			ref<CodeSegment> defaultLabel = _continueLabel;
			_continueLabel = null;
			return defaultLabel;
		}

		public ref<JumpContext> enclosingSwitch() {
			if (_controller.op() == Operator.SWITCH)
				return this;
			else if (_next != null)
				return _next.enclosingSwitch();
			else
				return null;
		}

		public ref<CodeSegment> nextCaseLabel() {
			--_nextCase;
			return _caseLabels[_nextCase];
		}

		ref<CodeSegment>[] caseLabels() { 
			return _caseLabels; 
		}
	}

	void pushJumpContext(ref<JumpContext> context) {
		_jumpContext = context;
	}
	
	ref<JumpContext> jumpContext() {
		return _jumpContext;
	}

	void popJumpContext() {
		_jumpContext = _jumpContext.next();
	}

	void closeCodeSegment(CC continuation, ref<CodeSegment> jumpTarget) {
		if (_f.emitting == null) {
			if (continuation == CC.NOP)
				return;
			ref<CodeSegment> cs = new CodeSegment;
			cs.start(this);
		}
		_f.emitting.length = _functionCode.length() - _f.emitting.codeOffset; 
		_f.emitting.continuation = continuation;
		_f.emitting.jumpTarget = jumpTarget;
		_f.emitting = null;
	}
	
	void insertPreamble() {
		ref<CodeSegment> cs = new CodeSegment;
		cs.next = _f.first;
		cs.codeOffset = _functionCode.length();
		if (_f.first != null)
			_f.first.prev = cs;
		else
			_f.last = cs;
		_f.first = cs;
		_f.emitting = cs;
	}

	private void fixup(FixupKind kind, address value) {
		 ref<Fixup> f = new Fixup();
		 f.kind = kind;
		 f.location = _functionCode.length() - _f.emitting.codeOffset;
		 f.value = value;
		 f.next = _f.emitting.fixups;
		 _f.emitting.fixups = f;
	}
	
	private int assignBuiltInVector(int builtInId) {
		for (int i = 0; i < _builtIns.length(); i++)
			if (_builtIns[i] == builtInId)
				return i;
		int result = _builtIns.length();
		_builtIns.append(builtInId);
		string name(runtime.builtInFunctionName(builtInId));
		for (int i = 0; i < name.length(); i++)
			_builtInsList.append(name[i]);
		_builtInsList.append(0);
		return result;
	}
	
	protected byte[] functionCode() {
		return _functionCode;
	}
	
	protected ref<FunctionState> f() {
		return _f;
	}

	public int imageLength() {
		return X86_64SectionHeader.bytes + _staticMemoryLength +
				_builtInsList.length();
	}
	
	public void writePxiFile(file.File pxiFile) {
		pxiFile.write(&_pxiHeader, _pxiHeader.bytes);
		pxiFile.write(_staticMemory, _staticMemoryLength);
		pxiFile.write(_builtInsList);
	}
	
	public ref<X86_64SectionHeader> pxiHeader() {
		return &_pxiHeader;
	}

	public pointer<byte> staticMemory() {
		return _staticMemory;
	}
	
	public int staticMemoryLength() {
		return _staticMemoryLength;
	}
}

enum FixupKind {
	RELATIVE32_CODE,				// Fixup value is a ref<Scope>
	RELATIVE32_DATA,				// Fixup value is a ref<Symbol>
	RELATIVE32_TYPE,				// Fixup value is a ref<Type>
	RELATIVE32_STRING,				// Fixup value is an int offset into the string pool
	RELATIVE32_VTABLE,				// Fixup value is a ref<ClassScope>
	RELATIVE32_FPDATA,				// Fixup value is a ref<Constant>
	LOCAL32_CODE,					// Fixup value is a ref<CodeSegment>
	ABSOLUTE64_JUMP,				// Fixup value is a ref<CodeSegment>
	ABSOLUTE64_CODE,				// Fixup value is a ref<Scope>
	ABSOLUTE64_DATA,				// Fixup value is a ref<Symbol>
	BUILTIN32						// Fixup value is builtIn index
}

class Fixup {
	public FixupKind kind;
	public int location;						// Where the bytes to be fixed up appear in code
	public address value;						// What the value should be
	public ref<Fixup> next;						// Next fixup
	
	void print() {
		switch (kind) {
		case	RELATIVE32_CODE:				// Fixup value is a ref<Scope>
			printf("    @%x RELATIVE32_CODE %p\n", location, value);
			break;
			
		case	RELATIVE32_DATA:				// Fixup value is a ref<Symbol>
			printf("    @%x RELATIVE32_DATA %p\n", location, value);
			break;
			
		case	RELATIVE32_STRING:				// Fixup value is an int offset into the string pool
			printf("    @%x RELATIVE32_STRING %p\n", location, value);
			break;
			
		case	ABSOLUTE64_JUMP:				// Fixup value is a ref<CodeSegment>
			printf("    @%x ABSOLUTE64_JUMP %p\n", location, value);
			break;
			
		case	ABSOLUTE64_CODE:				// Fixup value is a ref<Scope>
			printf("    @%x ABSOLUTE64_CODE %p\n", location, value);
			break;
			
		case	ABSOLUTE64_DATA:				// Fixup value is a ref<Symbol>
			printf("    @%x ABSOLUTE64_DATA %p\n", location, value);
			break;
			
		case	BUILTIN32:						// Fixup value is builtIn index
			printf("    @%x BUILTIN32 %p\n", location, value);
			break;
			
		default:
			printf("    @%x <error %d> %p\n", location, int(kind), value);
		}
	}
}

private string ccLabel(CC x) {
	if (x == null)
		return "<null>";
	if (int(x) < 0 || int(x) >= int(CC.MAX_CC)) {
		string s;
		s.printf("<bad:%d>", int(x));
		return s;
	} else
		return ccLabels[x];
}
	
/*
 * X86 condition codes
 */
enum CC {
	ERROR,			// Not a valid jump
	JO,				// Jump on overflow
	JNO,			// Jump not overflow
	JB,				// Jump below (unsigned <)
	JNB,			// Jump not below (unsigned >=)
	JE,				// Jump equal / zero
	JNE,			// Jump not equal / zero
	JNA,			// Jump not above (unsigned <=)
	JA,				// Jump above (unsigned >)
	JS,				// Jump on sign
	JNS,			// Jump on no sign
	JP,			// Jump parity even
	JNP,			// Jump parity odd
	JL,				// Jump less (sign <)
	JGE,			// Jump greater or equal (signed >=)
	JLE,			// Jump less or equal (signed <=)
	JG,				// Jump greater (signed >)
	NOP,			// no-op
	JMP,			// Unconditional jump
	MAX_CC
}

private string[CC] ccLabels;

ccLabels.append("error");
ccLabels.append("jo");
ccLabels.append("jno");
ccLabels.append("jb");
ccLabels.append("jnb");
ccLabels.append("je");
ccLabels.append("jne");
ccLabels.append("jna");
ccLabels.append("ja");
ccLabels.append("js");
ccLabels.append("jns");
ccLabels.append("jpe");
ccLabels.append("jpo");
ccLabels.append("jl");
ccLabels.append("jge");
ccLabels.append("jle");
ccLabels.append("jg");
ccLabels.append("nop");
ccLabels.append("jmp");

CC parityTest(Operator compare, ref<Type> type) {
	if (type.isFloat()) {
		switch (compare) {
		case	NOT_LESS_GREATER:		return CC.NOP;
		case	LESS_GREATER:			return CC.NOP;
		case	NOT_LESS:				return CC.JP;
		case	NOT_GREATER:			return CC.NOP;
		case	NOT_LESS_EQUAL:			return CC.JP;
		case	NOT_GREATER_EQUAL:		return CC.NOP;
		case	NOT_EQUAL:				return CC.JP;
		case	EQUALITY:				return CC.JNP;
		case	GREATER:				return CC.NOP;
		case	GREATER_EQUAL:			return CC.NOP;
		case	LESS:					return CC.JNP;
		case	LESS_EQUAL:				return CC.JNP;
		case	LESS_GREATER_EQUAL:		return CC.NOP;
		case	NOT_LESS_GREATER_EQUAL:	return CC.NOP;
		
		default:
			printf("parityTest(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		return CC.ERROR;
	} else
		return CC.NOP;
}

CC continuation(Operator compare, ref<Type> type) {
	switch (compare) {
	case	NOT_LESS_GREATER:
		switch (type.family()) {
		case	UNSIGNED_32:
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	POINTER:
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JE; 
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	LESS_GREATER:
		switch (type.family()) {
		case	UNSIGNED_32:
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	POINTER:
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNE; 
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_LESS:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNB;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JGE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNB;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_GREATER:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNA;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JLE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNA;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_LESS_EQUAL:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JA;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JG; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JA;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_GREATER_EQUAL:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JB;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JL; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JB;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_EQUAL:
		switch (type.family()) {
		case	UNSIGNED_32:
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	FLOAT_32:
		case	FLOAT_64:
		case	BOOLEAN:
		case	FUNCTION:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	ENUM:
		case	CLASS:			return CC.JNE;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	EQUALITY:
		switch (type.family()) {
		case	UNSIGNED_32:
		case	SIGNED_32: 
		case	SIGNED_64: 
		case	FLOAT_32:
		case	FLOAT_64:
		case	BOOLEAN:
		case	FUNCTION:
		case	ADDRESS:
		case	REF:
		case	POINTER:
		case	ENUM:
		case	CLASS:			return CC.JE; 
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	GREATER:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JA;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JG; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JA;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	GREATER_EQUAL:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNB;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JGE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNB;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	LESS:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JB;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JL; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JB;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	LESS_EQUAL:
		switch (type.family()) {
		case	POINTER:
		case	UNSIGNED_32:	return CC.JNA;
		case	SIGNED_32: 
		case	SIGNED_64:		return CC.JLE; 
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNA;		// also need JNP
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	LESS_GREATER_EQUAL:
		switch (type.family()) {
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JNP;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	case	NOT_LESS_GREATER_EQUAL:
		switch (type.family()) {
		case	FLOAT_32:
		case	FLOAT_64:		return CC.JP;
		default:
			printf("continuation(%s,", operatorMap.name[compare]);
			type.print();
			printf(")\n");
			assert(false);
		}
		break;

	default:
		printf("continuation(%s,", operatorMap.name[compare]);
		type.print();
		printf(")\n");
		assert(false);
	}
	return CC.ERROR;
}

Operator invert(Operator compare) {
	switch (compare) {
	case	NOT_LESS_GREATER:		return Operator.LESS_GREATER;
	case	NOT_LESS_GREATER_EQUAL:	return Operator.LESS_GREATER_EQUAL;
	case	NOT_LESS:				return Operator.LESS;
	case	NOT_GREATER:			return Operator.GREATER;
	case	NOT_LESS_EQUAL:			return Operator.LESS_EQUAL;
	case	NOT_GREATER_EQUAL:		return Operator.GREATER_EQUAL;
	case	NOT_EQUAL:				return Operator.EQUALITY;
	case	EQUALITY:				return Operator.NOT_EQUAL;
	case	GREATER:				return Operator.NOT_GREATER;
	case	GREATER_EQUAL:			return Operator.NOT_GREATER_EQUAL;
	case	LESS:					return Operator.NOT_LESS;
	case	LESS_GREATER:			return Operator.NOT_LESS_GREATER;
	case	LESS_EQUAL:				return Operator.NOT_LESS_EQUAL;
	case	LESS_GREATER_EQUAL:		return Operator.NOT_LESS_GREATER_EQUAL;
	default:
		printf("invert(%s)\n", operatorMap.name[compare]);
		assert(false);
	}
	return Operator.SYNTAX_ERROR;
}

private int[CC] minCCSize;
minCCSize.resize(CC.MAX_CC);

private int[CC] maxCCSize;
maxCCSize.resize(CC.MAX_CC);

minCCSize[CC.JO] = 2;
maxCCSize[CC.JO] = 6;
minCCSize[CC.JNO] = 2;
maxCCSize[CC.JNO] = 6;
minCCSize[CC.JB] = 2;
maxCCSize[CC.JB] = 6;
minCCSize[CC.JNB] = 2;
maxCCSize[CC.JNB] = 6;
minCCSize[CC.JE] = 2;
maxCCSize[CC.JE] = 6;
minCCSize[CC.JNE] = 2;
maxCCSize[CC.JNE] = 6;
minCCSize[CC.JNA] = 2;
maxCCSize[CC.JNA] = 6;
minCCSize[CC.JA] = 2;
maxCCSize[CC.JA] = 6;
minCCSize[CC.JS] = 2;
maxCCSize[CC.JS] = 6;
minCCSize[CC.JNS] = 2;
maxCCSize[CC.JNS] = 6;
minCCSize[CC.JP] = 2;
maxCCSize[CC.JP] = 6;
minCCSize[CC.JNP] = 2;
maxCCSize[CC.JNP] = 6;
minCCSize[CC.JL] = 2;
maxCCSize[CC.JL] = 6;
minCCSize[CC.JGE] = 2;
maxCCSize[CC.JGE] = 6;
minCCSize[CC.JLE] = 2;
maxCCSize[CC.JLE] = 6;
minCCSize[CC.JG] = 2;
maxCCSize[CC.JG] = 6;
minCCSize[CC.JMP] = 2;
maxCCSize[CC.JMP] = 5;

private byte[R] rmValues;

rmValues.resize(R.MAX_REG);

rmValues[R.NO_REG] = 0xff;
rmValues[R.RAX] = 0x0;
rmValues[R.RBX] = 0x3;
rmValues[R.RCX] = 0x1;
rmValues[R.RDX] = 0x2;
rmValues[R.RSP] = 0x4;
rmValues[R.RBP] = 0x5;
rmValues[R.RSI] = 0x6;
rmValues[R.RDI] = 0x7;
rmValues[R.R8] = 0x0;
rmValues[R.R9] = 0x1;
rmValues[R.R10] = 0x2;
rmValues[R.R11] = 0x3;
rmValues[R.R12] = 0x4;
rmValues[R.R13] = 0x5;
rmValues[R.R14] = 0x6;
rmValues[R.R15] = 0x7;
rmValues[R.AH] = 0x04;
rmValues[R.XMM0] = 0x00;
rmValues[R.XMM1] = 0x01;
rmValues[R.XMM2] = 0x02;
rmValues[R.XMM3] = 0x03;
rmValues[R.XMM4] = 0x04;
rmValues[R.XMM5] = 0x05;
rmValues[R.XMM6] = 0x06;
rmValues[R.XMM7] = 0x07;
rmValues[R.XMM8] = 0x00;
rmValues[R.XMM9] = 0x01;
rmValues[R.XMM10] = 0x02;
rmValues[R.XMM11] = 0x03;
rmValues[R.XMM12] = 0x04;
rmValues[R.XMM13] = 0x05;
rmValues[R.XMM14] = 0x06;
rmValues[R.XMM15] = 0x07;

private byte[R] rexValues;
private byte[R] rexbValues;
private byte[R] rexxValues;

rexValues.resize(R.MAX_REG);
rexbValues.resize(R.MAX_REG);
rexxValues.resize(R.MAX_REG);

rexValues[R.R8] = REX_R;
rexValues[R.R9] = REX_R;
rexValues[R.R10] = REX_R;
rexValues[R.R11] = REX_R;
rexValues[R.R12] = REX_R;
rexValues[R.R13] = REX_R;
rexValues[R.R14] = REX_R;
rexValues[R.R15] = REX_R;
rexValues[R.XMM8] = REX_R;
rexValues[R.XMM9] = REX_R;
rexValues[R.XMM10] = REX_R;
rexValues[R.XMM11] = REX_R;
rexValues[R.XMM12] = REX_R;
rexValues[R.XMM13] = REX_R;
rexValues[R.XMM14] = REX_R;
rexValues[R.XMM15] = REX_R;

rexbValues[R.R8] = REX_B;
rexbValues[R.R9] = REX_B;
rexbValues[R.R10] = REX_B;
rexbValues[R.R11] = REX_B;
rexbValues[R.R12] = REX_B;
rexbValues[R.R13] = REX_B;
rexbValues[R.R14] = REX_B;
rexbValues[R.R15] = REX_B;

rexxValues[R.R8] = REX_X;
rexxValues[R.R9] = REX_X;
rexxValues[R.R10] = REX_X;
rexxValues[R.R11] = REX_X;
rexxValues[R.R12] = REX_X;
rexxValues[R.R13] = REX_X;
rexxValues[R.R14] = REX_X;
rexxValues[R.R15] = REX_X;

byte[X86] opcodes;

opcodes.resize(X86.MAX_INSTRUCTION);

opcodes[X86.ADD] = 0x00;
opcodes[X86.OR]  = 0x08;
opcodes[X86.SBB] = 0x18;
opcodes[X86.AND] = 0x20;
opcodes[X86.SUB] = 0x28;
opcodes[X86.XOR] = 0x30;
opcodes[X86.CMP] = 0x38;
opcodes[X86.MOV] = 0x88;

byte[X86] group1opcodes;

group1opcodes.resize(X86.MAX_INSTRUCTION);

group1opcodes[X86.ADD] = 0;
group1opcodes[X86.OR] = 1;
group1opcodes[X86.SBB] = 3;
group1opcodes[X86.AND] = 4;
group1opcodes[X86.SUB] = 5;
group1opcodes[X86.XOR] = 6;
group1opcodes[X86.CMP] = 7;

byte[X86] group2opcodes;

group2opcodes.resize(X86.MAX_INSTRUCTION);

group2opcodes[X86.SAL] = 4;
group2opcodes[X86.SHR] = 5;
group2opcodes[X86.SAR] = 7;

byte[X86] group3opcodes;

group3opcodes.resize(X86.MAX_INSTRUCTION);

group3opcodes[X86.NOT] = 2;
group3opcodes[X86.NEG] = 3;
group3opcodes[X86.MUL] = 4;
group3opcodes[X86.IMUL] = 5;
group3opcodes[X86.DIV] = 6;
group3opcodes[X86.IDIV] = 7;

string[X86] opcodeNames;

opcodeNames.append("ADD");
opcodeNames.append("ADDSD");
opcodeNames.append("ADDSS");
opcodeNames.append("AND");
opcodeNames.append("CALL");
opcodeNames.append("CMP");
opcodeNames.append("CVTSD2SI");
opcodeNames.append("CVTSD2SS");
opcodeNames.append("CVTSI2SD");
opcodeNames.append("CVTSI2SS");
opcodeNames.append("CVTSS2SD");
opcodeNames.append("CVTSS2SI");
opcodeNames.append("CWD");
opcodeNames.append("DIV");
opcodeNames.append("DIVSD");
opcodeNames.append("DIVSS");
opcodeNames.append("ENTER");
opcodeNames.append("IDIV");
opcodeNames.append("IMUL");
opcodeNames.append("LEA");
opcodeNames.append("LEAVE");
opcodeNames.append("MOV");
opcodeNames.append("MOVSD");
opcodeNames.append("MOVSS");
opcodeNames.append("MOVSX");
opcodeNames.append("MOVSX_REX_W");
opcodeNames.append("MOVSXD");
opcodeNames.append("MOVZX");
opcodeNames.append("MUL");
opcodeNames.append("MULSD");
opcodeNames.append("MULSS");
opcodeNames.append("NEG");
opcodeNames.append("NOT");
opcodeNames.append("OR");
opcodeNames.append("POP");
opcodeNames.append("PUSH");
opcodeNames.append("RET");
opcodeNames.append("SAL");
opcodeNames.append("SAR");
opcodeNames.append("SBB");
opcodeNames.append("SHR");
opcodeNames.append("SUB");
opcodeNames.append("SUBSD");
opcodeNames.append("SUBSS");
opcodeNames.append("TEST");
opcodeNames.append("UCOMISD");
opcodeNames.append("UCOMISS");
opcodeNames.append("xCHG");
opcodeNames.append("XOR");
opcodeNames.append("XORPD");
opcodeNames.append("XORPS");

