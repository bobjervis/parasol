/*
   Copyright 2015 Robert Jervis

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
/**
 * Provides facilities for generating random data or random number sequences.
 *
 * The core of the random number generator is based on  note at this like 
 * http://mathforum.org/kb/message.jspa?messageID=1607566.
 *
 * As stated there, the period is ~2^60, which should be long enough for most purposes.
 * It only has 32 bits of significance in the results of calls such as {@link Random.uniform}.
 */
namespace parasol:random;

import native:C;
import native:windows;
import parasol:math;
import parasol:runtime;
/**
 * A random number generator
 */
public class Random {
	private class RandomState {
		public unsigned	z;
		public unsigned	w;
	}

	private RandomState		_state;
	/**
	 *  Initialize a Random number generator with an arbitrary string of
	 * bytes.
	 *
	 *	This constructor allows an arbitrary quantity of random data.
	 *	Typically, this might be used to clone the internal state
	 *	of the random number generator or restore the state from
	 *	external storage (by using the output of Random::save).
	 *
	 *	If the supplied data is more than is needed by the algorithm,
	 *	the excess is ignored.  If less, then the additional data is
	 *	generated using what is supplied.  
	 */
	public Random(string seed) {
		set(seed);
	}
	/**
	 *	This constructor supplies an integer value as the
	 *	seed data for the generator.
	 *
	 *  If this is not enough
	 *	data to completely fill in the internal state of the generator,
	 *	the data is generated by successive calls to the generator.
	 */
	public Random(int seed) {
		set(seed);
	}
	/**
	 *	This constructor initializes the state of the generator using
	 *	a cryptographically secure method native to the host operating
	 *	system (CryptGenRandom in Windows).  This constructor may require
	 *	operating system or even external device interactions, and so should
	 *	not be used for high-speed initialization of random number generators.
	 */
	public Random() {
		set();
	}
	/**
	 * Save the internal state of the generator.
	 *
	 * This string is not suitable for display or text processing, but it can be 
	 * passed to the constructor of another Random object, which will then generate
	 * the same values this generator will.
	 *
	 * @return The state of the generator, represented as a string of bytes
	 * (but not utf-8).
	 */
	public string save() {
		return string(pointer<byte>(&_state), _state.bytes);
	}

	public void set(string seed) {
		int i = seed.length();
		if (i < _state.bytes) {
			unsigned jcong = 0;

			if (i > jcong.bytes)
				i = jcong.bytes;
			C.memcpy(&jcong, seed.c_str(), i);
			
			jcong = nextCongruential(jcong);
			_state.z = jcong;
			jcong = nextCongruential(jcong);
			_state.w = jcong;
		} else
			C.memcpy(&_state, seed.c_str(), _state.bytes);
	}

	private unsigned nextCongruential(unsigned jcong) {
		return 69069 * jcong + 1234567;
// Use these constants for a 64-bit generator (from Knuth)
//		return 6364136223846793005 * jcong + 1442695040888963407;
	}

	void set(long seed) {
		string s(pointer<byte>(&seed), seed.bytes);
		set(s);
	}

	void set() {
		if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
			byte[] b;
			b.resize(long.bytes);
			if (windows.BCryptGenRandom(null, &b[0], windows.ULONG(b.length()), windows.BCRYPT_USE_SYSTEM_PREFERRED_RNG) == windows.STATUS_SUCCESS)
				set(*ref<long>(&b[0]));
			else
				set(C.time(null));
		} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
			ref<C.FILE> f = C.fopen("/dev/urandom".c_str(), "rb".c_str());
			if (f == null)
				set(C.time(null));
			else {
				long x;
				C.fread(&x, 1, unsigned(x.bytes), f);
				C.fclose(f);
				set(x);
			}
		} else
			set(C.time(null));
	}
	/**
	 *	Returns a uniformly distributed 32-bit unsigned integer.
	 */
	public unsigned next() {
		_state.z = 36969 * (_state.z & 0xffff) + (_state.z >> 16);
		_state.w = 18000 * (_state.w & 0xffff) + (_state.w >> 16);
		return (_state.z << 16) + (_state.w & 0xffff);
	}
	/**
	 *	Returns a uniformly distributed number in the range from
	 *  0 to 1.
	 *
	 * Zero can be returned, but one cannot be.
	 */
	public double uniform() {
		return next() / double(0x100000000);
	}
	/**
	 * Returns a uniformly distributed integer in the range from 0 - range-1, inclusive.
	 */
	public int uniform(int range) {
		return int(range * uniform());
	}
	/**
	 * calculate a normal distribution
	 *
	 * This function returns a number with a normal
	 * distribution with a mean of 0 and standard
	 * deviation of 1.
	 */
	public double normal()  {
		double x1, x2, r;

		do {
			x1 = 2 * uniform() - 1;
			x2 = 2 * uniform() - 1;
			r = x1 * x1 + x2 * x2;
		} while (r >= 1);
		double fac = math.sqrt(-2 * math.log(r) / r);
		return x2 * fac;
	}
	/**
	 * Calculate a binomial distribution
	 *
	 * This function returns a number between 0 and n according
	 * to a binomial distribution with n trials and probability of
	 * p at each trial
	 */
	public int binomial(int n, double p) {
		double mean = n * p;
		double sdev = mean * (1 - p);
		int x = int(normal() * sdev + mean);
		if (x < 0)
			x = 0;
		else if (x > n)
			x = n;
		return x;
	}
	/**
	 * This function returns the sum on n random die rolls where
	 * sides is the number of sides on each die.
	 *
	 *  The assumption is
	 * that all sides are equally likely to appear and are numbered
	 * from 1 through sides in value.
	 */
	public int dieRoll(int n, int sides) {
		int sum = 0;
		while (n > 0) {
			sum += int(sides * uniform()) + 1;
			n--;
		}
		return sum;
	}
}
/**
 * Get any number of bytes, each containing a random value.
 *
 * This method takes advantage of native operating system services that provide random bits from the
 * kernel that can serve as appropriate random number seeds.
 *
 * If no suitable operating system service is available, a {@link Random} object is seeded using a
 * default seed computed from the time of day.
 */
public byte[] getBytes(int length) {
	byte[] b;

	b.resize(length);
	if (runtime.compileTarget == runtime.Target.X86_64_WIN) {
		if (windows.BCryptGenRandom(null, &b[0], windows.ULONG(b.length()), windows.BCRYPT_USE_SYSTEM_PREFERRED_RNG) == windows.STATUS_SUCCESS)
			return b;
	} else if (runtime.compileTarget == runtime.Target.X86_64_LNX) {
		ref<C.FILE> f = C.fopen("/dev/urandom".c_str(), "rb".c_str());
		if (f != null) {
			C.fread(&b[0], 1, unsigned(length), f);
			C.fclose(f);
			return b;
		}
	}
	// fallback used when OS-specific solutions are not available.
	Random r;
	for (int i = 0; i < length; i++)
		b[i] = byte(r.uniform(256));
	return b;
}

